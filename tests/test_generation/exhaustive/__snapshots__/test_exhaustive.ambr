# name: test_async[builder.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  
  if sys.version_info >= (3, 8):
      from typing import TypedDict, Literal
  else:
      from typing_extensions import TypedDict, Literal
  
  # -- template builder.py.jinja --
  
  # TODO: the QueryBuilder should validate and add type information context.
  #       currently we just naively iterate through arguments and encode them
  #       using standard json when we don't have any special casing for it.
  #       this makes it more difficult to add support for non-standard types
  #       such as the `Json` type.
  # TODO: optimise for performance (switch to c / cython?)
  # TODO: pass context around differently, relying on the builder instance is
  #       not ideal, context should be local to each node
  
  
  import json
  import logging
  import inspect
  from textwrap import indent
  from datetime import timezone
  from abc import abstractmethod, ABC
  from functools import singledispatch
  
  from . import fields
  from .types import Serializable
  from .errors import UnknownModelError, UnknownRelationalFieldError
  
  
  log: logging.Logger = logging.getLogger(__name__)
  
  ChildType = Union['AbstractNode', str]
  
  
  GLOBAL_ALIASES: Dict[str, str] = {
      'startswith': 'startsWith',
      'endswith': 'endsWith',
      'order_by': 'orderBy',
      'not_in': 'notIn',
      'is_not': 'isNot',
  }
  
  DEFAULT_FIELDS_MAPPING: Dict[str, List[str]] = {
      'Post': [
          'id',
          'created_at',
          'title',
          'content',
          'published',
          'author_id',
      ],
      'User': [
          'id',
          'email',
          'int',
          'optional_int',
          'float',
          'optional_float',
          'string',
          'optional_string',
          'enum',
          'optional_enum',
          'boolean',
          'optional_boolean',
      ],
      'M': [
          'id',
          'int',
          'optional_int',
          'float',
          'optional_float',
          'string',
          'optional_string',
          'enum',
          'optional_enum',
          'boolean',
          'optional_boolean',
      ],
      'N': [
          'id',
          'int',
          'optional_int',
          'float',
          'optional_float',
          'string',
          'optional_string',
          'json_',
          'optional_json',
          'enum',
          'optional_enum',
          'boolean',
          'optional_boolean',
      ],
      'OneOptional': [
          'id',
          'int',
          'optional_int',
          'float',
          'optional_float',
          'string',
          'optional_string',
          'enum',
          'optional_enum',
          'boolean',
          'optional_boolean',
      ],
      'ManyRequired': [
          'id',
          'one_optional_id',
          'int',
          'optional_int',
          'float',
          'optional_float',
          'string',
          'optional_string',
          'enum',
          'optional_enum',
          'boolean',
          'optional_boolean',
      ],
      'A': [
          'id',
          'email',
          'name',
          'int',
          'sInt',
          'inc_int',
          'inc_sInt',
          'bInt',
          'inc_bInt',
      ],
      'B': [
          'id',
          'float',
          'd_float',
      ],
      'C': [
          'id',
          'char',
          'v_char',
          'text',
          'bit',
          'v_bit',
          'uuid',
      ],
      'D': [
          'id',
          'bool',
          'xml',
          'json_',
          'jsonb',
      ],
      'E': [
          'id',
          'date',
          'time',
          'ts',
      ],
  }
  
  RELATIONAL_FIELD_MAPPINGS: Dict[str, Dict[str, str]] = {
      'Post': {
          'author': 'User',
      },
      'User': {
          'posts': 'Post',
      },
      'M': {
          'n': 'N',
      },
      'N': {
          'm': 'M',
      },
      'OneOptional': {
          'many': 'ManyRequired',
      },
      'ManyRequired': {
          'one': 'OneOptional',
      },
      'A': {
      },
      'B': {
      },
      'C': {
      },
      'D': {
      },
      'E': {
      },
  }
  
  
  class QueryBuilder:
      # prisma method
      method: str
  
      # GraphQL operation
      operation: str
  
      # prisma model
      model: Optional[str]
  
      # mapping of relational fields to include in the result
      include: Optional[Dict[str, Any]]
  
      # arguments to pass to the query
      arguments: Dict[str, Any]
  
      # list of fields to select
      root_selection: Optional[List[str]]
  
      def __init__(
          self,
          *,
          method: str,
          operation: str,
          arguments: Dict[str, Any],
          model: Optional[str] = None,
          root_selection: Optional[List[str]] = None
      ) -> None:
          self.model = model
          self.method = method
          self.operation = operation
          self.root_selection = root_selection
          self.arguments = args = self._transform_aliases(arguments)
          self.include = args.pop('include', None)
  
      def build(self) -> str:
          """Build the payload that should be sent to the QueryEngine"""
          data = {
              'variables': {},
              'operation_name': self.operation,
              'query': self.build_query(),
          }
          return dumps(data)
  
      def build_query(self) -> str:
          """Build the GraphQL query
  
          Example query:
  
          query {
            result: findUniqueUser
            (
              where: {
                id: "ckq23ky3003510r8zll5m2hma"
              }
            )
            {
              id
              name
              profile {
                id
                user_id
                bio
              }
            }
          }
          """
          query = self._create_root_node().render()
          log.debug('Generated query: \n%s', query)
          return query
  
      def _create_root_node(self) -> 'RootNode':
          root = RootNode(builder=self)
          root.add(ResultNode.create(self))
          root.add(
              Selection.create(
                  self,
                  model=self.model,
                  include=self.include,
                  root_selection=self.root_selection,
              )
          )
          return root
  
      def get_default_fields(self, model: str) -> List[str]:
          """Returns a list of all the scalar fields of a model
  
          Raises UnknownModelError if the current model cannot be found.
          """
          try:
              return DEFAULT_FIELDS_MAPPING[model].copy()
          except KeyError as exc:
              raise UnknownModelError(model) from exc
  
      def get_relational_model(self, current_model: str, field: str) -> str:
          """Returns the model that the field is related to.
  
          Raises UnknownModelError if the current model is invalid.
          Raises UnknownRelationalFieldError if the field does not exist.
          """
          try:
              mappings = RELATIONAL_FIELD_MAPPINGS[current_model]
          except KeyError as exc:
              raise UnknownModelError(current_model) from exc
  
          try:
              return mappings[field]
          except KeyError as exc:
              raise UnknownRelationalFieldError(model=current_model, field=field) from exc
  
      def _transform_aliases(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
          """Transform dict keys to match global aliases
  
          e.g. order_by -> orderBy
          """
          transformed = dict()
          for key, value in arguments.items():
              alias = GLOBAL_ALIASES.get(key, key)
              if isinstance(value, dict):
                  transformed[alias] = self._transform_aliases(arguments=value)
              else:
                  transformed[alias] = value
          return transformed
  
  
  class AbstractNode(ABC):
      @abstractmethod
      def render(self) -> Optional[str]:
          """Render the node to a string
  
          None is returned if the node should not be rendered.
          """
          ...
  
      def should_render(self) -> bool:
          """If True, rendering of the node is skipped
  
          Useful for some nodes as they should only actually
          be rendered if they have any children.
          """
          return True
  
  
  class Node(AbstractNode):
      """Base node handling rendering of child nodes"""
      joiner: str
      indent: str
      builder: QueryBuilder
      children: List[ChildType]
  
      def __init__(
          self,
          builder: QueryBuilder,
          *,
          joiner: str = '\n',
          indent: str = '  ',
          children: Optional[List[ChildType]] = None
      ) -> None:
          self.builder = builder
          self.joiner = joiner
          self.indent = indent
          self.children = children if children is not None else []
  
      def enter(self) -> Optional[str]:
          """Get the string used to enter the node.
  
          This string will be rendered *before* the children.
          """
          return None
  
      def depart(self) -> Optional[str]:
          """Get the string used to depart the node.
  
          This string will be rendered *after* the children.
          """
          return None
  
      def render(self) -> Optional[str]:
          """Render the node and it's children and to string.
  
          Rendering a node involves 4 steps:
  
          1. Entering the node
          2. Rendering it's children
          3. Departing the node
          4. Joining the previous steps together into a single string
          """
          if not self.should_render():
              return None
  
          strings: List[str] = []
          entered = self.enter()
          if entered is not None:
              strings.append(entered)
  
          for child in self.children:
              content: Optional[str] = None
  
              if isinstance(child, str):
                  content = child
              else:
                  content = child.render()
  
              if content:
                  strings.append(indent(content, self.indent))
  
          departed = self.depart()
          if departed is not None:
              strings.append(departed)
  
          return self.joiner.join(strings)
  
      def add(self, child: ChildType) -> None:
          """Add a child"""
          self.children.append(child)
  
      def create_children(self) -> List[ChildType]:
          """Create the node's children
  
          If children are passed to the constructor, the children
          returned from this method are used to extend the already
          set children.
          """
          return []
  
      @classmethod
      def create(cls, builder: Optional[QueryBuilder] = None, **kwargs: Any) -> 'Node':
          """Create the node and its children
  
          This is useful for subclasses that add extra attributes in __init__
          """
          kwargs.setdefault('builder', builder)
          node = cls(**kwargs)
          node.children.extend(node.create_children())
          return node
  
  
  class RootNode(Node):
      """Rendered node examples:
  
      query {
          <children>
      }
  
      or
  
      mutation {
          <children>
      }
      """
  
      def enter(self) -> str:
          return f'{self.builder.operation} {{'
  
      def depart(self) -> str:
          return '}'
  
      def render(self) -> str:
          content = super().render()
          if not content:  # pragma: no cover
              # this should never happen.
              # render() is typed to return None if the node
              # should not be rendered but as this node will
              # always be rendered it should always return
              # a non-empty string.
              raise RuntimeError('Could not generate query.')
          return content
  
  
  class ResultNode(Node):
      """Rendered node examples:
  
      result: findUniqueUser
          <children>
  
      or
  
      result: executeRaw
          <children>
      """
      def __init__(self, indent: str = '', **kwargs: Any) -> None:
          super().__init__(indent=indent, **kwargs)
  
      def enter(self) -> str:
          model = self.builder.model
          if model is not None:
              return f'result: {self.builder.method}{model}'
  
          return f'result: {self.builder.method}'
  
      def depart(self) -> Optional[str]:
          return None
  
      def create_children(self) -> List[ChildType]:
          return [
              Arguments.create(
                  self.builder,
                  arguments=self.builder.arguments,
              )
          ]
  
  
  class Arguments(Node):
      """Rendered node example:
  
      (
          key1: "1"
          key2: "[\"John\",\"123\"]"
          key3: true
          key4: {
              data: true
          }
      )
      """
      arguments: Dict[str, Any]
  
      def __init__(self, arguments: Dict[str, Any], **kwargs: Any) -> None:
          super().__init__(**kwargs)
          self.arguments = arguments
  
      def should_render(self) -> bool:
          return bool(self.children)
  
      def enter(self) -> str:
          return '('
  
      def depart(self) -> str:
          return ')'
  
      def create_children(self, arguments: Optional[Dict[str, Any]] = None) -> List[ChildType]:
          children: List[ChildType] = []
  
          for arg, value in self.arguments.items():
              if value is None:
                  # ignore None values for convenience
                  continue
  
              if isinstance(value, dict):
                  children.append(
                      Key(arg, node=Data.create(self.builder, data=value))
                  )
              elif isinstance(value, (list, tuple, set)):
                  # NOTE: we have a special case for execute_raw and query_raw
                  # here as prisma expects parameters to be passed as a json string
                  # value like "[\"John\",\"123\"]", and we encode twice to ensure
                  # that only the inner quotes are escaped
                  if self.builder.method in {'queryRaw', 'executeRaw'}:
                      children.append(f'{arg}: {dumps(dumps(value))}')
                  else:
                      children.append(Key(arg, node=ListNode.create(self.builder, data=value)))
              else:
                  children.append(f'{arg}: {dumps(value)}')
  
          return children
  
  
  class Data(Node):
      """Rendered node example:
  
      {
          key1: "a"
          key2: 3
          key3: [
              "name"
          ]
      }
      """
      data: Mapping[str, Any]
  
      def __init__(
          self,
          data: Mapping[str, Any],
          **kwargs: Any
      ) -> None:
          super().__init__(**kwargs)
          self.data = data
  
      def enter(self) -> str:
          return '{'
  
      def depart(self) -> str:
          return '}'
  
      def create_children(self) -> List[ChildType]:
          children: List[ChildType] = []
  
          for key, value in self.data.items():
              if isinstance(value, dict):
                  children.append(
                      Key(key, node=Data.create(self.builder, data=value))
                  )
              elif isinstance(value, (list, tuple, set)):
                  children.append(
                      Key(key, node=ListNode.create(self.builder, data=value))
                  )
              else:
                  children.append(f'{key}: {dumps(value)}')
  
          return children
  
  
  class ListNode(Node):
      data: Iterable[Any]
  
      def __init__(self, data: Iterable[Any], joiner: str = ',\n', **kwargs: Any) -> None:
          super().__init__(joiner=joiner, **kwargs)
          self.data = data
  
      def enter(self) -> str:
          return '['
  
      def depart(self) -> str:
          return ']'
  
      def create_children(self) -> List[ChildType]:
          children: List[ChildType] = []
  
          for item in self.data:
              if isinstance(item, dict):
                  children.append(Data.create(self.builder, data=item))
              else:
                  children.append(dumps(item))
  
          return children
  
  
  class Selection(Node):
      """Represents field selections
  
      Example no include:
  
      {
          id
          name
      }
  
      Example include={'posts': True}
  
      {
          id
          name
          posts {
              id
              title
          }
      }
  
      Example include={'posts': {'where': {'title': {'contains': 'Test'}}}}
  
      {
          id
          name
          posts(
              where: {
                  title: {
                      contains: 'Test'
                  }
              }
          )
          {
              id
              title
          }
      }
      """
      model: Optional[str]
      include: Optional[Dict[str, Any]]
      root_selection: Optional[List[str]]
  
      def __init__(
          self,
          model: Optional[str] = None,
          include: Optional[Dict[str, Any]] = None,
          root_selection: Optional[List[str]] = None,
          **kwargs: Any
      ) -> None:
          super().__init__(**kwargs)
          self.model = model
          self.include = include
          self.root_selection = root_selection
  
      def should_render(self) -> bool:
          return bool(self.children)
  
      def enter(self) -> str:
          return '{'
  
      def depart(self) -> str:
          return '}'
  
      def create_children(self) -> List[ChildType]:
          model = self.model
          include = self.include
          builder = self.builder
          children: List[ChildType] = []
  
          # root_selection, if present overrides the default fields
          # for a model as it is used by methods such as count()
          # that do not support returning model fields
          root_selection = self.root_selection
          if root_selection is not None:
              children.extend(root_selection)
          elif model is not None:
              children.extend(builder.get_default_fields(model))
  
          if include is not None:
              if model is None:
                  raise ValueError('Cannot include fields when model is None.')
  
              for key, value in include.items():
                  if value is True:
                      # e.g. posts { post_fields }
                      children.append(
                          Key(
                              key,
                              sep=' ',
                              node=Selection.create(
                                  builder,
                                  include=None,
                                  model=builder.get_relational_model(
                                      current_model=model, field=key
                                  ),
                              ),
                          )
                      )
                  elif isinstance(value, dict):
                      # e.g. given {'posts': {where': {'published': True}}} return
                      # posts( where: { published: true }) { post_fields }
                      args = value.copy()
                      nested_include = args.pop('include', None)
                      children.extend(
                          [
                              Key(
                                  key,
                                  sep='',
                                  node=Arguments.create(
                                      builder, arguments=args
                                  ),
                              ),
                              Selection.create(
                                  builder,
                                  include=nested_include,
                                  model=builder.get_relational_model(
                                      current_model=model, field=key
                                  ),
                              ),
                          ]
                      )
                  elif value is False:
                      continue
                  else:
                      raise TypeError(
                          f'Expected `bool` or `dict` include value but got {type(value)} instead.'
                      )
  
          return children
  
  
  class Key(AbstractNode):
      """Node for rendering a child node with a prefixed key"""
      key: str
      sep: str
      node: Node
  
      def __init__(self, key: str, node: Node, sep: str = ': ') -> None:
          self.key = key
          self.node = node
          self.sep = sep
  
      def render(self) -> str:
          content = self.node.render()
          if content:
              return f'{self.key}{self.sep}{content}'
          return f'{self.key}{self.sep}'
  
  
  @singledispatch
  def serializer(obj: Any) -> Serializable:
      """Single dispatch generic function for serializing objects to JSON"""
      if inspect.isclass(obj):
          typ = obj
      else:
          typ = type(obj)
  
      raise TypeError(f'Type {typ} not serializable')
  
  
  @serializer.register(datetime.datetime)
  def serialize_datetime(dt: datetime.datetime) -> str:
      """Format a datetime object to an ISO8601 string with a timezone.
  
      This assumes naive datetime objects are in UTC.
      """
      if dt.tzinfo is None:
          dt = dt.replace(tzinfo=timezone.utc)
      elif dt.tzinfo != timezone.utc:
          dt = dt.astimezone(timezone.utc)
  
      return dt.isoformat()
  
  
  @serializer.register(fields.Json)
  def serialize_json(obj: fields.Json) -> str:
      """Serialize a Json wrapper to a json string.
  
      This is used as a hook to override our default behaviour when building
      queries which would treat data like {'hello': 'world'} as a Data node
      when we instead want it to be rendered as a raw json string.
  
      This should only be used for fields that are of the `Json` type.
      """
      return dumps(obj.data)
  
  
  def dumps(obj: Any, **kwargs: Any) -> str:
      kwargs.setdefault('default', serializer)
      kwargs.setdefault('ensure_ascii', False)
      return json.dumps(obj, **kwargs)
  
  # black does not respect the fmt: off comment without this
  # fmt: on
  
  '
---
# name: test_async[client.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  
  if sys.version_info >= (3, 8):
      from typing import TypedDict, Literal
  else:
      from typing_extensions import TypedDict, Literal
  
  # -- template client.py.jinja --
  from types import TracebackType
  from collections import defaultdict
  from pydantic import BaseModel, validate_arguments
  
  from . import types, models, errors
  from ._types import BaseModelT
  from .engine import QueryEngine
  from .builder import QueryBuilder
  
  
  __all__ = (
      'Client',
      'load_env',
  )
  
  SCHEMA = '''
  // NOTE: modified from https://github.com/prisma/prisma/blob/master/src/packages/client/src/__tests__/integration/happy/exhaustive-schema/schema.prisma
  
  datasource db {
    provider = "postgresql"
    url      = env("DB_URL")
  }
  
  generator db {
    provider             = "prisma-client-py"
    interface            = "asyncio"
    recursive_type_depth = 3
    output               = "../../../.tests_cache/generation/exhaustive/__prisma_async_output__/prisma"
  }
  
  model Post {
    id         Int      @id @default(autoincrement())
    created_at DateTime @default(now())
    title      String
    content    String?
    published  Boolean  @default(false)
    author     User     @relation(fields: [author_id], references: [id])
    author_id  Int
  }
  
  model User {
    id               Int             @id @default(autoincrement())
    email            String          @unique
    int              Int
    optional_int     Int?
    float            Float
    optional_float   Float?
    string           String
    optional_string  String?
    enum             ABeautifulEnum
    optional_enum    ABeautifulEnum?
    boolean          Boolean
    optional_boolean Boolean?
    posts            Post[]
  }
  
  model M {
    id               Int             @id @default(autoincrement())
    n                N[]
    int              Int
    optional_int     Int?
    float            Float
    optional_float   Float?
    string           String
    optional_string  String?
    enum             ABeautifulEnum
    optional_enum    ABeautifulEnum?
    boolean          Boolean
    optional_boolean Boolean?
  }
  
  model N {
    id               Int             @id @default(autoincrement())
    m                M[]
    int              Int
    optional_int     Int?
    float            Float
    optional_float   Float?
    string           String
    optional_string  String?
    json_            Json
    optional_json    Json?
    enum             ABeautifulEnum
    optional_enum    ABeautifulEnum?
    boolean          Boolean
    optional_boolean Boolean?
  }
  
  model OneOptional {
    id               Int             @id @default(autoincrement())
    many             ManyRequired[]
    int              Int
    optional_int     Int?
    float            Float
    optional_float   Float?
    string           String
    optional_string  String?
    enum             ABeautifulEnum
    optional_enum    ABeautifulEnum?
    boolean          Boolean
    optional_boolean Boolean?
  }
  
  model ManyRequired {
    id  Int          @id @default(autoincrement())
    one OneOptional? @relation(fields: [one_optional_id], references: [id])
  
    one_optional_id  Int?
    int              Int
    optional_int     Int?
    float            Float
    optional_float   Float?
    string           String
    optional_string  String?
    enum             ABeautifulEnum
    optional_enum    ABeautifulEnum?
    boolean          Boolean
    optional_boolean Boolean?
  }
  
  enum ABeautifulEnum {
    A
    B
    C
  }
  
  model A {
    id       String  @id @default(uuid())
    email    String  @unique
    name     String?
    int      Int     @db.Integer
    sInt     Int     @db.SmallInt
    inc_int  Int     @default(autoincrement()) @db.Integer
    inc_sInt Int     @default(autoincrement()) @db.SmallInt
    bInt     BigInt  @db.BigInt
    inc_bInt BigInt  @default(autoincrement()) @db.BigInt
  }
  
  model B {
    id      String @id @default(cuid())
    float   Float  @db.Real
    d_float Float  @db.DoublePrecision
  
    // TODO
    // decFloat Decimal @db.Decimal(2, 1)
    // numFloat Decimal @db.Decimal(10, 6)
  }
  
  model C {
    id     String @id @default(cuid())
    char   String @db.Char(10)
    v_char String @db.VarChar(11)
    text   String @db.Text
    bit    String @db.Bit(4)
    v_bit  String @db.VarBit(5)
    uuid   String @db.Uuid
  }
  
  model D {
    id    String  @id @default(cuid())
    bool  Boolean @db.Boolean
    xml   String  @db.Xml
    json_ Json    @db.Json
    jsonb Json    @db.JsonB
  
    // TODO
    // byteA Bytes   @db.ByteA
  }
  
  model E {
    id   String   @id @default(cuid())
    date DateTime @db.Date
    time DateTime @db.Time(3)
    ts   DateTime @db.Timestamp(3)
  }
  
  '''
  
  
  def load_env(*, override: bool = True, **kwargs: Any) -> None:
      """Load environemntal variables from dotenv files
  
      Loads from the following files relative to the current
      working directory:
  
      - .env
      - prisma/.env
      """
      from dotenv import load_dotenv
  
      load_dotenv('.env', override=override, **kwargs)
      load_dotenv('prisma/.env', override=override, **kwargs)
  
  
  class Client:
      post: 'PostActions'
      user: 'UserActions'
      m: 'MActions'
      n: 'NActions'
      oneoptional: 'OneOptionalActions'
      manyrequired: 'ManyRequiredActions'
      a: 'AActions'
      b: 'BActions'
      c: 'CActions'
      d: 'DActions'
      e: 'EActions'
  
      def __init__(self, *, use_dotenv: bool = True, log_queries: bool = False) -> None:
          self.post = PostActions(self)
          self.user = UserActions(self)
          self.m = MActions(self)
          self.n = NActions(self)
          self.oneoptional = OneOptionalActions(self)
          self.manyrequired = ManyRequiredActions(self)
          self.a = AActions(self)
          self.b = BActions(self)
          self.c = CActions(self)
          self.d = DActions(self)
          self.e = EActions(self)
          self.__engine: Optional[QueryEngine] = None
          self._active_provider = 'postgresql'
          self._log_queries = log_queries
  
          if use_dotenv:
              load_env()
  
      def __del__(self) -> None:
          if self.__engine is not None:
              self.__engine.stop()
              self.__engine = None
  
      def is_connected(self) -> bool:
          """Returns True if the client is connected to the query engine, False otherwise."""
          return self.__engine is not None
  
      async def connect(self, timeout: int = 10) -> None:
          """Connect to the Prisma query engine.
  
          It is required to call this before accessing data.
          """
          if self.__engine is None:
              self.__engine = QueryEngine(dml=SCHEMA, log_queries=self._log_queries)
  
          await self.__engine.connect(timeout=timeout)
  
      async def disconnect(self) -> None:
          """Disconnect the Prisma query engine."""
          if self.__engine is not None:
              self.__engine.disconnect()
              await self.__engine.close_session()
              self.__engine = None
  
      async def execute_raw(self, query: str, *args: Any) -> int:
          resp = await self._execute(
              operation='mutation',
              method='executeRaw',
              arguments={
                  'query': query,
                  'parameters': args,
              }
          )
          return int(resp['data']['result'])
  
      @overload
      async def query_first(self, query: str, *args: Any) -> Any:
          ...
  
      @overload
      async def query_first(self, query: str, *args: Any, model: Type[BaseModelT]) -> Optional[BaseModelT]:
          ...
  
      async def query_first(
          self, query: str, *args: Any, model: Optional[Type[BaseModelT]] = None
      ) -> Union[Optional[BaseModelT], Any]:
          if model is not None:
              results = await self.query_raw(query, *args, model=model)
          else:
              results = await self.query_raw(query, *args)
  
          if not results:
              return None
  
          return results[0]
  
      @overload
      async def query_raw(self, query: str, *args: Any) -> Any:
          ...
  
      @overload
      async def query_raw(self, query: str, *args: Any, model: Type[BaseModelT]) -> List[BaseModelT]:
          ...
  
      async def query_raw(
          self, query: str, *args: Any, model: Optional[Type[BaseModelT]] = None
      ) -> Union[List[BaseModelT], Any]:
          resp = await self._execute(
              operation='mutation',
              method='queryRaw',
              arguments={
                  'query': query,
                  'parameters': args,
              }
          )
          result = resp['data']['result']
          if model is not None:
              return [model.parse_obj(r) for r in result]
          return result
  
      def batch_(self) -> 'Batch':
          """Returns a context manager for grouping write queries into a single transaction."""
          return Batch(client=self)
  
      # TODO: don't return Any
      async def _execute(
          self,
          method: str,
          operation: str,
          arguments: Dict[str, Any],
          model: Optional[str] = None,
          root_selection: Optional[List[str]] = None
      ) -> Any:
          builder = QueryBuilder(
              operation=operation,
              method=method,
              model=model,
              arguments=arguments,
              root_selection=root_selection,
          )
          return await self._engine.request('POST', '/', content=builder.build())
  
      @property
      def _engine(self) -> QueryEngine:
          engine = self.__engine
          if engine is None:
              raise errors.ClientNotConnectedError()
          return engine
  
  
  # TODO: this should return the results as well
  # TODO: don't require copy-pasting arguments between actions and batch actions
  class Batch:
      post: 'PostBatchActions'
      user: 'UserBatchActions'
      m: 'MBatchActions'
      n: 'NBatchActions'
      oneoptional: 'OneOptionalBatchActions'
      manyrequired: 'ManyRequiredBatchActions'
      a: 'ABatchActions'
      b: 'BBatchActions'
      c: 'CBatchActions'
      d: 'DBatchActions'
      e: 'EBatchActions'
  
      def __init__(self, client: Client) -> None:
          self.__client = client
          self.__queries: List[str] = []
          self._active_provider = client._active_provider
          self.post = PostBatchActions(self)
          self.user = UserBatchActions(self)
          self.m = MBatchActions(self)
          self.n = NBatchActions(self)
          self.oneoptional = OneOptionalBatchActions(self)
          self.manyrequired = ManyRequiredBatchActions(self)
          self.a = ABatchActions(self)
          self.b = BBatchActions(self)
          self.c = CBatchActions(self)
          self.d = DBatchActions(self)
          self.e = EBatchActions(self)
  
      def _add(self, **kwargs: Any) -> None:
          builder = QueryBuilder(**kwargs)
          self.__queries.append(builder.build_query())
  
      async def commit(self) -> None:
          """Execute the queries"""
          # TODO: normalise this, we should still call client._execute
          from .builder import dumps
  
          queries = self.__queries
          self.__queries = []
  
          payload = {
              'batch': [
                  {
                      'query': query,
                      'variables': {},
                  }
                  for query in queries
              ],
              'transaction': True,
          }
          await self.__client._engine.request('POST', '/', content=dumps(payload))
  
      async def __aenter__(self) -> 'Batch':
          return self
  
      async def __aexit__(
          self,
          exc_type: Optional[Type[BaseException]],
          exc: Optional[BaseException],
          exc_tb: Optional[TracebackType],
      ) -> None:
          if exc is None:
              await self.commit()
  
  
  class PostActions:
      def __init__(self, client: Client):
          self._client = client
  
      async def create(
          self,
          data: types.PostCreateInput,
          include: Optional[types.PostInclude] = None
      ) -> models.Post:
          resp = await self._client._execute(
              operation='mutation',
              method='createOne',
              model='Post',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return models.Post.parse_obj(resp['data']['result'])
  
      async def create_many(
          self,
          data: List[types.PostCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = await self._client._execute(
              operation='mutation',
              method='createMany',
              model='Post',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def delete(
          self,
          where: types.PostWhereUniqueInput,
          include: Optional[types.PostInclude] = None
      ) -> Optional[models.Post]:
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='Post',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.Post.parse_obj(resp['data']['result'])
  
      async def find_unique(
          self,
          where: types.PostWhereUniqueInput,
          include: Optional[types.PostInclude] = None
      ) -> Optional[models.Post]:
          resp = await self._client._execute(
              operation='query',
              method='findUnique',
              model='Post',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.Post.parse_obj(result)
  
      async def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.PostWhereInput] = None,
          cursor: Optional[types.PostWhereUniqueInput] = None,
          include: Optional[types.PostInclude] = None,
          order: Optional[Union[types.PostOrderByInput, List[types.PostOrderByInput]]] = None,
      ) -> List[models.Post]:
          resp = await self._client._execute(
              operation='query',
              method='findMany',
              model='Post',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [models.Post.parse_obj(r) for r in resp['data']['result']]
  
      async def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.PostWhereInput] = None,
          cursor: Optional[types.PostWhereUniqueInput] = None,
          include: Optional[types.PostInclude] = None,
          order: Optional[Union[types.PostOrderByInput, List[types.PostOrderByInput]]] = None,
      ) -> Optional[models.Post]:
          resp = await self._client._execute(
              operation='query',
              method='findFirst',
              model='Post',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.Post.parse_obj(result)
  
      async def update(
          self,
          data: types.PostUpdateInput,
          where: types.PostWhereUniqueInput,
          include: Optional[types.PostInclude] = None
      ) -> Optional[models.Post]:
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='Post',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.Post.parse_obj(resp['data']['result'])
  
      async def upsert(
          self,
          where: types.PostWhereUniqueInput,
          data: types.PostUpsertInput,
          include: Optional[types.PostInclude] = None,
      ) -> models.Post:
          resp = await self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='Post',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return models.Post.parse_obj(resp['data']['result'])
  
      async def update_many(
          self,
          data: types.PostUpdateManyMutationInput,
          where: types.PostWhereInput,
      ) -> int:
          resp = await self._client._execute(
              operation='mutation',
              method='updateMany',
              model='Post',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def count(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.PostWhereInput] = None,
          cursor: Optional[types.PostWhereUniqueInput] = None,
          order: Optional[Union[types.PostOrderByInput, List[types.PostOrderByInput]]] = None,
      ) -> int:
          # TODO: support select
          resp = await self._client._execute(
              operation='query',
              method='aggregate',
              model='Post',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=['_count { _all }'],
          )
          return cast(int, resp['data']['result']['_count']['_all'])
  
      async def delete_many(
          self,
          where: Optional[types.PostWhereInput] = None
      ) -> int:
          resp = await self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='Post',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class PostBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.PostCreateInput,
          include: Optional[types.PostInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='Post',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.PostCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='Post',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.PostWhereUniqueInput,
          include: Optional[types.PostInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='Post',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.PostUpdateInput,
          where: types.PostWhereUniqueInput,
          include: Optional[types.PostInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='Post',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.PostWhereUniqueInput,
          data: types.PostUpsertInput,
          include: Optional[types.PostInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='Post',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.PostUpdateManyMutationInput,
          where: types.PostWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='Post',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.PostWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='Post',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  class UserActions:
      def __init__(self, client: Client):
          self._client = client
  
      async def create(
          self,
          data: types.UserCreateInput,
          include: Optional[types.UserInclude] = None
      ) -> models.User:
          resp = await self._client._execute(
              operation='mutation',
              method='createOne',
              model='User',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return models.User.parse_obj(resp['data']['result'])
  
      async def create_many(
          self,
          data: List[types.UserCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = await self._client._execute(
              operation='mutation',
              method='createMany',
              model='User',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def delete(
          self,
          where: types.UserWhereUniqueInput,
          include: Optional[types.UserInclude] = None
      ) -> Optional[models.User]:
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='User',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.User.parse_obj(resp['data']['result'])
  
      async def find_unique(
          self,
          where: types.UserWhereUniqueInput,
          include: Optional[types.UserInclude] = None
      ) -> Optional[models.User]:
          resp = await self._client._execute(
              operation='query',
              method='findUnique',
              model='User',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.User.parse_obj(result)
  
      async def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.UserWhereInput] = None,
          cursor: Optional[types.UserWhereUniqueInput] = None,
          include: Optional[types.UserInclude] = None,
          order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
      ) -> List[models.User]:
          resp = await self._client._execute(
              operation='query',
              method='findMany',
              model='User',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [models.User.parse_obj(r) for r in resp['data']['result']]
  
      async def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.UserWhereInput] = None,
          cursor: Optional[types.UserWhereUniqueInput] = None,
          include: Optional[types.UserInclude] = None,
          order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
      ) -> Optional[models.User]:
          resp = await self._client._execute(
              operation='query',
              method='findFirst',
              model='User',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.User.parse_obj(result)
  
      async def update(
          self,
          data: types.UserUpdateInput,
          where: types.UserWhereUniqueInput,
          include: Optional[types.UserInclude] = None
      ) -> Optional[models.User]:
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='User',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.User.parse_obj(resp['data']['result'])
  
      async def upsert(
          self,
          where: types.UserWhereUniqueInput,
          data: types.UserUpsertInput,
          include: Optional[types.UserInclude] = None,
      ) -> models.User:
          resp = await self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='User',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return models.User.parse_obj(resp['data']['result'])
  
      async def update_many(
          self,
          data: types.UserUpdateManyMutationInput,
          where: types.UserWhereInput,
      ) -> int:
          resp = await self._client._execute(
              operation='mutation',
              method='updateMany',
              model='User',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def count(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.UserWhereInput] = None,
          cursor: Optional[types.UserWhereUniqueInput] = None,
          order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
      ) -> int:
          # TODO: support select
          resp = await self._client._execute(
              operation='query',
              method='aggregate',
              model='User',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=['_count { _all }'],
          )
          return cast(int, resp['data']['result']['_count']['_all'])
  
      async def delete_many(
          self,
          where: Optional[types.UserWhereInput] = None
      ) -> int:
          resp = await self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='User',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class UserBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.UserCreateInput,
          include: Optional[types.UserInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='User',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.UserCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='User',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.UserWhereUniqueInput,
          include: Optional[types.UserInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='User',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.UserUpdateInput,
          where: types.UserWhereUniqueInput,
          include: Optional[types.UserInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='User',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.UserWhereUniqueInput,
          data: types.UserUpsertInput,
          include: Optional[types.UserInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='User',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.UserUpdateManyMutationInput,
          where: types.UserWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='User',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.UserWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='User',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  class MActions:
      def __init__(self, client: Client):
          self._client = client
  
      async def create(
          self,
          data: types.MCreateInput,
          include: Optional[types.MInclude] = None
      ) -> models.M:
          resp = await self._client._execute(
              operation='mutation',
              method='createOne',
              model='M',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return models.M.parse_obj(resp['data']['result'])
  
      async def create_many(
          self,
          data: List[types.MCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = await self._client._execute(
              operation='mutation',
              method='createMany',
              model='M',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def delete(
          self,
          where: types.MWhereUniqueInput,
          include: Optional[types.MInclude] = None
      ) -> Optional[models.M]:
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='M',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.M.parse_obj(resp['data']['result'])
  
      async def find_unique(
          self,
          where: types.MWhereUniqueInput,
          include: Optional[types.MInclude] = None
      ) -> Optional[models.M]:
          resp = await self._client._execute(
              operation='query',
              method='findUnique',
              model='M',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.M.parse_obj(result)
  
      async def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.MWhereInput] = None,
          cursor: Optional[types.MWhereUniqueInput] = None,
          include: Optional[types.MInclude] = None,
          order: Optional[Union[types.MOrderByInput, List[types.MOrderByInput]]] = None,
      ) -> List[models.M]:
          resp = await self._client._execute(
              operation='query',
              method='findMany',
              model='M',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [models.M.parse_obj(r) for r in resp['data']['result']]
  
      async def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.MWhereInput] = None,
          cursor: Optional[types.MWhereUniqueInput] = None,
          include: Optional[types.MInclude] = None,
          order: Optional[Union[types.MOrderByInput, List[types.MOrderByInput]]] = None,
      ) -> Optional[models.M]:
          resp = await self._client._execute(
              operation='query',
              method='findFirst',
              model='M',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.M.parse_obj(result)
  
      async def update(
          self,
          data: types.MUpdateInput,
          where: types.MWhereUniqueInput,
          include: Optional[types.MInclude] = None
      ) -> Optional[models.M]:
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='M',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.M.parse_obj(resp['data']['result'])
  
      async def upsert(
          self,
          where: types.MWhereUniqueInput,
          data: types.MUpsertInput,
          include: Optional[types.MInclude] = None,
      ) -> models.M:
          resp = await self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='M',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return models.M.parse_obj(resp['data']['result'])
  
      async def update_many(
          self,
          data: types.MUpdateManyMutationInput,
          where: types.MWhereInput,
      ) -> int:
          resp = await self._client._execute(
              operation='mutation',
              method='updateMany',
              model='M',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def count(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.MWhereInput] = None,
          cursor: Optional[types.MWhereUniqueInput] = None,
          order: Optional[Union[types.MOrderByInput, List[types.MOrderByInput]]] = None,
      ) -> int:
          # TODO: support select
          resp = await self._client._execute(
              operation='query',
              method='aggregate',
              model='M',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=['_count { _all }'],
          )
          return cast(int, resp['data']['result']['_count']['_all'])
  
      async def delete_many(
          self,
          where: Optional[types.MWhereInput] = None
      ) -> int:
          resp = await self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='M',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class MBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.MCreateInput,
          include: Optional[types.MInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='M',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.MCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='M',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.MWhereUniqueInput,
          include: Optional[types.MInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='M',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.MUpdateInput,
          where: types.MWhereUniqueInput,
          include: Optional[types.MInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='M',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.MWhereUniqueInput,
          data: types.MUpsertInput,
          include: Optional[types.MInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='M',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.MUpdateManyMutationInput,
          where: types.MWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='M',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.MWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='M',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  class NActions:
      def __init__(self, client: Client):
          self._client = client
  
      async def create(
          self,
          data: types.NCreateInput,
          include: Optional[types.NInclude] = None
      ) -> models.N:
          resp = await self._client._execute(
              operation='mutation',
              method='createOne',
              model='N',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return models.N.parse_obj(resp['data']['result'])
  
      async def create_many(
          self,
          data: List[types.NCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = await self._client._execute(
              operation='mutation',
              method='createMany',
              model='N',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def delete(
          self,
          where: types.NWhereUniqueInput,
          include: Optional[types.NInclude] = None
      ) -> Optional[models.N]:
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='N',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.N.parse_obj(resp['data']['result'])
  
      async def find_unique(
          self,
          where: types.NWhereUniqueInput,
          include: Optional[types.NInclude] = None
      ) -> Optional[models.N]:
          resp = await self._client._execute(
              operation='query',
              method='findUnique',
              model='N',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.N.parse_obj(result)
  
      async def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.NWhereInput] = None,
          cursor: Optional[types.NWhereUniqueInput] = None,
          include: Optional[types.NInclude] = None,
          order: Optional[Union[types.NOrderByInput, List[types.NOrderByInput]]] = None,
      ) -> List[models.N]:
          resp = await self._client._execute(
              operation='query',
              method='findMany',
              model='N',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [models.N.parse_obj(r) for r in resp['data']['result']]
  
      async def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.NWhereInput] = None,
          cursor: Optional[types.NWhereUniqueInput] = None,
          include: Optional[types.NInclude] = None,
          order: Optional[Union[types.NOrderByInput, List[types.NOrderByInput]]] = None,
      ) -> Optional[models.N]:
          resp = await self._client._execute(
              operation='query',
              method='findFirst',
              model='N',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.N.parse_obj(result)
  
      async def update(
          self,
          data: types.NUpdateInput,
          where: types.NWhereUniqueInput,
          include: Optional[types.NInclude] = None
      ) -> Optional[models.N]:
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='N',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.N.parse_obj(resp['data']['result'])
  
      async def upsert(
          self,
          where: types.NWhereUniqueInput,
          data: types.NUpsertInput,
          include: Optional[types.NInclude] = None,
      ) -> models.N:
          resp = await self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='N',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return models.N.parse_obj(resp['data']['result'])
  
      async def update_many(
          self,
          data: types.NUpdateManyMutationInput,
          where: types.NWhereInput,
      ) -> int:
          resp = await self._client._execute(
              operation='mutation',
              method='updateMany',
              model='N',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def count(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.NWhereInput] = None,
          cursor: Optional[types.NWhereUniqueInput] = None,
          order: Optional[Union[types.NOrderByInput, List[types.NOrderByInput]]] = None,
      ) -> int:
          # TODO: support select
          resp = await self._client._execute(
              operation='query',
              method='aggregate',
              model='N',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=['_count { _all }'],
          )
          return cast(int, resp['data']['result']['_count']['_all'])
  
      async def delete_many(
          self,
          where: Optional[types.NWhereInput] = None
      ) -> int:
          resp = await self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='N',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class NBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.NCreateInput,
          include: Optional[types.NInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='N',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.NCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='N',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.NWhereUniqueInput,
          include: Optional[types.NInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='N',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.NUpdateInput,
          where: types.NWhereUniqueInput,
          include: Optional[types.NInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='N',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.NWhereUniqueInput,
          data: types.NUpsertInput,
          include: Optional[types.NInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='N',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.NUpdateManyMutationInput,
          where: types.NWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='N',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.NWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='N',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  class OneOptionalActions:
      def __init__(self, client: Client):
          self._client = client
  
      async def create(
          self,
          data: types.OneOptionalCreateInput,
          include: Optional[types.OneOptionalInclude] = None
      ) -> models.OneOptional:
          resp = await self._client._execute(
              operation='mutation',
              method='createOne',
              model='OneOptional',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return models.OneOptional.parse_obj(resp['data']['result'])
  
      async def create_many(
          self,
          data: List[types.OneOptionalCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = await self._client._execute(
              operation='mutation',
              method='createMany',
              model='OneOptional',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def delete(
          self,
          where: types.OneOptionalWhereUniqueInput,
          include: Optional[types.OneOptionalInclude] = None
      ) -> Optional[models.OneOptional]:
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='OneOptional',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.OneOptional.parse_obj(resp['data']['result'])
  
      async def find_unique(
          self,
          where: types.OneOptionalWhereUniqueInput,
          include: Optional[types.OneOptionalInclude] = None
      ) -> Optional[models.OneOptional]:
          resp = await self._client._execute(
              operation='query',
              method='findUnique',
              model='OneOptional',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.OneOptional.parse_obj(result)
  
      async def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.OneOptionalWhereInput] = None,
          cursor: Optional[types.OneOptionalWhereUniqueInput] = None,
          include: Optional[types.OneOptionalInclude] = None,
          order: Optional[Union[types.OneOptionalOrderByInput, List[types.OneOptionalOrderByInput]]] = None,
      ) -> List[models.OneOptional]:
          resp = await self._client._execute(
              operation='query',
              method='findMany',
              model='OneOptional',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [models.OneOptional.parse_obj(r) for r in resp['data']['result']]
  
      async def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.OneOptionalWhereInput] = None,
          cursor: Optional[types.OneOptionalWhereUniqueInput] = None,
          include: Optional[types.OneOptionalInclude] = None,
          order: Optional[Union[types.OneOptionalOrderByInput, List[types.OneOptionalOrderByInput]]] = None,
      ) -> Optional[models.OneOptional]:
          resp = await self._client._execute(
              operation='query',
              method='findFirst',
              model='OneOptional',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.OneOptional.parse_obj(result)
  
      async def update(
          self,
          data: types.OneOptionalUpdateInput,
          where: types.OneOptionalWhereUniqueInput,
          include: Optional[types.OneOptionalInclude] = None
      ) -> Optional[models.OneOptional]:
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='OneOptional',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.OneOptional.parse_obj(resp['data']['result'])
  
      async def upsert(
          self,
          where: types.OneOptionalWhereUniqueInput,
          data: types.OneOptionalUpsertInput,
          include: Optional[types.OneOptionalInclude] = None,
      ) -> models.OneOptional:
          resp = await self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='OneOptional',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return models.OneOptional.parse_obj(resp['data']['result'])
  
      async def update_many(
          self,
          data: types.OneOptionalUpdateManyMutationInput,
          where: types.OneOptionalWhereInput,
      ) -> int:
          resp = await self._client._execute(
              operation='mutation',
              method='updateMany',
              model='OneOptional',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def count(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.OneOptionalWhereInput] = None,
          cursor: Optional[types.OneOptionalWhereUniqueInput] = None,
          order: Optional[Union[types.OneOptionalOrderByInput, List[types.OneOptionalOrderByInput]]] = None,
      ) -> int:
          # TODO: support select
          resp = await self._client._execute(
              operation='query',
              method='aggregate',
              model='OneOptional',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=['_count { _all }'],
          )
          return cast(int, resp['data']['result']['_count']['_all'])
  
      async def delete_many(
          self,
          where: Optional[types.OneOptionalWhereInput] = None
      ) -> int:
          resp = await self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='OneOptional',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class OneOptionalBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.OneOptionalCreateInput,
          include: Optional[types.OneOptionalInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='OneOptional',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.OneOptionalCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='OneOptional',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.OneOptionalWhereUniqueInput,
          include: Optional[types.OneOptionalInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='OneOptional',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.OneOptionalUpdateInput,
          where: types.OneOptionalWhereUniqueInput,
          include: Optional[types.OneOptionalInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='OneOptional',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.OneOptionalWhereUniqueInput,
          data: types.OneOptionalUpsertInput,
          include: Optional[types.OneOptionalInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='OneOptional',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.OneOptionalUpdateManyMutationInput,
          where: types.OneOptionalWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='OneOptional',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.OneOptionalWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='OneOptional',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  class ManyRequiredActions:
      def __init__(self, client: Client):
          self._client = client
  
      async def create(
          self,
          data: types.ManyRequiredCreateInput,
          include: Optional[types.ManyRequiredInclude] = None
      ) -> models.ManyRequired:
          resp = await self._client._execute(
              operation='mutation',
              method='createOne',
              model='ManyRequired',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return models.ManyRequired.parse_obj(resp['data']['result'])
  
      async def create_many(
          self,
          data: List[types.ManyRequiredCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = await self._client._execute(
              operation='mutation',
              method='createMany',
              model='ManyRequired',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def delete(
          self,
          where: types.ManyRequiredWhereUniqueInput,
          include: Optional[types.ManyRequiredInclude] = None
      ) -> Optional[models.ManyRequired]:
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='ManyRequired',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.ManyRequired.parse_obj(resp['data']['result'])
  
      async def find_unique(
          self,
          where: types.ManyRequiredWhereUniqueInput,
          include: Optional[types.ManyRequiredInclude] = None
      ) -> Optional[models.ManyRequired]:
          resp = await self._client._execute(
              operation='query',
              method='findUnique',
              model='ManyRequired',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.ManyRequired.parse_obj(result)
  
      async def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.ManyRequiredWhereInput] = None,
          cursor: Optional[types.ManyRequiredWhereUniqueInput] = None,
          include: Optional[types.ManyRequiredInclude] = None,
          order: Optional[Union[types.ManyRequiredOrderByInput, List[types.ManyRequiredOrderByInput]]] = None,
      ) -> List[models.ManyRequired]:
          resp = await self._client._execute(
              operation='query',
              method='findMany',
              model='ManyRequired',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [models.ManyRequired.parse_obj(r) for r in resp['data']['result']]
  
      async def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.ManyRequiredWhereInput] = None,
          cursor: Optional[types.ManyRequiredWhereUniqueInput] = None,
          include: Optional[types.ManyRequiredInclude] = None,
          order: Optional[Union[types.ManyRequiredOrderByInput, List[types.ManyRequiredOrderByInput]]] = None,
      ) -> Optional[models.ManyRequired]:
          resp = await self._client._execute(
              operation='query',
              method='findFirst',
              model='ManyRequired',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.ManyRequired.parse_obj(result)
  
      async def update(
          self,
          data: types.ManyRequiredUpdateInput,
          where: types.ManyRequiredWhereUniqueInput,
          include: Optional[types.ManyRequiredInclude] = None
      ) -> Optional[models.ManyRequired]:
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='ManyRequired',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.ManyRequired.parse_obj(resp['data']['result'])
  
      async def upsert(
          self,
          where: types.ManyRequiredWhereUniqueInput,
          data: types.ManyRequiredUpsertInput,
          include: Optional[types.ManyRequiredInclude] = None,
      ) -> models.ManyRequired:
          resp = await self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='ManyRequired',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return models.ManyRequired.parse_obj(resp['data']['result'])
  
      async def update_many(
          self,
          data: types.ManyRequiredUpdateManyMutationInput,
          where: types.ManyRequiredWhereInput,
      ) -> int:
          resp = await self._client._execute(
              operation='mutation',
              method='updateMany',
              model='ManyRequired',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def count(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.ManyRequiredWhereInput] = None,
          cursor: Optional[types.ManyRequiredWhereUniqueInput] = None,
          order: Optional[Union[types.ManyRequiredOrderByInput, List[types.ManyRequiredOrderByInput]]] = None,
      ) -> int:
          # TODO: support select
          resp = await self._client._execute(
              operation='query',
              method='aggregate',
              model='ManyRequired',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=['_count { _all }'],
          )
          return cast(int, resp['data']['result']['_count']['_all'])
  
      async def delete_many(
          self,
          where: Optional[types.ManyRequiredWhereInput] = None
      ) -> int:
          resp = await self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='ManyRequired',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class ManyRequiredBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.ManyRequiredCreateInput,
          include: Optional[types.ManyRequiredInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='ManyRequired',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.ManyRequiredCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='ManyRequired',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.ManyRequiredWhereUniqueInput,
          include: Optional[types.ManyRequiredInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='ManyRequired',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.ManyRequiredUpdateInput,
          where: types.ManyRequiredWhereUniqueInput,
          include: Optional[types.ManyRequiredInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='ManyRequired',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.ManyRequiredWhereUniqueInput,
          data: types.ManyRequiredUpsertInput,
          include: Optional[types.ManyRequiredInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='ManyRequired',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.ManyRequiredUpdateManyMutationInput,
          where: types.ManyRequiredWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='ManyRequired',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.ManyRequiredWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='ManyRequired',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  class AActions:
      def __init__(self, client: Client):
          self._client = client
  
      async def create(
          self,
          data: types.ACreateInput,
          include: Optional[types.AInclude] = None
      ) -> models.A:
          resp = await self._client._execute(
              operation='mutation',
              method='createOne',
              model='A',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return models.A.parse_obj(resp['data']['result'])
  
      async def create_many(
          self,
          data: List[types.ACreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = await self._client._execute(
              operation='mutation',
              method='createMany',
              model='A',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def delete(
          self,
          where: types.AWhereUniqueInput,
          include: Optional[types.AInclude] = None
      ) -> Optional[models.A]:
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='A',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.A.parse_obj(resp['data']['result'])
  
      async def find_unique(
          self,
          where: types.AWhereUniqueInput,
          include: Optional[types.AInclude] = None
      ) -> Optional[models.A]:
          resp = await self._client._execute(
              operation='query',
              method='findUnique',
              model='A',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.A.parse_obj(result)
  
      async def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.AWhereInput] = None,
          cursor: Optional[types.AWhereUniqueInput] = None,
          include: Optional[types.AInclude] = None,
          order: Optional[Union[types.AOrderByInput, List[types.AOrderByInput]]] = None,
      ) -> List[models.A]:
          resp = await self._client._execute(
              operation='query',
              method='findMany',
              model='A',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [models.A.parse_obj(r) for r in resp['data']['result']]
  
      async def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.AWhereInput] = None,
          cursor: Optional[types.AWhereUniqueInput] = None,
          include: Optional[types.AInclude] = None,
          order: Optional[Union[types.AOrderByInput, List[types.AOrderByInput]]] = None,
      ) -> Optional[models.A]:
          resp = await self._client._execute(
              operation='query',
              method='findFirst',
              model='A',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.A.parse_obj(result)
  
      async def update(
          self,
          data: types.AUpdateInput,
          where: types.AWhereUniqueInput,
          include: Optional[types.AInclude] = None
      ) -> Optional[models.A]:
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='A',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.A.parse_obj(resp['data']['result'])
  
      async def upsert(
          self,
          where: types.AWhereUniqueInput,
          data: types.AUpsertInput,
          include: Optional[types.AInclude] = None,
      ) -> models.A:
          resp = await self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='A',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return models.A.parse_obj(resp['data']['result'])
  
      async def update_many(
          self,
          data: types.AUpdateManyMutationInput,
          where: types.AWhereInput,
      ) -> int:
          resp = await self._client._execute(
              operation='mutation',
              method='updateMany',
              model='A',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def count(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.AWhereInput] = None,
          cursor: Optional[types.AWhereUniqueInput] = None,
          order: Optional[Union[types.AOrderByInput, List[types.AOrderByInput]]] = None,
      ) -> int:
          # TODO: support select
          resp = await self._client._execute(
              operation='query',
              method='aggregate',
              model='A',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=['_count { _all }'],
          )
          return cast(int, resp['data']['result']['_count']['_all'])
  
      async def delete_many(
          self,
          where: Optional[types.AWhereInput] = None
      ) -> int:
          resp = await self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='A',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class ABatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.ACreateInput,
          include: Optional[types.AInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='A',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.ACreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='A',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.AWhereUniqueInput,
          include: Optional[types.AInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='A',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.AUpdateInput,
          where: types.AWhereUniqueInput,
          include: Optional[types.AInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='A',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.AWhereUniqueInput,
          data: types.AUpsertInput,
          include: Optional[types.AInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='A',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.AUpdateManyMutationInput,
          where: types.AWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='A',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.AWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='A',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  class BActions:
      def __init__(self, client: Client):
          self._client = client
  
      async def create(
          self,
          data: types.BCreateInput,
          include: Optional[types.BInclude] = None
      ) -> models.B:
          resp = await self._client._execute(
              operation='mutation',
              method='createOne',
              model='B',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return models.B.parse_obj(resp['data']['result'])
  
      async def create_many(
          self,
          data: List[types.BCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = await self._client._execute(
              operation='mutation',
              method='createMany',
              model='B',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def delete(
          self,
          where: types.BWhereUniqueInput,
          include: Optional[types.BInclude] = None
      ) -> Optional[models.B]:
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='B',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.B.parse_obj(resp['data']['result'])
  
      async def find_unique(
          self,
          where: types.BWhereUniqueInput,
          include: Optional[types.BInclude] = None
      ) -> Optional[models.B]:
          resp = await self._client._execute(
              operation='query',
              method='findUnique',
              model='B',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.B.parse_obj(result)
  
      async def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.BWhereInput] = None,
          cursor: Optional[types.BWhereUniqueInput] = None,
          include: Optional[types.BInclude] = None,
          order: Optional[Union[types.BOrderByInput, List[types.BOrderByInput]]] = None,
      ) -> List[models.B]:
          resp = await self._client._execute(
              operation='query',
              method='findMany',
              model='B',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [models.B.parse_obj(r) for r in resp['data']['result']]
  
      async def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.BWhereInput] = None,
          cursor: Optional[types.BWhereUniqueInput] = None,
          include: Optional[types.BInclude] = None,
          order: Optional[Union[types.BOrderByInput, List[types.BOrderByInput]]] = None,
      ) -> Optional[models.B]:
          resp = await self._client._execute(
              operation='query',
              method='findFirst',
              model='B',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.B.parse_obj(result)
  
      async def update(
          self,
          data: types.BUpdateInput,
          where: types.BWhereUniqueInput,
          include: Optional[types.BInclude] = None
      ) -> Optional[models.B]:
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='B',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.B.parse_obj(resp['data']['result'])
  
      async def upsert(
          self,
          where: types.BWhereUniqueInput,
          data: types.BUpsertInput,
          include: Optional[types.BInclude] = None,
      ) -> models.B:
          resp = await self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='B',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return models.B.parse_obj(resp['data']['result'])
  
      async def update_many(
          self,
          data: types.BUpdateManyMutationInput,
          where: types.BWhereInput,
      ) -> int:
          resp = await self._client._execute(
              operation='mutation',
              method='updateMany',
              model='B',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def count(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.BWhereInput] = None,
          cursor: Optional[types.BWhereUniqueInput] = None,
          order: Optional[Union[types.BOrderByInput, List[types.BOrderByInput]]] = None,
      ) -> int:
          # TODO: support select
          resp = await self._client._execute(
              operation='query',
              method='aggregate',
              model='B',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=['_count { _all }'],
          )
          return cast(int, resp['data']['result']['_count']['_all'])
  
      async def delete_many(
          self,
          where: Optional[types.BWhereInput] = None
      ) -> int:
          resp = await self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='B',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class BBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.BCreateInput,
          include: Optional[types.BInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='B',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.BCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='B',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.BWhereUniqueInput,
          include: Optional[types.BInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='B',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.BUpdateInput,
          where: types.BWhereUniqueInput,
          include: Optional[types.BInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='B',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.BWhereUniqueInput,
          data: types.BUpsertInput,
          include: Optional[types.BInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='B',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.BUpdateManyMutationInput,
          where: types.BWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='B',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.BWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='B',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  class CActions:
      def __init__(self, client: Client):
          self._client = client
  
      async def create(
          self,
          data: types.CCreateInput,
          include: Optional[types.CInclude] = None
      ) -> models.C:
          resp = await self._client._execute(
              operation='mutation',
              method='createOne',
              model='C',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return models.C.parse_obj(resp['data']['result'])
  
      async def create_many(
          self,
          data: List[types.CCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = await self._client._execute(
              operation='mutation',
              method='createMany',
              model='C',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def delete(
          self,
          where: types.CWhereUniqueInput,
          include: Optional[types.CInclude] = None
      ) -> Optional[models.C]:
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='C',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.C.parse_obj(resp['data']['result'])
  
      async def find_unique(
          self,
          where: types.CWhereUniqueInput,
          include: Optional[types.CInclude] = None
      ) -> Optional[models.C]:
          resp = await self._client._execute(
              operation='query',
              method='findUnique',
              model='C',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.C.parse_obj(result)
  
      async def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.CWhereInput] = None,
          cursor: Optional[types.CWhereUniqueInput] = None,
          include: Optional[types.CInclude] = None,
          order: Optional[Union[types.COrderByInput, List[types.COrderByInput]]] = None,
      ) -> List[models.C]:
          resp = await self._client._execute(
              operation='query',
              method='findMany',
              model='C',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [models.C.parse_obj(r) for r in resp['data']['result']]
  
      async def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.CWhereInput] = None,
          cursor: Optional[types.CWhereUniqueInput] = None,
          include: Optional[types.CInclude] = None,
          order: Optional[Union[types.COrderByInput, List[types.COrderByInput]]] = None,
      ) -> Optional[models.C]:
          resp = await self._client._execute(
              operation='query',
              method='findFirst',
              model='C',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.C.parse_obj(result)
  
      async def update(
          self,
          data: types.CUpdateInput,
          where: types.CWhereUniqueInput,
          include: Optional[types.CInclude] = None
      ) -> Optional[models.C]:
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='C',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.C.parse_obj(resp['data']['result'])
  
      async def upsert(
          self,
          where: types.CWhereUniqueInput,
          data: types.CUpsertInput,
          include: Optional[types.CInclude] = None,
      ) -> models.C:
          resp = await self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='C',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return models.C.parse_obj(resp['data']['result'])
  
      async def update_many(
          self,
          data: types.CUpdateManyMutationInput,
          where: types.CWhereInput,
      ) -> int:
          resp = await self._client._execute(
              operation='mutation',
              method='updateMany',
              model='C',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def count(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.CWhereInput] = None,
          cursor: Optional[types.CWhereUniqueInput] = None,
          order: Optional[Union[types.COrderByInput, List[types.COrderByInput]]] = None,
      ) -> int:
          # TODO: support select
          resp = await self._client._execute(
              operation='query',
              method='aggregate',
              model='C',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=['_count { _all }'],
          )
          return cast(int, resp['data']['result']['_count']['_all'])
  
      async def delete_many(
          self,
          where: Optional[types.CWhereInput] = None
      ) -> int:
          resp = await self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='C',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class CBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.CCreateInput,
          include: Optional[types.CInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='C',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.CCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='C',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.CWhereUniqueInput,
          include: Optional[types.CInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='C',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.CUpdateInput,
          where: types.CWhereUniqueInput,
          include: Optional[types.CInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='C',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.CWhereUniqueInput,
          data: types.CUpsertInput,
          include: Optional[types.CInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='C',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.CUpdateManyMutationInput,
          where: types.CWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='C',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.CWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='C',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  class DActions:
      def __init__(self, client: Client):
          self._client = client
  
      async def create(
          self,
          data: types.DCreateInput,
          include: Optional[types.DInclude] = None
      ) -> models.D:
          resp = await self._client._execute(
              operation='mutation',
              method='createOne',
              model='D',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return models.D.parse_obj(resp['data']['result'])
  
      async def create_many(
          self,
          data: List[types.DCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = await self._client._execute(
              operation='mutation',
              method='createMany',
              model='D',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def delete(
          self,
          where: types.DWhereUniqueInput,
          include: Optional[types.DInclude] = None
      ) -> Optional[models.D]:
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='D',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.D.parse_obj(resp['data']['result'])
  
      async def find_unique(
          self,
          where: types.DWhereUniqueInput,
          include: Optional[types.DInclude] = None
      ) -> Optional[models.D]:
          resp = await self._client._execute(
              operation='query',
              method='findUnique',
              model='D',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.D.parse_obj(result)
  
      async def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.DWhereInput] = None,
          cursor: Optional[types.DWhereUniqueInput] = None,
          include: Optional[types.DInclude] = None,
          order: Optional[Union[types.DOrderByInput, List[types.DOrderByInput]]] = None,
      ) -> List[models.D]:
          resp = await self._client._execute(
              operation='query',
              method='findMany',
              model='D',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [models.D.parse_obj(r) for r in resp['data']['result']]
  
      async def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.DWhereInput] = None,
          cursor: Optional[types.DWhereUniqueInput] = None,
          include: Optional[types.DInclude] = None,
          order: Optional[Union[types.DOrderByInput, List[types.DOrderByInput]]] = None,
      ) -> Optional[models.D]:
          resp = await self._client._execute(
              operation='query',
              method='findFirst',
              model='D',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.D.parse_obj(result)
  
      async def update(
          self,
          data: types.DUpdateInput,
          where: types.DWhereUniqueInput,
          include: Optional[types.DInclude] = None
      ) -> Optional[models.D]:
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='D',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.D.parse_obj(resp['data']['result'])
  
      async def upsert(
          self,
          where: types.DWhereUniqueInput,
          data: types.DUpsertInput,
          include: Optional[types.DInclude] = None,
      ) -> models.D:
          resp = await self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='D',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return models.D.parse_obj(resp['data']['result'])
  
      async def update_many(
          self,
          data: types.DUpdateManyMutationInput,
          where: types.DWhereInput,
      ) -> int:
          resp = await self._client._execute(
              operation='mutation',
              method='updateMany',
              model='D',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def count(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.DWhereInput] = None,
          cursor: Optional[types.DWhereUniqueInput] = None,
          order: Optional[Union[types.DOrderByInput, List[types.DOrderByInput]]] = None,
      ) -> int:
          # TODO: support select
          resp = await self._client._execute(
              operation='query',
              method='aggregate',
              model='D',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=['_count { _all }'],
          )
          return cast(int, resp['data']['result']['_count']['_all'])
  
      async def delete_many(
          self,
          where: Optional[types.DWhereInput] = None
      ) -> int:
          resp = await self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='D',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class DBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.DCreateInput,
          include: Optional[types.DInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='D',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.DCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='D',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.DWhereUniqueInput,
          include: Optional[types.DInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='D',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.DUpdateInput,
          where: types.DWhereUniqueInput,
          include: Optional[types.DInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='D',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.DWhereUniqueInput,
          data: types.DUpsertInput,
          include: Optional[types.DInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='D',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.DUpdateManyMutationInput,
          where: types.DWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='D',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.DWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='D',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  class EActions:
      def __init__(self, client: Client):
          self._client = client
  
      async def create(
          self,
          data: types.ECreateInput,
          include: Optional[types.EInclude] = None
      ) -> models.E:
          resp = await self._client._execute(
              operation='mutation',
              method='createOne',
              model='E',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return models.E.parse_obj(resp['data']['result'])
  
      async def create_many(
          self,
          data: List[types.ECreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = await self._client._execute(
              operation='mutation',
              method='createMany',
              model='E',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def delete(
          self,
          where: types.EWhereUniqueInput,
          include: Optional[types.EInclude] = None
      ) -> Optional[models.E]:
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='E',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.E.parse_obj(resp['data']['result'])
  
      async def find_unique(
          self,
          where: types.EWhereUniqueInput,
          include: Optional[types.EInclude] = None
      ) -> Optional[models.E]:
          resp = await self._client._execute(
              operation='query',
              method='findUnique',
              model='E',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.E.parse_obj(result)
  
      async def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.EWhereInput] = None,
          cursor: Optional[types.EWhereUniqueInput] = None,
          include: Optional[types.EInclude] = None,
          order: Optional[Union[types.EOrderByInput, List[types.EOrderByInput]]] = None,
      ) -> List[models.E]:
          resp = await self._client._execute(
              operation='query',
              method='findMany',
              model='E',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [models.E.parse_obj(r) for r in resp['data']['result']]
  
      async def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.EWhereInput] = None,
          cursor: Optional[types.EWhereUniqueInput] = None,
          include: Optional[types.EInclude] = None,
          order: Optional[Union[types.EOrderByInput, List[types.EOrderByInput]]] = None,
      ) -> Optional[models.E]:
          resp = await self._client._execute(
              operation='query',
              method='findFirst',
              model='E',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.E.parse_obj(result)
  
      async def update(
          self,
          data: types.EUpdateInput,
          where: types.EWhereUniqueInput,
          include: Optional[types.EInclude] = None
      ) -> Optional[models.E]:
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='E',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.E.parse_obj(resp['data']['result'])
  
      async def upsert(
          self,
          where: types.EWhereUniqueInput,
          data: types.EUpsertInput,
          include: Optional[types.EInclude] = None,
      ) -> models.E:
          resp = await self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='E',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return models.E.parse_obj(resp['data']['result'])
  
      async def update_many(
          self,
          data: types.EUpdateManyMutationInput,
          where: types.EWhereInput,
      ) -> int:
          resp = await self._client._execute(
              operation='mutation',
              method='updateMany',
              model='E',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def count(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.EWhereInput] = None,
          cursor: Optional[types.EWhereUniqueInput] = None,
          order: Optional[Union[types.EOrderByInput, List[types.EOrderByInput]]] = None,
      ) -> int:
          # TODO: support select
          resp = await self._client._execute(
              operation='query',
              method='aggregate',
              model='E',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=['_count { _all }'],
          )
          return cast(int, resp['data']['result']['_count']['_all'])
  
      async def delete_many(
          self,
          where: Optional[types.EWhereInput] = None
      ) -> int:
          resp = await self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='E',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class EBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.ECreateInput,
          include: Optional[types.EInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='E',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.ECreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='E',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.EWhereUniqueInput,
          include: Optional[types.EInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='E',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.EUpdateInput,
          where: types.EWhereUniqueInput,
          include: Optional[types.EInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='E',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.EWhereUniqueInput,
          data: types.EUpsertInput,
          include: Optional[types.EInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='E',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.EUpdateManyMutationInput,
          where: types.EWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='E',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.EWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='E',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  '
---
# name: test_async[engine/query.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  
  if sys.version_info >= (3, 8):
      from typing import TypedDict, Literal
  else:
      from typing_extensions import TypedDict, Literal
  
  # -- template engine/query.py.jinja --
  
  import os
  import time
  import atexit
  import signal
  import asyncio
  import logging
  import subprocess
  from pathlib import Path
  
  from . import utils, errors
  from ..http import HTTP
  from ..utils import DEBUG
  from .._types import Method
  from ..binaries import platform
  from ..utils import time_since, _env_bool
  
  
  __all__ = ('QueryEngine',)
  
  log: logging.Logger = logging.getLogger(__name__)
  
  
  class QueryEngine:
      dml: str
      session: HTTP
  
      def __init__(self, *, dml: str, log_queries: bool = False):
          self.dml = dml
          self.session = HTTP()
          self._log_queries = log_queries
          self.url = None  # type: Optional[str]
          self.process = None  # type: Optional[subprocess.Popen[bytes]]
          self.file = None  # type: Optional[Path]
  
          # ensure the query engine process is terminated when we are
          atexit.register(self.stop)
  
      def __del__(self) -> None:
          self.stop()
  
      def stop(self) -> None:
          self.disconnect()
          try:
              loop = asyncio.get_event_loop()
          except RuntimeError:
              # no event loop in the current thread, we cannot cleanup
              return
          else:
              if not loop.is_closed():
                  loop.create_task(self.close_session())
  
      def disconnect(self) -> None:
          log.debug('Disconnecting query engine...')
  
          if self.process is not None:
              if platform.name() == 'windows':
                  self.process.kill()
              else:
                  self.process.send_signal(signal.SIGINT)
  
              self.process.wait()
              self.process = None
  
          log.debug('Disconnected query engine')
  
      async def close_session(self) -> None:
          if self.session and not self.session.closed:
              await self.session.close()
  
      async def connect(self, timeout: int = 10) -> None:
          log.debug('Connecting to query engine')
          if self.process is not None:
              raise errors.AlreadyConnectedError('Already connected to the query engine')
  
          start = time.monotonic()
          self.file = file = utils.ensure()
  
          try:
              await self.spawn(file, timeout=timeout)
          except Exception:
              self.disconnect()
              raise
  
          log.debug('Connecting to query engine took %s', time_since(start))
  
      async def spawn(self, file: Path, timeout: int = 10) -> None:
          port = utils.get_open_port()
          log.debug('Running query engine on port %i', port)
  
          self.url = f'http://localhost:{port}'
  
          env = os.environ.copy()
          env.update(
              PRISMA_DML=self.dml,
              RUST_LOG='error',
              RUST_LOG_FORMAT='json',
              PRISMA_CLIENT_ENGINE_TYPE='binary',
          )
  
          if DEBUG:
              env.update(RUST_LOG='info')
  
          # TODO: remove the noise from these query logs
          if self._log_queries:
              env.update(LOG_QUERIES='y')
  
          args: List[str] = [str(file.absolute()), '-p', str(port), '--enable-raw-queries']
          if _env_bool('__PRISMA_PY_PLAYGROUND'):
              env.update(RUST_LOG='info')
              args.append('--enable-playground')
  
          log.debug('Starting query engine...')
          self.process = subprocess.Popen(
              args,
              env=env,
              stdout=sys.stdout,
              stderr=sys.stderr,
          )
  
          last_exc = None
          for _ in range(int(timeout / 0.1)):
              try:
                  data = await self.request('GET', '/status')
              except Exception as exc:  # pylint: disable=broad-except
                  last_exc = exc
                  log.debug(
                      'Could not connect to query engine due to %s; retrying...',
                      type(exc).__name__,
                  )
                  await asyncio.sleep(0.1)
  
                  continue
  
              if data.get('Errors') is not None:
                  log.debug('Could not connect due to gql errors; retrying...')
                  await asyncio.sleep(0.1)
  
                  continue
  
              break
          else:
              raise errors.EngineConnectionError(
                  'Could not connect to the query engine'
              ) from last_exc
  
      async def request(self, method: Method, path: str, *, content: Any = None) -> Any:
          if self.url is None:
              raise errors.NotConnectedError('Not connected to the query engine')
  
          kwargs = {
              'headers': {
                  'Content-Type': 'application/json',
                  'Accept': 'application/json',
              }
          }
  
          if content is not None:
              kwargs['content'] = content
  
          url = self.url + path
          log.debug('Sending %s request to %s with content: %s', method, url, content)
  
          resp = await self.session.request(method, url, **kwargs)
  
          if 300 > resp.status >= 200:
              response = await resp.json()
              log.debug('%s %s returned %s', method, url, response)
  
              errors_data = response.get('errors')
              if errors_data:
                  return utils.handle_response_errors(resp, errors_data)
  
              return response
  
          if resp.status == 422:
              raise errors.UnprocessableEntityError(resp)
  
          # TODO: handle errors better
          raise errors.EngineRequestError(resp, await resp.text())
  
  
  # black does not respect the fmt: off comment without this
  # fmt: on
  
  '
---
# name: test_async[enums.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  
  if sys.version_info >= (3, 8):
      from typing import TypedDict, Literal
  else:
      from typing_extensions import TypedDict, Literal
  
  # -- template enums.py.jinja --
  from enum import Enum
  
  
  class ABeautifulEnum(str, Enum):
      A = 'A'
      B = 'B'
      C = 'C'
  
  
  '
---
# name: test_async[fields.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  
  if sys.version_info >= (3, 8):
      from typing import TypedDict, Literal
  else:
      from typing_extensions import TypedDict, Literal
  
  # -- template fields.py.jinja --
  from pydantic import Json as _PydanticJson
  
  
  __all__ = (
      'Json',
  )
  
  
  _JsonKeys = Union[
      None,
      bool,
      float,
      int,
      str,
  ]
  
  
  # inherit from _PydanticJson so that pydantic will automatically
  # transform the json string into python objects.
  class Json(_PydanticJson):
      data: 'Serializable'
  
      def __init__(self, data: 'Serializable') -> None:
          self.data = data
          super().__init__()
  
      @classmethod
      def keys(cls, **data: 'Serializable') -> 'Json':
          return cls(data)
  
      if TYPE_CHECKING:
          # Fields that are of the `Json` type are automatically
          # de-serialized from json to the corresponding python type
          # when the model is created, e.g.
          #
          # User(json_obj='{"foo": null}') -> User(json_obj={'foo': None})
          #
          # As we don't know what the type will actually be at runtime
          # we add methods here for convenience so that naive access
          # to the field is still allowed, e.g.
          #
          # user.json_obj['foo']
          # user.json_obj[1]
          # user.json_obj[1:5]
          #
          # It should be noted that users will still have
          # to validate / cast fields to the type they are expecting
          # for any strict type binding or nested index calls to work, e.g.
          #
          # isinstance(user.json_obj, dict)
          # cast(Dict[str, Any], user.json_obj)
          # prisma.validate(ExpectedType, user.json_obj)  # NOTE: not implemented yet
          @overload  # type: ignore
          def __getitem__(self, i: slice) -> List['Serializable']:
              ...
  
          @overload
          def __getitem__(self, i: '_JsonKeys') -> 'Serializable':  # pyright: reportIncompatibleMethodOverride=false
              ...
  
          def __getitem__(self, i: Union['_JsonKeys', slice]) -> 'Serializable':
              ...
  
  
  from .types import Serializable
  '
---
# name: test_async[http.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  
  if sys.version_info >= (3, 8):
      from typing import TypedDict, Literal
  else:
      from typing_extensions import TypedDict, Literal
  
  # -- template http.py.jinja --
  from ._async_http import (
      HTTP as HTTP,
      Response as Response,
      client as client,
  )
  
  '
---
# name: test_async[models.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  
  if sys.version_info >= (3, 8):
      from typing import TypedDict, Literal
  else:
      from typing_extensions import TypedDict, Literal
  
  # -- template models.py.jinja --
  import os
  from pydantic import BaseConfig, BaseModel, Field
  
  from . import types, enums, errors, fields
  from .generator import partial_models_ctx, PartialModelField
  
  
  class Config(BaseConfig):
      use_enum_values: bool = True
      allow_population_by_field_name: bool = True
  
  
  _created_partial_types: Set[str] = set()
  
  
  class Post(BaseModel):
      id: int
      created_at: datetime.datetime
      title: str
      content: Optional[str]
      published: bool
      author: Optional['models.User']
      author_id: int
  
      Config = Config
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.PostKeys']] = None,
          exclude: Optional[Iterable['types.PostKeys']] = None,
          required: Optional[Iterable['types.PostKeys']] = None,
          optional: Optional[Iterable['types.PostKeys']] = None,
          relations: Optional[Mapping['types.PostRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.PostKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _Post_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _Post_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _Post_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _Post_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  for field, type_ in relations.items():
                      if field not in _Post_relational_fields:
                          raise errors.UnknownRelationalFieldError('Post', field)
  
                      # TODO: this method of validating types is not ideal
                      # as it means we cannot two create partial types that
                      # reference each other
                      if type_ not in _created_partial_types:
                          raise ValueError(
                              f'Unknown partial type: "{type_}". '
                              f'Did you remember to generate the {type_} type before this one?'
                          )
  
                      # TODO: support non prisma.partials models
                      info = fields[field]
                      if info['is_list']:
                          info['type'] = f'List[\'partials.{type_}\']'
                      else:
                          info['type'] = f'\'partials.{type_}\''
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid Post / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class User(BaseModel):
      id: int
      email: str
      int: int
      optional_int: Optional[int]
      float: float
      optional_float: Optional[float]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
      posts: Optional[List['models.Post']]
  
      Config = Config
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.UserKeys']] = None,
          exclude: Optional[Iterable['types.UserKeys']] = None,
          required: Optional[Iterable['types.UserKeys']] = None,
          optional: Optional[Iterable['types.UserKeys']] = None,
          relations: Optional[Mapping['types.UserRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.UserKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _User_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _User_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _User_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _User_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  for field, type_ in relations.items():
                      if field not in _User_relational_fields:
                          raise errors.UnknownRelationalFieldError('User', field)
  
                      # TODO: this method of validating types is not ideal
                      # as it means we cannot two create partial types that
                      # reference each other
                      if type_ not in _created_partial_types:
                          raise ValueError(
                              f'Unknown partial type: "{type_}". '
                              f'Did you remember to generate the {type_} type before this one?'
                          )
  
                      # TODO: support non prisma.partials models
                      info = fields[field]
                      if info['is_list']:
                          info['type'] = f'List[\'partials.{type_}\']'
                      else:
                          info['type'] = f'\'partials.{type_}\''
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid User / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class M(BaseModel):
      id: int
      n: Optional[List['models.N']]
      int: int
      optional_int: Optional[int]
      float: float
      optional_float: Optional[float]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
      Config = Config
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.MKeys']] = None,
          exclude: Optional[Iterable['types.MKeys']] = None,
          required: Optional[Iterable['types.MKeys']] = None,
          optional: Optional[Iterable['types.MKeys']] = None,
          relations: Optional[Mapping['types.MRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.MKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _M_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _M_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _M_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _M_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  for field, type_ in relations.items():
                      if field not in _M_relational_fields:
                          raise errors.UnknownRelationalFieldError('M', field)
  
                      # TODO: this method of validating types is not ideal
                      # as it means we cannot two create partial types that
                      # reference each other
                      if type_ not in _created_partial_types:
                          raise ValueError(
                              f'Unknown partial type: "{type_}". '
                              f'Did you remember to generate the {type_} type before this one?'
                          )
  
                      # TODO: support non prisma.partials models
                      info = fields[field]
                      if info['is_list']:
                          info['type'] = f'List[\'partials.{type_}\']'
                      else:
                          info['type'] = f'\'partials.{type_}\''
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid M / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class N(BaseModel):
      id: int
      m: Optional[List['models.M']]
      int: int
      optional_int: Optional[int]
      float: float
      optional_float: Optional[float]
      string: str
      optional_string: Optional[str]
      json_: 'fields.Json'
      optional_json: Optional['fields.Json']
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
      Config = Config
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.NKeys']] = None,
          exclude: Optional[Iterable['types.NKeys']] = None,
          required: Optional[Iterable['types.NKeys']] = None,
          optional: Optional[Iterable['types.NKeys']] = None,
          relations: Optional[Mapping['types.NRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.NKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _N_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _N_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _N_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _N_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  for field, type_ in relations.items():
                      if field not in _N_relational_fields:
                          raise errors.UnknownRelationalFieldError('N', field)
  
                      # TODO: this method of validating types is not ideal
                      # as it means we cannot two create partial types that
                      # reference each other
                      if type_ not in _created_partial_types:
                          raise ValueError(
                              f'Unknown partial type: "{type_}". '
                              f'Did you remember to generate the {type_} type before this one?'
                          )
  
                      # TODO: support non prisma.partials models
                      info = fields[field]
                      if info['is_list']:
                          info['type'] = f'List[\'partials.{type_}\']'
                      else:
                          info['type'] = f'\'partials.{type_}\''
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid N / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class OneOptional(BaseModel):
      id: int
      many: Optional[List['models.ManyRequired']]
      int: int
      optional_int: Optional[int]
      float: float
      optional_float: Optional[float]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
      Config = Config
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.OneOptionalKeys']] = None,
          exclude: Optional[Iterable['types.OneOptionalKeys']] = None,
          required: Optional[Iterable['types.OneOptionalKeys']] = None,
          optional: Optional[Iterable['types.OneOptionalKeys']] = None,
          relations: Optional[Mapping['types.OneOptionalRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.OneOptionalKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _OneOptional_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _OneOptional_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _OneOptional_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _OneOptional_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  for field, type_ in relations.items():
                      if field not in _OneOptional_relational_fields:
                          raise errors.UnknownRelationalFieldError('OneOptional', field)
  
                      # TODO: this method of validating types is not ideal
                      # as it means we cannot two create partial types that
                      # reference each other
                      if type_ not in _created_partial_types:
                          raise ValueError(
                              f'Unknown partial type: "{type_}". '
                              f'Did you remember to generate the {type_} type before this one?'
                          )
  
                      # TODO: support non prisma.partials models
                      info = fields[field]
                      if info['is_list']:
                          info['type'] = f'List[\'partials.{type_}\']'
                      else:
                          info['type'] = f'\'partials.{type_}\''
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid OneOptional / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class ManyRequired(BaseModel):
      id: int
      one: Optional['models.OneOptional']
      one_optional_id: Optional[int]
      int: int
      optional_int: Optional[int]
      float: float
      optional_float: Optional[float]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
      Config = Config
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.ManyRequiredKeys']] = None,
          exclude: Optional[Iterable['types.ManyRequiredKeys']] = None,
          required: Optional[Iterable['types.ManyRequiredKeys']] = None,
          optional: Optional[Iterable['types.ManyRequiredKeys']] = None,
          relations: Optional[Mapping['types.ManyRequiredRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.ManyRequiredKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _ManyRequired_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _ManyRequired_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _ManyRequired_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _ManyRequired_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  for field, type_ in relations.items():
                      if field not in _ManyRequired_relational_fields:
                          raise errors.UnknownRelationalFieldError('ManyRequired', field)
  
                      # TODO: this method of validating types is not ideal
                      # as it means we cannot two create partial types that
                      # reference each other
                      if type_ not in _created_partial_types:
                          raise ValueError(
                              f'Unknown partial type: "{type_}". '
                              f'Did you remember to generate the {type_} type before this one?'
                          )
  
                      # TODO: support non prisma.partials models
                      info = fields[field]
                      if info['is_list']:
                          info['type'] = f'List[\'partials.{type_}\']'
                      else:
                          info['type'] = f'\'partials.{type_}\''
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid ManyRequired / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class A(BaseModel):
      id: str
      email: str
      name: Optional[str]
      int: int
      sInt: int
      inc_int: int
      inc_sInt: int
      bInt: int
      inc_bInt: int
  
      Config = Config
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.AKeys']] = None,
          exclude: Optional[Iterable['types.AKeys']] = None,
          required: Optional[Iterable['types.AKeys']] = None,
          optional: Optional[Iterable['types.AKeys']] = None,
          relations: Optional[Mapping['types.ARelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.AKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _A_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _A_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _A_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _A_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  raise ValueError('Model: "A" has no relational fields.')
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid A / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class B(BaseModel):
      id: str
      float: float
      d_float: float
  
      Config = Config
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.BKeys']] = None,
          exclude: Optional[Iterable['types.BKeys']] = None,
          required: Optional[Iterable['types.BKeys']] = None,
          optional: Optional[Iterable['types.BKeys']] = None,
          relations: Optional[Mapping['types.BRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.BKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _B_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _B_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _B_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _B_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  raise ValueError('Model: "B" has no relational fields.')
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid B / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class C(BaseModel):
      id: str
      char: str
      v_char: str
      text: str
      bit: str
      v_bit: str
      uuid: str
  
      Config = Config
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.CKeys']] = None,
          exclude: Optional[Iterable['types.CKeys']] = None,
          required: Optional[Iterable['types.CKeys']] = None,
          optional: Optional[Iterable['types.CKeys']] = None,
          relations: Optional[Mapping['types.CRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.CKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _C_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _C_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _C_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _C_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  raise ValueError('Model: "C" has no relational fields.')
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid C / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class D(BaseModel):
      id: str
      bool: bool
      xml: str
      json_: 'fields.Json'
      jsonb: 'fields.Json'
  
      Config = Config
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.DKeys']] = None,
          exclude: Optional[Iterable['types.DKeys']] = None,
          required: Optional[Iterable['types.DKeys']] = None,
          optional: Optional[Iterable['types.DKeys']] = None,
          relations: Optional[Mapping['types.DRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.DKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _D_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _D_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _D_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _D_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  raise ValueError('Model: "D" has no relational fields.')
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid D / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class E(BaseModel):
      id: str
      date: datetime.datetime
      time: datetime.datetime
      ts: datetime.datetime
  
      Config = Config
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.EKeys']] = None,
          exclude: Optional[Iterable['types.EKeys']] = None,
          required: Optional[Iterable['types.EKeys']] = None,
          optional: Optional[Iterable['types.EKeys']] = None,
          relations: Optional[Mapping['types.ERelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.EKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _E_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _E_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _E_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _E_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  raise ValueError('Model: "E" has no relational fields.')
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid E / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  
  _Post_relational_fields: Set[str] = {
          'author',
      }
  _Post_fields: Dict['types.PostKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'created_at': {
          'name': 'created_at',
          'is_list': False,
          'optional': False,
          'type': 'datetime.datetime',
      },
      'title': {
          'name': 'title',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'content': {
          'name': 'content',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'published': {
          'name': 'published',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'author': {
          'name': 'author',
          'is_list': False,
          'optional': True,
          'type': 'models.User',
      },
      'author_id': {
          'name': 'author_id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
  }
  
  _User_relational_fields: Set[str] = {
          'posts',
      }
  _User_fields: Dict['types.UserKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'email': {
          'name': 'email',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'int': {
          'name': 'int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'optional_int': {
          'name': 'optional_int',
          'is_list': False,
          'optional': True,
          'type': 'int',
      },
      'float': {
          'name': 'float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
      'optional_float': {
          'name': 'optional_float',
          'is_list': False,
          'optional': True,
          'type': 'float',
      },
      'string': {
          'name': 'string',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'optional_string': {
          'name': 'optional_string',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'enum': {
          'name': 'enum',
          'is_list': False,
          'optional': False,
          'type': 'enums.ABeautifulEnum',
      },
      'optional_enum': {
          'name': 'optional_enum',
          'is_list': False,
          'optional': True,
          'type': 'enums.ABeautifulEnum',
      },
      'boolean': {
          'name': 'boolean',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'optional_boolean': {
          'name': 'optional_boolean',
          'is_list': False,
          'optional': True,
          'type': 'bool',
      },
      'posts': {
          'name': 'posts',
          'is_list': True,
          'optional': True,
          'type': 'List[\'models.Post\']',
      },
  }
  
  _M_relational_fields: Set[str] = {
          'n',
      }
  _M_fields: Dict['types.MKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'n': {
          'name': 'n',
          'is_list': True,
          'optional': True,
          'type': 'List[\'models.N\']',
      },
      'int': {
          'name': 'int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'optional_int': {
          'name': 'optional_int',
          'is_list': False,
          'optional': True,
          'type': 'int',
      },
      'float': {
          'name': 'float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
      'optional_float': {
          'name': 'optional_float',
          'is_list': False,
          'optional': True,
          'type': 'float',
      },
      'string': {
          'name': 'string',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'optional_string': {
          'name': 'optional_string',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'enum': {
          'name': 'enum',
          'is_list': False,
          'optional': False,
          'type': 'enums.ABeautifulEnum',
      },
      'optional_enum': {
          'name': 'optional_enum',
          'is_list': False,
          'optional': True,
          'type': 'enums.ABeautifulEnum',
      },
      'boolean': {
          'name': 'boolean',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'optional_boolean': {
          'name': 'optional_boolean',
          'is_list': False,
          'optional': True,
          'type': 'bool',
      },
  }
  
  _N_relational_fields: Set[str] = {
          'm',
      }
  _N_fields: Dict['types.NKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'm': {
          'name': 'm',
          'is_list': True,
          'optional': True,
          'type': 'List[\'models.M\']',
      },
      'int': {
          'name': 'int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'optional_int': {
          'name': 'optional_int',
          'is_list': False,
          'optional': True,
          'type': 'int',
      },
      'float': {
          'name': 'float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
      'optional_float': {
          'name': 'optional_float',
          'is_list': False,
          'optional': True,
          'type': 'float',
      },
      'string': {
          'name': 'string',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'optional_string': {
          'name': 'optional_string',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'json_': {
          'name': 'json_',
          'is_list': False,
          'optional': False,
          'type': 'fields.Json',
      },
      'optional_json': {
          'name': 'optional_json',
          'is_list': False,
          'optional': True,
          'type': 'fields.Json',
      },
      'enum': {
          'name': 'enum',
          'is_list': False,
          'optional': False,
          'type': 'enums.ABeautifulEnum',
      },
      'optional_enum': {
          'name': 'optional_enum',
          'is_list': False,
          'optional': True,
          'type': 'enums.ABeautifulEnum',
      },
      'boolean': {
          'name': 'boolean',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'optional_boolean': {
          'name': 'optional_boolean',
          'is_list': False,
          'optional': True,
          'type': 'bool',
      },
  }
  
  _OneOptional_relational_fields: Set[str] = {
          'many',
      }
  _OneOptional_fields: Dict['types.OneOptionalKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'many': {
          'name': 'many',
          'is_list': True,
          'optional': True,
          'type': 'List[\'models.ManyRequired\']',
      },
      'int': {
          'name': 'int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'optional_int': {
          'name': 'optional_int',
          'is_list': False,
          'optional': True,
          'type': 'int',
      },
      'float': {
          'name': 'float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
      'optional_float': {
          'name': 'optional_float',
          'is_list': False,
          'optional': True,
          'type': 'float',
      },
      'string': {
          'name': 'string',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'optional_string': {
          'name': 'optional_string',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'enum': {
          'name': 'enum',
          'is_list': False,
          'optional': False,
          'type': 'enums.ABeautifulEnum',
      },
      'optional_enum': {
          'name': 'optional_enum',
          'is_list': False,
          'optional': True,
          'type': 'enums.ABeautifulEnum',
      },
      'boolean': {
          'name': 'boolean',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'optional_boolean': {
          'name': 'optional_boolean',
          'is_list': False,
          'optional': True,
          'type': 'bool',
      },
  }
  
  _ManyRequired_relational_fields: Set[str] = {
          'one',
      }
  _ManyRequired_fields: Dict['types.ManyRequiredKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'one': {
          'name': 'one',
          'is_list': False,
          'optional': True,
          'type': 'models.OneOptional',
      },
      'one_optional_id': {
          'name': 'one_optional_id',
          'is_list': False,
          'optional': True,
          'type': 'int',
      },
      'int': {
          'name': 'int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'optional_int': {
          'name': 'optional_int',
          'is_list': False,
          'optional': True,
          'type': 'int',
      },
      'float': {
          'name': 'float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
      'optional_float': {
          'name': 'optional_float',
          'is_list': False,
          'optional': True,
          'type': 'float',
      },
      'string': {
          'name': 'string',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'optional_string': {
          'name': 'optional_string',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'enum': {
          'name': 'enum',
          'is_list': False,
          'optional': False,
          'type': 'enums.ABeautifulEnum',
      },
      'optional_enum': {
          'name': 'optional_enum',
          'is_list': False,
          'optional': True,
          'type': 'enums.ABeautifulEnum',
      },
      'boolean': {
          'name': 'boolean',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'optional_boolean': {
          'name': 'optional_boolean',
          'is_list': False,
          'optional': True,
          'type': 'bool',
      },
  }
  
  _A_relational_fields: Set[str] = set()  # pyright: reportUnusedVariable=false
  _A_fields: Dict['types.AKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'email': {
          'name': 'email',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'name': {
          'name': 'name',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'int': {
          'name': 'int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'sInt': {
          'name': 'sInt',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'inc_int': {
          'name': 'inc_int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'inc_sInt': {
          'name': 'inc_sInt',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'bInt': {
          'name': 'bInt',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'inc_bInt': {
          'name': 'inc_bInt',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
  }
  
  _B_relational_fields: Set[str] = set()  # pyright: reportUnusedVariable=false
  _B_fields: Dict['types.BKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'float': {
          'name': 'float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
      'd_float': {
          'name': 'd_float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
  }
  
  _C_relational_fields: Set[str] = set()  # pyright: reportUnusedVariable=false
  _C_fields: Dict['types.CKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'char': {
          'name': 'char',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'v_char': {
          'name': 'v_char',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'text': {
          'name': 'text',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'bit': {
          'name': 'bit',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'v_bit': {
          'name': 'v_bit',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'uuid': {
          'name': 'uuid',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
  }
  
  _D_relational_fields: Set[str] = set()  # pyright: reportUnusedVariable=false
  _D_fields: Dict['types.DKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'bool': {
          'name': 'bool',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'xml': {
          'name': 'xml',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'json_': {
          'name': 'json_',
          'is_list': False,
          'optional': False,
          'type': 'fields.Json',
      },
      'jsonb': {
          'name': 'jsonb',
          'is_list': False,
          'optional': False,
          'type': 'fields.Json',
      },
  }
  
  _E_relational_fields: Set[str] = set()  # pyright: reportUnusedVariable=false
  _E_fields: Dict['types.EKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'date': {
          'name': 'date',
          'is_list': False,
          'optional': False,
          'type': 'datetime.datetime',
      },
      'time': {
          'name': 'time',
          'is_list': False,
          'optional': False,
          'type': 'datetime.datetime',
      },
      'ts': {
          'name': 'ts',
          'is_list': False,
          'optional': False,
          'type': 'datetime.datetime',
      },
  }
  
  
  
  # we have to import ourselves as relation types are namespaced to models
  # e.g. models.Post
  from . import models
  
  # required to support relationships between models
  Post.update_forward_refs()
  User.update_forward_refs()
  M.update_forward_refs()
  N.update_forward_refs()
  OneOptional.update_forward_refs()
  ManyRequired.update_forward_refs()
  A.update_forward_refs()
  B.update_forward_refs()
  C.update_forward_refs()
  D.update_forward_refs()
  E.update_forward_refs()
  
  '
---
# name: test_async[partials.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  
  if sys.version_info >= (3, 8):
      from typing import TypedDict, Literal
  else:
      from typing_extensions import TypedDict, Literal
  
  # -- template partials.py.jinja --
  from pydantic import BaseModel, Field
  from . import types, models, fields
  
  
  
  # users can modify relational types which are then namespaced to partials.
  # so we have to import ourselves in order to resolve forward references
  from . import partials
  
  
  # fmt: on
  
  '
---
# name: test_async[types.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  
  if sys.version_info >= (3, 8):
      from typing import TypedDict, Literal
  else:
      from typing_extensions import TypedDict, Literal
  
  # -- template types.py.jinja --
  from .utils import _NoneType
  
  
  
  # TODO: cleanup whitespace control
  # TODO: add an argument to signify that the last iteration should be skipped
  
  
  SortOrder = Literal['asc', 'desc']
  
  # types that can be serialized to json by our query builder
  Serializable = Union[
      None,
      bool,
      float,
      int,
      str,
      datetime.datetime,
      List[Any],
      Dict[None, Any],
      Dict[bool, Any],
      Dict[float, Any],
      Dict[int, Any],
      Dict[str, Any],
  ]
  
  
      
  
  StringFilter = TypedDict(
      'StringFilter',
      {
          'equals': str,
          'not_in': List[str],
          'lt': str,
          'lte': str,
          'gt': str,
          'gte': str,
          'contains': str,
          'startswith': str,
          'endswith': str,
          'in': List[str],
          'not': Union[str, 'StringFilterRecursive1'],
      },
      total=False,
  )
  
  
  StringFilterRecursive1 = TypedDict(
      'StringFilterRecursive1',
      {
          'equals': str,
          'not_in': List[str],
          'lt': str,
          'lte': str,
          'gt': str,
          'gte': str,
          'contains': str,
          'startswith': str,
          'endswith': str,
          'in': List[str],
          'not': Union[str, 'StringFilterRecursive2'],
      },
      total=False,
  )
  
  
  StringFilterRecursive2 = TypedDict(
      'StringFilterRecursive2',
      {
          'equals': str,
          'not_in': List[str],
          'lt': str,
          'lte': str,
          'gt': str,
          'gte': str,
          'contains': str,
          'startswith': str,
          'endswith': str,
          'in': List[str],
              },
      total=False,
  )
  
      
  
  DateTimeFilter = TypedDict(
      'DateTimeFilter',
      {
          'equals': datetime.datetime,
          'not_in': List[datetime.datetime],
          'lt': datetime.datetime,
          'lte': datetime.datetime,
          'gt': datetime.datetime,
          'gte': datetime.datetime,
          'in': List[datetime.datetime],
          'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
      },
      total=False,
  )
  
  
  DateTimeFilterRecursive1 = TypedDict(
      'DateTimeFilterRecursive1',
      {
          'equals': datetime.datetime,
          'not_in': List[datetime.datetime],
          'lt': datetime.datetime,
          'lte': datetime.datetime,
          'gt': datetime.datetime,
          'gte': datetime.datetime,
          'in': List[datetime.datetime],
          'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
      },
      total=False,
  )
  
  
  DateTimeFilterRecursive2 = TypedDict(
      'DateTimeFilterRecursive2',
      {
          'equals': datetime.datetime,
          'not_in': List[datetime.datetime],
          'lt': datetime.datetime,
          'lte': datetime.datetime,
          'gt': datetime.datetime,
          'gte': datetime.datetime,
          'in': List[datetime.datetime],
              },
      total=False,
  )
  
  
      
  
  BooleanFilter = TypedDict(
      'BooleanFilter',
      {
          'equals': bool,
          'not': Union[bool, 'BooleanFilterRecursive1'],
      },
      total=False,
  )
  
  
  BooleanFilterRecursive1 = TypedDict(
      'BooleanFilterRecursive1',
      {
          'equals': bool,
          'not': Union[bool, 'BooleanFilterRecursive2'],
      },
      total=False,
  )
  
  
  BooleanFilterRecursive2 = TypedDict(
      'BooleanFilterRecursive2',
      {
          'equals': bool,
              },
      total=False,
  )
  
  
      
  
  IntFilter = TypedDict(
      'IntFilter',
      {
          'equals': int,
          'not_in': List[int],
          'lt': int,
          'lte': int,
          'gt': int,
          'gte': int,
          'in': List[int],
          'not': Union[int, 'IntFilterRecursive1'],
      },
      total=False,
  )
  
  
  IntFilterRecursive1 = TypedDict(
      'IntFilterRecursive1',
      {
          'equals': int,
          'not_in': List[int],
          'lt': int,
          'lte': int,
          'gt': int,
          'gte': int,
          'in': List[int],
          'not': Union[int, 'IntFilterRecursive2'],
      },
      total=False,
  )
  
  
  IntFilterRecursive2 = TypedDict(
      'IntFilterRecursive2',
      {
          'equals': int,
          'not_in': List[int],
          'lt': int,
          'lte': int,
          'gt': int,
          'gte': int,
          'in': List[int],
              },
      total=False,
  )
  
  
  BigIntFilter = IntFilter
      
  
  FloatFilter = TypedDict(
      'FloatFilter',
      {
          'equals': float,
          'not_in': List[float],
          'lt': float,
          'lte': float,
          'gt': float,
          'gte': float,
          'in': List[float],
          'not': Union[float, 'FloatFilterRecursive1'],
      },
      total=False,
  )
  
  
  FloatFilterRecursive1 = TypedDict(
      'FloatFilterRecursive1',
      {
          'equals': float,
          'not_in': List[float],
          'lt': float,
          'lte': float,
          'gt': float,
          'gte': float,
          'in': List[float],
          'not': Union[float, 'FloatFilterRecursive2'],
      },
      total=False,
  )
  
  
  FloatFilterRecursive2 = TypedDict(
      'FloatFilterRecursive2',
      {
          'equals': float,
          'not_in': List[float],
          'lt': float,
          'lte': float,
          'gt': float,
          'gte': float,
          'in': List[float],
              },
      total=False,
  )
  
  # TODO: preview feature for improving JSON filtering
  JsonFilter = TypedDict(
      'JsonFilter',
      {
          'equals': 'fields.Json',
          'not': 'fields.Json',
      },
      total=False,
  )
  
  
  class _FloatSetInput(TypedDict):
      set: float
  
  
  class _FloatDivideInput(TypedDict):
      divide: float
  
  
  class _FloatMultiplyInput(TypedDict):
      multiply: float
  
  
  class _FloatIncrementInput(TypedDict):
      increment: float
  
  
  class _FloatDecrementInput(TypedDict):
      decrement: float
  
  
  class _IntSetInput(TypedDict):
      set: int
  
  
  class _IntDivideInput(TypedDict):
      divide: int
  
  
  class _IntMultiplyInput(TypedDict):
      multiply: int
  
  
  class _IntIncrementInput(TypedDict):
      increment: int
  
  
  class _IntDecrementInput(TypedDict):
      decrement: int
  
  
  AtomicFloatInput = Union[
      _FloatSetInput,
      _FloatDivideInput,
      _FloatMultiplyInput,
      _FloatIncrementInput,
      _FloatDecrementInput,
  ]
  AtomicIntInput = Union[
      _IntSetInput,
      _IntDivideInput,
      _IntMultiplyInput,
      _IntIncrementInput,
      _IntDecrementInput,
  ]
  AtomicBigIntInput = AtomicIntInput
  
  
  # Post types
  
  class PostOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the Post create method"""
      id: int
      created_at: datetime.datetime
      content: Optional[str]
      published: bool
      author: 'UserCreateNestedWithoutRelationsInput'
  
  
  class PostCreateInput(PostOptionalCreateInput):
      """Required arguments to the Post create method"""
      title: str
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class PostOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the Post create method, without relations"""
      id: int
      created_at: datetime.datetime
      content: Optional[str]
      published: bool
  
  
  class PostCreateWithoutRelationsInput(PostOptionalCreateWithoutRelationsInput):
      """Required arguments to the Post create method, without relations"""
      title: str
  
  
  class PostCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'PostCreateWithoutRelationsInput'
      connect: 'PostWhereUniqueInput'
  
  
  class PostCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['PostCreateWithoutRelationsInput', List['PostCreateWithoutRelationsInput']]
      connect: Union['PostWhereUniqueInput', List['PostWhereUniqueInput']]
  
  
  class PostWhereUniqueInput(TypedDict, total=False):
      """Unique Post arguments for searching"""
      id: int
  
  
  class PostUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      created_at: datetime.datetime
      title: str
      content: Optional[str]
      published: bool
      author: 'UserUpdateOneWithoutRelationsInput'
  
  
  class PostUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: Union[AtomicIntInput, int]
      created_at: datetime.datetime
      title: str
      content: Optional[str]
      published: bool
      author: 'UserUpdateOneWithoutRelationsInput'
  
  
  class PostUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['PostCreateWithoutRelationsInput']
      connect: List['PostWhereUniqueInput']
      set: List['PostWhereUniqueInput']
      disconnect: List['PostWhereUniqueInput']
      delete: List['PostWhereUniqueInput']
  
      # TODO
      # update: List['PostUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['PostUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['PostScalarWhereInput']
      # upsert: List['PostUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['PostCreateOrConnectWithoutRelationsInput']
  
  
  class PostUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'PostCreateWithoutRelationsInput'
      connect: 'PostWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'PostUpdateInput'
      # upsert: 'PostUpsertWithoutRelationsInput'
      # connectOrCreate: 'PostCreateOrConnectWithoutRelationsInput'
  
  
  class PostUpsertInput(TypedDict):
      create: 'PostCreateInput'
      update: 'PostUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class PostOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      created_at: 'SortOrder'
      title: 'SortOrder'
      content: 'SortOrder'
      published: 'SortOrder'
      author_id: 'SortOrder'
  
  
  # recursive Post types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/latest/limitations/
  
  PostRelationFilter = TypedDict(
      'PostRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class PostListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class PostInclude(TypedDict, total=False):
      """Post relational arguments"""
      author: Union[bool, 'UserArgsFromPost']
  
  
      
  
  class PostIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
      author: Union[bool, 'UserArgsFromPostRecursive1']
  
  
  class PostIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
      author: Union[bool, 'UserArgsFromPostRecursive2']
  
  
  class PostIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class PostArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyPostArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
      posts: Union[bool, 'FindManyPostArgsFromPostRecursive1']
  
  
  class UserIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
      posts: Union[bool, 'FindManyPostArgsFromPostRecursive2']
  
  
  class UserIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class UserArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyUserArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
      n: Union[bool, 'FindManyNArgsFromPostRecursive1']
  
  
  class MIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
      n: Union[bool, 'FindManyNArgsFromPostRecursive2']
  
  
  class MIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class MArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyMArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
      m: Union[bool, 'FindManyMArgsFromPostRecursive1']
  
  
  class NIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
      m: Union[bool, 'FindManyMArgsFromPostRecursive2']
  
  
  class NIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class NArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyNArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
      many: Union[bool, 'FindManyManyRequiredArgsFromPostRecursive1']
  
  
  class OneOptionalIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
      many: Union[bool, 'FindManyManyRequiredArgsFromPostRecursive2']
  
  
  class OneOptionalIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class OneOptionalArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyOneOptionalArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
      one: Union[bool, 'OneOptionalArgsFromPostRecursive1']
  
  
  class ManyRequiredIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
      one: Union[bool, 'OneOptionalArgsFromPostRecursive2']
  
  
  class ManyRequiredIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class ManyRequiredArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyManyRequiredArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class AIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class AIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class AIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class AArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyAArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class BIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class BIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class BArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyBArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class CIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class CIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class CArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyCArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class DIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class DIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class DArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyDArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class EIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class EIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class EArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyEArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyPostArgs = FindManyPostArgsFromPost
  FindFirstPostArgs = FindManyPostArgsFromPost
  
  
      
  
  class PostWhereInput(TypedDict, total=False):
      """Post arguments for searching"""
      id: Union[int, 'types.IntFilter']
      created_at: Union[datetime.datetime, 'types.DateTimeFilter']
      title: Union[str, 'types.StringFilter']
      content: Union[str, 'types.StringFilter']
      published: Union[bool, 'types.BooleanFilter']
      author: 'UserRelationFilter'
      author_id: Union[int, 'types.IntFilter']
  
      # should be noted that AND and NOT should be Union['PostWhereInputRecursive1', List['PostWhereInputRecursive1']]
      # but this causes mypy to hang \_()_/
      AND: List['PostWhereInputRecursive1']
      OR: List['PostWhereInputRecursive1']
      NOT: List['PostWhereInputRecursive1']
  
  
  class PostWhereInputRecursive1(TypedDict, total=False):
      """Post arguments for searching"""
      id: Union[int, 'types.IntFilter']
      created_at: Union[datetime.datetime, 'types.DateTimeFilter']
      title: Union[str, 'types.StringFilter']
      content: Union[str, 'types.StringFilter']
      published: Union[bool, 'types.BooleanFilter']
      author: 'UserRelationFilter'
      author_id: Union[int, 'types.IntFilter']
  
      # should be noted that AND and NOT should be Union['PostWhereInputRecursive2', List['PostWhereInputRecursive2']]
      # but this causes mypy to hang \_()_/
      AND: List['PostWhereInputRecursive2']
      OR: List['PostWhereInputRecursive2']
      NOT: List['PostWhereInputRecursive2']
  
  
  class PostWhereInputRecursive2(TypedDict, total=False):
      """Post arguments for searching"""
      id: Union[int, 'types.IntFilter']
      created_at: Union[datetime.datetime, 'types.DateTimeFilter']
      title: Union[str, 'types.StringFilter']
      content: Union[str, 'types.StringFilter']
      published: Union[bool, 'types.BooleanFilter']
      author: 'UserRelationFilter'
      author_id: Union[int, 'types.IntFilter']
  
  
  
  PostKeys = Literal[
      'id',
      'created_at',
      'title',
      'content',
      'published',
      'author',
      'author_id',
  ]
  
  PostRelationalFieldKeys = Literal[
          'author',
      ]
  
  # User types
  
  class UserOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the User create method"""
      id: int
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
      posts: 'PostCreateManyNestedWithoutRelationsInput'
  
  
  class UserCreateInput(UserOptionalCreateInput):
      """Required arguments to the User create method"""
      email: str
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class UserOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the User create method, without relations"""
      id: int
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class UserCreateWithoutRelationsInput(UserOptionalCreateWithoutRelationsInput):
      """Required arguments to the User create method, without relations"""
      email: str
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  class UserCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'UserCreateWithoutRelationsInput'
      connect: 'UserWhereUniqueInput'
  
  
  class UserCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['UserCreateWithoutRelationsInput', List['UserCreateWithoutRelationsInput']]
      connect: Union['UserWhereUniqueInput', List['UserWhereUniqueInput']]
  
  
  class UserWhereUniqueInput(TypedDict, total=False):
      """Unique User arguments for searching"""
      id: int
      email: str
  
  
  class UserUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
      posts: 'PostUpdateManyWithoutRelationsInput'
  
  
  class UserUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: Union[AtomicIntInput, int]
      email: str
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
      posts: 'PostUpdateManyWithoutRelationsInput'
  
  
  class UserUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['UserCreateWithoutRelationsInput']
      connect: List['UserWhereUniqueInput']
      set: List['UserWhereUniqueInput']
      disconnect: List['UserWhereUniqueInput']
      delete: List['UserWhereUniqueInput']
  
      # TODO
      # update: List['UserUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['UserUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['UserScalarWhereInput']
      # upsert: List['UserUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['UserCreateOrConnectWithoutRelationsInput']
  
  
  class UserUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'UserCreateWithoutRelationsInput'
      connect: 'UserWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'UserUpdateInput'
      # upsert: 'UserUpsertWithoutRelationsInput'
      # connectOrCreate: 'UserCreateOrConnectWithoutRelationsInput'
  
  
  class UserUpsertInput(TypedDict):
      create: 'UserCreateInput'
      update: 'UserUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class UserOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      email: 'SortOrder'
      int: 'SortOrder'
      optional_int: 'SortOrder'
      float: 'SortOrder'
      optional_float: 'SortOrder'
      string: 'SortOrder'
      optional_string: 'SortOrder'
      enum: 'SortOrder'
      optional_enum: 'SortOrder'
      boolean: 'SortOrder'
      optional_boolean: 'SortOrder'
  
  
  # recursive User types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/latest/limitations/
  
  UserRelationFilter = TypedDict(
      'UserRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class UserListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class UserInclude(TypedDict, total=False):
      """User relational arguments"""
      posts: Union[bool, 'FindManyPostArgsFromUser']
  
  
      
  
  class PostIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
      author: Union[bool, 'UserArgsFromUserRecursive1']
  
  
  class PostIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
      author: Union[bool, 'UserArgsFromUserRecursive2']
  
  
  class PostIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class PostArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyPostArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
      posts: Union[bool, 'FindManyPostArgsFromUserRecursive1']
  
  
  class UserIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
      posts: Union[bool, 'FindManyPostArgsFromUserRecursive2']
  
  
  class UserIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class UserArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyUserArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
      n: Union[bool, 'FindManyNArgsFromUserRecursive1']
  
  
  class MIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
      n: Union[bool, 'FindManyNArgsFromUserRecursive2']
  
  
  class MIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class MArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyMArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
      m: Union[bool, 'FindManyMArgsFromUserRecursive1']
  
  
  class NIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
      m: Union[bool, 'FindManyMArgsFromUserRecursive2']
  
  
  class NIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class NArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyNArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
      many: Union[bool, 'FindManyManyRequiredArgsFromUserRecursive1']
  
  
  class OneOptionalIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
      many: Union[bool, 'FindManyManyRequiredArgsFromUserRecursive2']
  
  
  class OneOptionalIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class OneOptionalArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyOneOptionalArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
      one: Union[bool, 'OneOptionalArgsFromUserRecursive1']
  
  
  class ManyRequiredIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
      one: Union[bool, 'OneOptionalArgsFromUserRecursive2']
  
  
  class ManyRequiredIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class ManyRequiredArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyManyRequiredArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class AIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class AIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class AIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class AArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyAArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class BIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class BIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class BArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyBArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class CIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class CIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class CArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyCArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class DIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class DIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class DArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyDArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class EIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class EIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class EArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyEArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyUserArgs = FindManyUserArgsFromUser
  FindFirstUserArgs = FindManyUserArgsFromUser
  
  
      
  
  class UserWhereInput(TypedDict, total=False):
      """User arguments for searching"""
      id: Union[int, 'types.IntFilter']
      email: Union[str, 'types.StringFilter']
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
      posts: 'PostListRelationFilter'
  
      # should be noted that AND and NOT should be Union['UserWhereInputRecursive1', List['UserWhereInputRecursive1']]
      # but this causes mypy to hang \_()_/
      AND: List['UserWhereInputRecursive1']
      OR: List['UserWhereInputRecursive1']
      NOT: List['UserWhereInputRecursive1']
  
  
  class UserWhereInputRecursive1(TypedDict, total=False):
      """User arguments for searching"""
      id: Union[int, 'types.IntFilter']
      email: Union[str, 'types.StringFilter']
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
      posts: 'PostListRelationFilter'
  
      # should be noted that AND and NOT should be Union['UserWhereInputRecursive2', List['UserWhereInputRecursive2']]
      # but this causes mypy to hang \_()_/
      AND: List['UserWhereInputRecursive2']
      OR: List['UserWhereInputRecursive2']
      NOT: List['UserWhereInputRecursive2']
  
  
  class UserWhereInputRecursive2(TypedDict, total=False):
      """User arguments for searching"""
      id: Union[int, 'types.IntFilter']
      email: Union[str, 'types.StringFilter']
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
      posts: 'PostListRelationFilter'
  
  
  
  UserKeys = Literal[
      'id',
      'email',
      'int',
      'optional_int',
      'float',
      'optional_float',
      'string',
      'optional_string',
      'enum',
      'optional_enum',
      'boolean',
      'optional_boolean',
      'posts',
  ]
  
  UserRelationalFieldKeys = Literal[
          'posts',
      ]
  
  # M types
  
  class MOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the M create method"""
      id: int
      n: 'NCreateManyNestedWithoutRelationsInput'
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class MCreateInput(MOptionalCreateInput):
      """Required arguments to the M create method"""
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class MOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the M create method, without relations"""
      id: int
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class MCreateWithoutRelationsInput(MOptionalCreateWithoutRelationsInput):
      """Required arguments to the M create method, without relations"""
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  class MCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'MCreateWithoutRelationsInput'
      connect: 'MWhereUniqueInput'
  
  
  class MCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['MCreateWithoutRelationsInput', List['MCreateWithoutRelationsInput']]
      connect: Union['MWhereUniqueInput', List['MWhereUniqueInput']]
  
  
  class MWhereUniqueInput(TypedDict, total=False):
      """Unique M arguments for searching"""
      id: int
  
  
  class MUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      n: 'NUpdateManyWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class MUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: Union[AtomicIntInput, int]
      n: 'NUpdateManyWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class MUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['MCreateWithoutRelationsInput']
      connect: List['MWhereUniqueInput']
      set: List['MWhereUniqueInput']
      disconnect: List['MWhereUniqueInput']
      delete: List['MWhereUniqueInput']
  
      # TODO
      # update: List['MUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['MUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['MScalarWhereInput']
      # upsert: List['MUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['MCreateOrConnectWithoutRelationsInput']
  
  
  class MUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'MCreateWithoutRelationsInput'
      connect: 'MWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'MUpdateInput'
      # upsert: 'MUpsertWithoutRelationsInput'
      # connectOrCreate: 'MCreateOrConnectWithoutRelationsInput'
  
  
  class MUpsertInput(TypedDict):
      create: 'MCreateInput'
      update: 'MUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class MOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      int: 'SortOrder'
      optional_int: 'SortOrder'
      float: 'SortOrder'
      optional_float: 'SortOrder'
      string: 'SortOrder'
      optional_string: 'SortOrder'
      enum: 'SortOrder'
      optional_enum: 'SortOrder'
      boolean: 'SortOrder'
      optional_boolean: 'SortOrder'
  
  
  # recursive M types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/latest/limitations/
  
  MRelationFilter = TypedDict(
      'MRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class MListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class MInclude(TypedDict, total=False):
      """M relational arguments"""
      n: Union[bool, 'FindManyNArgsFromM']
  
  
      
  
  class PostIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
      author: Union[bool, 'UserArgsFromMRecursive1']
  
  
  class PostIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
      author: Union[bool, 'UserArgsFromMRecursive2']
  
  
  class PostIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class PostArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyPostArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
      posts: Union[bool, 'FindManyPostArgsFromMRecursive1']
  
  
  class UserIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
      posts: Union[bool, 'FindManyPostArgsFromMRecursive2']
  
  
  class UserIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class UserArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyUserArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
      n: Union[bool, 'FindManyNArgsFromMRecursive1']
  
  
  class MIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
      n: Union[bool, 'FindManyNArgsFromMRecursive2']
  
  
  class MIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class MArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyMArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
      m: Union[bool, 'FindManyMArgsFromMRecursive1']
  
  
  class NIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
      m: Union[bool, 'FindManyMArgsFromMRecursive2']
  
  
  class NIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class NArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyNArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
      many: Union[bool, 'FindManyManyRequiredArgsFromMRecursive1']
  
  
  class OneOptionalIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
      many: Union[bool, 'FindManyManyRequiredArgsFromMRecursive2']
  
  
  class OneOptionalIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class OneOptionalArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyOneOptionalArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
      one: Union[bool, 'OneOptionalArgsFromMRecursive1']
  
  
  class ManyRequiredIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
      one: Union[bool, 'OneOptionalArgsFromMRecursive2']
  
  
  class ManyRequiredIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class ManyRequiredArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyManyRequiredArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class AIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class AIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class AIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class AArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyAArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class BIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class BIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class BArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyBArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class CIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class CIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class CArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyCArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class DIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class DIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class DArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyDArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class EIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class EIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class EArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyEArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyMArgs = FindManyMArgsFromM
  FindFirstMArgs = FindManyMArgsFromM
  
  
      
  
  class MWhereInput(TypedDict, total=False):
      """M arguments for searching"""
      id: Union[int, 'types.IntFilter']
      n: 'NListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['MWhereInputRecursive1', List['MWhereInputRecursive1']]
      # but this causes mypy to hang \_()_/
      AND: List['MWhereInputRecursive1']
      OR: List['MWhereInputRecursive1']
      NOT: List['MWhereInputRecursive1']
  
  
  class MWhereInputRecursive1(TypedDict, total=False):
      """M arguments for searching"""
      id: Union[int, 'types.IntFilter']
      n: 'NListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['MWhereInputRecursive2', List['MWhereInputRecursive2']]
      # but this causes mypy to hang \_()_/
      AND: List['MWhereInputRecursive2']
      OR: List['MWhereInputRecursive2']
      NOT: List['MWhereInputRecursive2']
  
  
  class MWhereInputRecursive2(TypedDict, total=False):
      """M arguments for searching"""
      id: Union[int, 'types.IntFilter']
      n: 'NListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
  
  
  MKeys = Literal[
      'id',
      'n',
      'int',
      'optional_int',
      'float',
      'optional_float',
      'string',
      'optional_string',
      'enum',
      'optional_enum',
      'boolean',
      'optional_boolean',
  ]
  
  MRelationalFieldKeys = Literal[
          'n',
      ]
  
  # N types
  
  class NOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the N create method"""
      id: int
      m: 'MCreateManyNestedWithoutRelationsInput'
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_json: Optional['fields.Json']
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class NCreateInput(NOptionalCreateInput):
      """Required arguments to the N create method"""
      int: int
      float: float
      string: str
      json_: 'fields.Json'
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class NOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the N create method, without relations"""
      id: int
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_json: Optional['fields.Json']
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class NCreateWithoutRelationsInput(NOptionalCreateWithoutRelationsInput):
      """Required arguments to the N create method, without relations"""
      int: int
      float: float
      string: str
      json_: 'fields.Json'
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  class NCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'NCreateWithoutRelationsInput'
      connect: 'NWhereUniqueInput'
  
  
  class NCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['NCreateWithoutRelationsInput', List['NCreateWithoutRelationsInput']]
      connect: Union['NWhereUniqueInput', List['NWhereUniqueInput']]
  
  
  class NWhereUniqueInput(TypedDict, total=False):
      """Unique N arguments for searching"""
      id: int
  
  
  class NUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      m: 'MUpdateManyWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      json_: 'fields.Json'
      optional_json: Optional['fields.Json']
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class NUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: Union[AtomicIntInput, int]
      m: 'MUpdateManyWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      json_: 'fields.Json'
      optional_json: Optional['fields.Json']
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class NUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['NCreateWithoutRelationsInput']
      connect: List['NWhereUniqueInput']
      set: List['NWhereUniqueInput']
      disconnect: List['NWhereUniqueInput']
      delete: List['NWhereUniqueInput']
  
      # TODO
      # update: List['NUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['NUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['NScalarWhereInput']
      # upsert: List['NUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['NCreateOrConnectWithoutRelationsInput']
  
  
  class NUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'NCreateWithoutRelationsInput'
      connect: 'NWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'NUpdateInput'
      # upsert: 'NUpsertWithoutRelationsInput'
      # connectOrCreate: 'NCreateOrConnectWithoutRelationsInput'
  
  
  class NUpsertInput(TypedDict):
      create: 'NCreateInput'
      update: 'NUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class NOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      int: 'SortOrder'
      optional_int: 'SortOrder'
      float: 'SortOrder'
      optional_float: 'SortOrder'
      string: 'SortOrder'
      optional_string: 'SortOrder'
      json_: 'SortOrder'
      optional_json: 'SortOrder'
      enum: 'SortOrder'
      optional_enum: 'SortOrder'
      boolean: 'SortOrder'
      optional_boolean: 'SortOrder'
  
  
  # recursive N types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/latest/limitations/
  
  NRelationFilter = TypedDict(
      'NRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class NListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class NInclude(TypedDict, total=False):
      """N relational arguments"""
      m: Union[bool, 'FindManyMArgsFromN']
  
  
      
  
  class PostIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
      author: Union[bool, 'UserArgsFromNRecursive1']
  
  
  class PostIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
      author: Union[bool, 'UserArgsFromNRecursive2']
  
  
  class PostIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class PostArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyPostArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
      posts: Union[bool, 'FindManyPostArgsFromNRecursive1']
  
  
  class UserIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
      posts: Union[bool, 'FindManyPostArgsFromNRecursive2']
  
  
  class UserIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class UserArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyUserArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
      n: Union[bool, 'FindManyNArgsFromNRecursive1']
  
  
  class MIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
      n: Union[bool, 'FindManyNArgsFromNRecursive2']
  
  
  class MIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class MArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyMArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
      m: Union[bool, 'FindManyMArgsFromNRecursive1']
  
  
  class NIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
      m: Union[bool, 'FindManyMArgsFromNRecursive2']
  
  
  class NIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class NArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyNArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
      many: Union[bool, 'FindManyManyRequiredArgsFromNRecursive1']
  
  
  class OneOptionalIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
      many: Union[bool, 'FindManyManyRequiredArgsFromNRecursive2']
  
  
  class OneOptionalIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class OneOptionalArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyOneOptionalArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
      one: Union[bool, 'OneOptionalArgsFromNRecursive1']
  
  
  class ManyRequiredIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
      one: Union[bool, 'OneOptionalArgsFromNRecursive2']
  
  
  class ManyRequiredIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class ManyRequiredArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyManyRequiredArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class AIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class AIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class AIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class AArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyAArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class BIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class BIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class BArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyBArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class CIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class CIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class CArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyCArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class DIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class DIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class DArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyDArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class EIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class EIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class EArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyEArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyNArgs = FindManyNArgsFromN
  FindFirstNArgs = FindManyNArgsFromN
  
  
      
  
  class NWhereInput(TypedDict, total=False):
      """N arguments for searching"""
      id: Union[int, 'types.IntFilter']
      m: 'MListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      json_: Union['fields.Json', 'types.JsonFilter']
      optional_json: Union['fields.Json', 'types.JsonFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['NWhereInputRecursive1', List['NWhereInputRecursive1']]
      # but this causes mypy to hang \_()_/
      AND: List['NWhereInputRecursive1']
      OR: List['NWhereInputRecursive1']
      NOT: List['NWhereInputRecursive1']
  
  
  class NWhereInputRecursive1(TypedDict, total=False):
      """N arguments for searching"""
      id: Union[int, 'types.IntFilter']
      m: 'MListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      json_: Union['fields.Json', 'types.JsonFilter']
      optional_json: Union['fields.Json', 'types.JsonFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['NWhereInputRecursive2', List['NWhereInputRecursive2']]
      # but this causes mypy to hang \_()_/
      AND: List['NWhereInputRecursive2']
      OR: List['NWhereInputRecursive2']
      NOT: List['NWhereInputRecursive2']
  
  
  class NWhereInputRecursive2(TypedDict, total=False):
      """N arguments for searching"""
      id: Union[int, 'types.IntFilter']
      m: 'MListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      json_: Union['fields.Json', 'types.JsonFilter']
      optional_json: Union['fields.Json', 'types.JsonFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
  
  
  NKeys = Literal[
      'id',
      'm',
      'int',
      'optional_int',
      'float',
      'optional_float',
      'string',
      'optional_string',
      'json_',
      'optional_json',
      'enum',
      'optional_enum',
      'boolean',
      'optional_boolean',
  ]
  
  NRelationalFieldKeys = Literal[
          'm',
      ]
  
  # OneOptional types
  
  class OneOptionalOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the OneOptional create method"""
      id: int
      many: 'ManyRequiredCreateManyNestedWithoutRelationsInput'
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class OneOptionalCreateInput(OneOptionalOptionalCreateInput):
      """Required arguments to the OneOptional create method"""
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class OneOptionalOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the OneOptional create method, without relations"""
      id: int
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class OneOptionalCreateWithoutRelationsInput(OneOptionalOptionalCreateWithoutRelationsInput):
      """Required arguments to the OneOptional create method, without relations"""
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  class OneOptionalCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'OneOptionalCreateWithoutRelationsInput'
      connect: 'OneOptionalWhereUniqueInput'
  
  
  class OneOptionalCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['OneOptionalCreateWithoutRelationsInput', List['OneOptionalCreateWithoutRelationsInput']]
      connect: Union['OneOptionalWhereUniqueInput', List['OneOptionalWhereUniqueInput']]
  
  
  class OneOptionalWhereUniqueInput(TypedDict, total=False):
      """Unique OneOptional arguments for searching"""
      id: int
  
  
  class OneOptionalUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      many: 'ManyRequiredUpdateManyWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class OneOptionalUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: Union[AtomicIntInput, int]
      many: 'ManyRequiredUpdateManyWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class OneOptionalUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['OneOptionalCreateWithoutRelationsInput']
      connect: List['OneOptionalWhereUniqueInput']
      set: List['OneOptionalWhereUniqueInput']
      disconnect: List['OneOptionalWhereUniqueInput']
      delete: List['OneOptionalWhereUniqueInput']
  
      # TODO
      # update: List['OneOptionalUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['OneOptionalUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['OneOptionalScalarWhereInput']
      # upsert: List['OneOptionalUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['OneOptionalCreateOrConnectWithoutRelationsInput']
  
  
  class OneOptionalUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'OneOptionalCreateWithoutRelationsInput'
      connect: 'OneOptionalWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'OneOptionalUpdateInput'
      # upsert: 'OneOptionalUpsertWithoutRelationsInput'
      # connectOrCreate: 'OneOptionalCreateOrConnectWithoutRelationsInput'
  
  
  class OneOptionalUpsertInput(TypedDict):
      create: 'OneOptionalCreateInput'
      update: 'OneOptionalUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class OneOptionalOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      int: 'SortOrder'
      optional_int: 'SortOrder'
      float: 'SortOrder'
      optional_float: 'SortOrder'
      string: 'SortOrder'
      optional_string: 'SortOrder'
      enum: 'SortOrder'
      optional_enum: 'SortOrder'
      boolean: 'SortOrder'
      optional_boolean: 'SortOrder'
  
  
  # recursive OneOptional types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/latest/limitations/
  
  OneOptionalRelationFilter = TypedDict(
      'OneOptionalRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class OneOptionalListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class OneOptionalInclude(TypedDict, total=False):
      """OneOptional relational arguments"""
      many: Union[bool, 'FindManyManyRequiredArgsFromOneOptional']
  
  
      
  
  class PostIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      author: Union[bool, 'UserArgsFromOneOptionalRecursive1']
  
  
  class PostIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      author: Union[bool, 'UserArgsFromOneOptionalRecursive2']
  
  
  class PostIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class PostArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyPostArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      posts: Union[bool, 'FindManyPostArgsFromOneOptionalRecursive1']
  
  
  class UserIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      posts: Union[bool, 'FindManyPostArgsFromOneOptionalRecursive2']
  
  
  class UserIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class UserArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyUserArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      n: Union[bool, 'FindManyNArgsFromOneOptionalRecursive1']
  
  
  class MIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      n: Union[bool, 'FindManyNArgsFromOneOptionalRecursive2']
  
  
  class MIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class MArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyMArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      m: Union[bool, 'FindManyMArgsFromOneOptionalRecursive1']
  
  
  class NIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      m: Union[bool, 'FindManyMArgsFromOneOptionalRecursive2']
  
  
  class NIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class NArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyNArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      many: Union[bool, 'FindManyManyRequiredArgsFromOneOptionalRecursive1']
  
  
  class OneOptionalIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      many: Union[bool, 'FindManyManyRequiredArgsFromOneOptionalRecursive2']
  
  
  class OneOptionalIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class OneOptionalArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyOneOptionalArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      one: Union[bool, 'OneOptionalArgsFromOneOptionalRecursive1']
  
  
  class ManyRequiredIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      one: Union[bool, 'OneOptionalArgsFromOneOptionalRecursive2']
  
  
  class ManyRequiredIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class ManyRequiredArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyManyRequiredArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class AIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class AIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class AIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class AArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyAArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class BIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class BIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class BArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyBArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class CIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class CIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class CArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyCArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class DIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class DIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class DArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyDArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class EIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class EIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class EArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyEArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyOneOptionalArgs = FindManyOneOptionalArgsFromOneOptional
  FindFirstOneOptionalArgs = FindManyOneOptionalArgsFromOneOptional
  
  
      
  
  class OneOptionalWhereInput(TypedDict, total=False):
      """OneOptional arguments for searching"""
      id: Union[int, 'types.IntFilter']
      many: 'ManyRequiredListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['OneOptionalWhereInputRecursive1', List['OneOptionalWhereInputRecursive1']]
      # but this causes mypy to hang \_()_/
      AND: List['OneOptionalWhereInputRecursive1']
      OR: List['OneOptionalWhereInputRecursive1']
      NOT: List['OneOptionalWhereInputRecursive1']
  
  
  class OneOptionalWhereInputRecursive1(TypedDict, total=False):
      """OneOptional arguments for searching"""
      id: Union[int, 'types.IntFilter']
      many: 'ManyRequiredListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['OneOptionalWhereInputRecursive2', List['OneOptionalWhereInputRecursive2']]
      # but this causes mypy to hang \_()_/
      AND: List['OneOptionalWhereInputRecursive2']
      OR: List['OneOptionalWhereInputRecursive2']
      NOT: List['OneOptionalWhereInputRecursive2']
  
  
  class OneOptionalWhereInputRecursive2(TypedDict, total=False):
      """OneOptional arguments for searching"""
      id: Union[int, 'types.IntFilter']
      many: 'ManyRequiredListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
  
  
  OneOptionalKeys = Literal[
      'id',
      'many',
      'int',
      'optional_int',
      'float',
      'optional_float',
      'string',
      'optional_string',
      'enum',
      'optional_enum',
      'boolean',
      'optional_boolean',
  ]
  
  OneOptionalRelationalFieldKeys = Literal[
          'many',
      ]
  
  # ManyRequired types
  
  class ManyRequiredOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the ManyRequired create method"""
      id: int
      one: 'OneOptionalCreateNestedWithoutRelationsInput'
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class ManyRequiredCreateInput(ManyRequiredOptionalCreateInput):
      """Required arguments to the ManyRequired create method"""
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class ManyRequiredOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the ManyRequired create method, without relations"""
      id: int
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class ManyRequiredCreateWithoutRelationsInput(ManyRequiredOptionalCreateWithoutRelationsInput):
      """Required arguments to the ManyRequired create method, without relations"""
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  class ManyRequiredCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'ManyRequiredCreateWithoutRelationsInput'
      connect: 'ManyRequiredWhereUniqueInput'
  
  
  class ManyRequiredCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['ManyRequiredCreateWithoutRelationsInput', List['ManyRequiredCreateWithoutRelationsInput']]
      connect: Union['ManyRequiredWhereUniqueInput', List['ManyRequiredWhereUniqueInput']]
  
  
  class ManyRequiredWhereUniqueInput(TypedDict, total=False):
      """Unique ManyRequired arguments for searching"""
      id: int
  
  
  class ManyRequiredUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      one: 'OneOptionalUpdateOneWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class ManyRequiredUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: Union[AtomicIntInput, int]
      one: 'OneOptionalUpdateOneWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class ManyRequiredUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['ManyRequiredCreateWithoutRelationsInput']
      connect: List['ManyRequiredWhereUniqueInput']
      set: List['ManyRequiredWhereUniqueInput']
      disconnect: List['ManyRequiredWhereUniqueInput']
      delete: List['ManyRequiredWhereUniqueInput']
  
      # TODO
      # update: List['ManyRequiredUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['ManyRequiredUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['ManyRequiredScalarWhereInput']
      # upsert: List['ManyRequiredUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['ManyRequiredCreateOrConnectWithoutRelationsInput']
  
  
  class ManyRequiredUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'ManyRequiredCreateWithoutRelationsInput'
      connect: 'ManyRequiredWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'ManyRequiredUpdateInput'
      # upsert: 'ManyRequiredUpsertWithoutRelationsInput'
      # connectOrCreate: 'ManyRequiredCreateOrConnectWithoutRelationsInput'
  
  
  class ManyRequiredUpsertInput(TypedDict):
      create: 'ManyRequiredCreateInput'
      update: 'ManyRequiredUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class ManyRequiredOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      one_optional_id: 'SortOrder'
      int: 'SortOrder'
      optional_int: 'SortOrder'
      float: 'SortOrder'
      optional_float: 'SortOrder'
      string: 'SortOrder'
      optional_string: 'SortOrder'
      enum: 'SortOrder'
      optional_enum: 'SortOrder'
      boolean: 'SortOrder'
      optional_boolean: 'SortOrder'
  
  
  # recursive ManyRequired types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/latest/limitations/
  
  ManyRequiredRelationFilter = TypedDict(
      'ManyRequiredRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class ManyRequiredListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class ManyRequiredInclude(TypedDict, total=False):
      """ManyRequired relational arguments"""
      one: Union[bool, 'OneOptionalArgsFromManyRequired']
  
  
      
  
  class PostIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      author: Union[bool, 'UserArgsFromManyRequiredRecursive1']
  
  
  class PostIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      author: Union[bool, 'UserArgsFromManyRequiredRecursive2']
  
  
  class PostIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class PostArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyPostArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      posts: Union[bool, 'FindManyPostArgsFromManyRequiredRecursive1']
  
  
  class UserIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      posts: Union[bool, 'FindManyPostArgsFromManyRequiredRecursive2']
  
  
  class UserIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class UserArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyUserArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      n: Union[bool, 'FindManyNArgsFromManyRequiredRecursive1']
  
  
  class MIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      n: Union[bool, 'FindManyNArgsFromManyRequiredRecursive2']
  
  
  class MIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class MArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyMArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      m: Union[bool, 'FindManyMArgsFromManyRequiredRecursive1']
  
  
  class NIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      m: Union[bool, 'FindManyMArgsFromManyRequiredRecursive2']
  
  
  class NIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class NArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyNArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      many: Union[bool, 'FindManyManyRequiredArgsFromManyRequiredRecursive1']
  
  
  class OneOptionalIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      many: Union[bool, 'FindManyManyRequiredArgsFromManyRequiredRecursive2']
  
  
  class OneOptionalIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class OneOptionalArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyOneOptionalArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      one: Union[bool, 'OneOptionalArgsFromManyRequiredRecursive1']
  
  
  class ManyRequiredIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      one: Union[bool, 'OneOptionalArgsFromManyRequiredRecursive2']
  
  
  class ManyRequiredIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class ManyRequiredArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyManyRequiredArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class AIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class AIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class AIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class AArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyAArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class BIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class BIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class BArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyBArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class CIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class CIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class CArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyCArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class DIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class DIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class DArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyDArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class EIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class EIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class EArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyEArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyManyRequiredArgs = FindManyManyRequiredArgsFromManyRequired
  FindFirstManyRequiredArgs = FindManyManyRequiredArgsFromManyRequired
  
  
      
  
  class ManyRequiredWhereInput(TypedDict, total=False):
      """ManyRequired arguments for searching"""
      id: Union[int, 'types.IntFilter']
      one: 'OneOptionalRelationFilter'
      one_optional_id: Union[int, 'types.IntFilter']
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['ManyRequiredWhereInputRecursive1', List['ManyRequiredWhereInputRecursive1']]
      # but this causes mypy to hang \_()_/
      AND: List['ManyRequiredWhereInputRecursive1']
      OR: List['ManyRequiredWhereInputRecursive1']
      NOT: List['ManyRequiredWhereInputRecursive1']
  
  
  class ManyRequiredWhereInputRecursive1(TypedDict, total=False):
      """ManyRequired arguments for searching"""
      id: Union[int, 'types.IntFilter']
      one: 'OneOptionalRelationFilter'
      one_optional_id: Union[int, 'types.IntFilter']
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['ManyRequiredWhereInputRecursive2', List['ManyRequiredWhereInputRecursive2']]
      # but this causes mypy to hang \_()_/
      AND: List['ManyRequiredWhereInputRecursive2']
      OR: List['ManyRequiredWhereInputRecursive2']
      NOT: List['ManyRequiredWhereInputRecursive2']
  
  
  class ManyRequiredWhereInputRecursive2(TypedDict, total=False):
      """ManyRequired arguments for searching"""
      id: Union[int, 'types.IntFilter']
      one: 'OneOptionalRelationFilter'
      one_optional_id: Union[int, 'types.IntFilter']
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
  
  
  ManyRequiredKeys = Literal[
      'id',
      'one',
      'one_optional_id',
      'int',
      'optional_int',
      'float',
      'optional_float',
      'string',
      'optional_string',
      'enum',
      'optional_enum',
      'boolean',
      'optional_boolean',
  ]
  
  ManyRequiredRelationalFieldKeys = Literal[
          'one',
      ]
  
  # A types
  
  class AOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the A create method"""
      id: str
      name: Optional[str]
      inc_int: int
      inc_sInt: int
      inc_bInt: int
  
  
  class ACreateInput(AOptionalCreateInput):
      """Required arguments to the A create method"""
      email: str
      int: int
      sInt: int
      bInt: int
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class AOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the A create method, without relations"""
      id: str
      name: Optional[str]
      inc_int: int
      inc_sInt: int
      inc_bInt: int
  
  
  class ACreateWithoutRelationsInput(AOptionalCreateWithoutRelationsInput):
      """Required arguments to the A create method, without relations"""
      email: str
      int: int
      sInt: int
      bInt: int
  
  
  class ACreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'ACreateWithoutRelationsInput'
      connect: 'AWhereUniqueInput'
  
  
  class ACreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['ACreateWithoutRelationsInput', List['ACreateWithoutRelationsInput']]
      connect: Union['AWhereUniqueInput', List['AWhereUniqueInput']]
  
  
  class AWhereUniqueInput(TypedDict, total=False):
      """Unique A arguments for searching"""
      id: str
      email: str
  
  
  class AUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      name: Optional[str]
      int: Union[AtomicIntInput, int]
      sInt: Union[AtomicIntInput, int]
      inc_int: Union[AtomicIntInput, int]
      inc_sInt: Union[AtomicIntInput, int]
      bInt: Union[AtomicBigIntInput, int]
      inc_bInt: Union[AtomicBigIntInput, int]
  
  
  class AUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: str
      email: str
      name: Optional[str]
      int: Union[AtomicIntInput, int]
      sInt: Union[AtomicIntInput, int]
      inc_int: Union[AtomicIntInput, int]
      inc_sInt: Union[AtomicIntInput, int]
      bInt: Union[AtomicBigIntInput, int]
      inc_bInt: Union[AtomicBigIntInput, int]
  
  
  class AUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['ACreateWithoutRelationsInput']
      connect: List['AWhereUniqueInput']
      set: List['AWhereUniqueInput']
      disconnect: List['AWhereUniqueInput']
      delete: List['AWhereUniqueInput']
  
      # TODO
      # update: List['AUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['AUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['AScalarWhereInput']
      # upsert: List['AUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['ACreateOrConnectWithoutRelationsInput']
  
  
  class AUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'ACreateWithoutRelationsInput'
      connect: 'AWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'AUpdateInput'
      # upsert: 'AUpsertWithoutRelationsInput'
      # connectOrCreate: 'ACreateOrConnectWithoutRelationsInput'
  
  
  class AUpsertInput(TypedDict):
      create: 'ACreateInput'
      update: 'AUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class AOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      email: 'SortOrder'
      name: 'SortOrder'
      int: 'SortOrder'
      sInt: 'SortOrder'
      inc_int: 'SortOrder'
      inc_sInt: 'SortOrder'
      bInt: 'SortOrder'
      inc_bInt: 'SortOrder'
  
  
  # recursive A types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/latest/limitations/
  
  ARelationFilter = TypedDict(
      'ARelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class AListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class AInclude(TypedDict, total=False):
      """A relational arguments"""
  
  
      
  
  class PostIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
      author: Union[bool, 'UserArgsFromARecursive1']
  
  
  class PostIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
      author: Union[bool, 'UserArgsFromARecursive2']
  
  
  class PostIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class PostArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyPostArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
      posts: Union[bool, 'FindManyPostArgsFromARecursive1']
  
  
  class UserIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
      posts: Union[bool, 'FindManyPostArgsFromARecursive2']
  
  
  class UserIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class UserArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyUserArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
      n: Union[bool, 'FindManyNArgsFromARecursive1']
  
  
  class MIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
      n: Union[bool, 'FindManyNArgsFromARecursive2']
  
  
  class MIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class MArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyMArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
      m: Union[bool, 'FindManyMArgsFromARecursive1']
  
  
  class NIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
      m: Union[bool, 'FindManyMArgsFromARecursive2']
  
  
  class NIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class NArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyNArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
      many: Union[bool, 'FindManyManyRequiredArgsFromARecursive1']
  
  
  class OneOptionalIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
      many: Union[bool, 'FindManyManyRequiredArgsFromARecursive2']
  
  
  class OneOptionalIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class OneOptionalArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyOneOptionalArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
      one: Union[bool, 'OneOptionalArgsFromARecursive1']
  
  
  class ManyRequiredIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
      one: Union[bool, 'OneOptionalArgsFromARecursive2']
  
  
  class ManyRequiredIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class ManyRequiredArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyManyRequiredArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class AIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class AIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class AIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class AArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyAArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class BIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class BIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class BArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyBArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class CIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class CIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class CArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyCArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class DIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class DIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class DArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyDArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class EIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class EIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class EArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyEArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyAArgs = FindManyAArgsFromA
  FindFirstAArgs = FindManyAArgsFromA
  
  
      
  
  class AWhereInput(TypedDict, total=False):
      """A arguments for searching"""
      id: Union[str, 'types.StringFilter']
      email: Union[str, 'types.StringFilter']
      name: Union[str, 'types.StringFilter']
      int: Union[int, 'types.IntFilter']
      sInt: Union[int, 'types.IntFilter']
      inc_int: Union[int, 'types.IntFilter']
      inc_sInt: Union[int, 'types.IntFilter']
      bInt: Union[int, 'types.BigIntFilter']
      inc_bInt: Union[int, 'types.BigIntFilter']
  
      # should be noted that AND and NOT should be Union['AWhereInputRecursive1', List['AWhereInputRecursive1']]
      # but this causes mypy to hang \_()_/
      AND: List['AWhereInputRecursive1']
      OR: List['AWhereInputRecursive1']
      NOT: List['AWhereInputRecursive1']
  
  
  class AWhereInputRecursive1(TypedDict, total=False):
      """A arguments for searching"""
      id: Union[str, 'types.StringFilter']
      email: Union[str, 'types.StringFilter']
      name: Union[str, 'types.StringFilter']
      int: Union[int, 'types.IntFilter']
      sInt: Union[int, 'types.IntFilter']
      inc_int: Union[int, 'types.IntFilter']
      inc_sInt: Union[int, 'types.IntFilter']
      bInt: Union[int, 'types.BigIntFilter']
      inc_bInt: Union[int, 'types.BigIntFilter']
  
      # should be noted that AND and NOT should be Union['AWhereInputRecursive2', List['AWhereInputRecursive2']]
      # but this causes mypy to hang \_()_/
      AND: List['AWhereInputRecursive2']
      OR: List['AWhereInputRecursive2']
      NOT: List['AWhereInputRecursive2']
  
  
  class AWhereInputRecursive2(TypedDict, total=False):
      """A arguments for searching"""
      id: Union[str, 'types.StringFilter']
      email: Union[str, 'types.StringFilter']
      name: Union[str, 'types.StringFilter']
      int: Union[int, 'types.IntFilter']
      sInt: Union[int, 'types.IntFilter']
      inc_int: Union[int, 'types.IntFilter']
      inc_sInt: Union[int, 'types.IntFilter']
      bInt: Union[int, 'types.BigIntFilter']
      inc_bInt: Union[int, 'types.BigIntFilter']
  
  
  
  AKeys = Literal[
      'id',
      'email',
      'name',
      'int',
      'sInt',
      'inc_int',
      'inc_sInt',
      'bInt',
      'inc_bInt',
  ]
  
  ARelationalFieldKeys = _NoneType
  
  # B types
  
  class BOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the B create method"""
      id: str
  
  
  class BCreateInput(BOptionalCreateInput):
      """Required arguments to the B create method"""
      float: float
      d_float: float
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class BOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the B create method, without relations"""
      id: str
  
  
  class BCreateWithoutRelationsInput(BOptionalCreateWithoutRelationsInput):
      """Required arguments to the B create method, without relations"""
      float: float
      d_float: float
  
  
  class BCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'BCreateWithoutRelationsInput'
      connect: 'BWhereUniqueInput'
  
  
  class BCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['BCreateWithoutRelationsInput', List['BCreateWithoutRelationsInput']]
      connect: Union['BWhereUniqueInput', List['BWhereUniqueInput']]
  
  
  class BWhereUniqueInput(TypedDict, total=False):
      """Unique B arguments for searching"""
      id: str
  
  
  class BUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      float: Union[AtomicFloatInput, float]
      d_float: Union[AtomicFloatInput, float]
  
  
  class BUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: str
      float: Union[AtomicFloatInput, float]
      d_float: Union[AtomicFloatInput, float]
  
  
  class BUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['BCreateWithoutRelationsInput']
      connect: List['BWhereUniqueInput']
      set: List['BWhereUniqueInput']
      disconnect: List['BWhereUniqueInput']
      delete: List['BWhereUniqueInput']
  
      # TODO
      # update: List['BUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['BUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['BScalarWhereInput']
      # upsert: List['BUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['BCreateOrConnectWithoutRelationsInput']
  
  
  class BUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'BCreateWithoutRelationsInput'
      connect: 'BWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'BUpdateInput'
      # upsert: 'BUpsertWithoutRelationsInput'
      # connectOrCreate: 'BCreateOrConnectWithoutRelationsInput'
  
  
  class BUpsertInput(TypedDict):
      create: 'BCreateInput'
      update: 'BUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class BOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      float: 'SortOrder'
      d_float: 'SortOrder'
  
  
  # recursive B types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/latest/limitations/
  
  BRelationFilter = TypedDict(
      'BRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class BListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class BInclude(TypedDict, total=False):
      """B relational arguments"""
  
  
      
  
  class PostIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
      author: Union[bool, 'UserArgsFromBRecursive1']
  
  
  class PostIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
      author: Union[bool, 'UserArgsFromBRecursive2']
  
  
  class PostIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class PostArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyPostArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
      posts: Union[bool, 'FindManyPostArgsFromBRecursive1']
  
  
  class UserIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
      posts: Union[bool, 'FindManyPostArgsFromBRecursive2']
  
  
  class UserIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class UserArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyUserArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
      n: Union[bool, 'FindManyNArgsFromBRecursive1']
  
  
  class MIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
      n: Union[bool, 'FindManyNArgsFromBRecursive2']
  
  
  class MIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class MArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyMArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
      m: Union[bool, 'FindManyMArgsFromBRecursive1']
  
  
  class NIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
      m: Union[bool, 'FindManyMArgsFromBRecursive2']
  
  
  class NIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class NArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyNArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
      many: Union[bool, 'FindManyManyRequiredArgsFromBRecursive1']
  
  
  class OneOptionalIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
      many: Union[bool, 'FindManyManyRequiredArgsFromBRecursive2']
  
  
  class OneOptionalIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class OneOptionalArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyOneOptionalArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
      one: Union[bool, 'OneOptionalArgsFromBRecursive1']
  
  
  class ManyRequiredIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
      one: Union[bool, 'OneOptionalArgsFromBRecursive2']
  
  
  class ManyRequiredIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class ManyRequiredArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyManyRequiredArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class AIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class AIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class AIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class AArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyAArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class BIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class BIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class BArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyBArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class CIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class CIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class CArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyCArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class DIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class DIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class DArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyDArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class EIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class EIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class EArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyEArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyBArgs = FindManyBArgsFromB
  FindFirstBArgs = FindManyBArgsFromB
  
  
      
  
  class BWhereInput(TypedDict, total=False):
      """B arguments for searching"""
      id: Union[str, 'types.StringFilter']
      float: Union[float, 'types.FloatFilter']
      d_float: Union[float, 'types.FloatFilter']
  
      # should be noted that AND and NOT should be Union['BWhereInputRecursive1', List['BWhereInputRecursive1']]
      # but this causes mypy to hang \_()_/
      AND: List['BWhereInputRecursive1']
      OR: List['BWhereInputRecursive1']
      NOT: List['BWhereInputRecursive1']
  
  
  class BWhereInputRecursive1(TypedDict, total=False):
      """B arguments for searching"""
      id: Union[str, 'types.StringFilter']
      float: Union[float, 'types.FloatFilter']
      d_float: Union[float, 'types.FloatFilter']
  
      # should be noted that AND and NOT should be Union['BWhereInputRecursive2', List['BWhereInputRecursive2']]
      # but this causes mypy to hang \_()_/
      AND: List['BWhereInputRecursive2']
      OR: List['BWhereInputRecursive2']
      NOT: List['BWhereInputRecursive2']
  
  
  class BWhereInputRecursive2(TypedDict, total=False):
      """B arguments for searching"""
      id: Union[str, 'types.StringFilter']
      float: Union[float, 'types.FloatFilter']
      d_float: Union[float, 'types.FloatFilter']
  
  
  
  BKeys = Literal[
      'id',
      'float',
      'd_float',
  ]
  
  BRelationalFieldKeys = _NoneType
  
  # C types
  
  class COptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the C create method"""
      id: str
  
  
  class CCreateInput(COptionalCreateInput):
      """Required arguments to the C create method"""
      char: str
      v_char: str
      text: str
      bit: str
      v_bit: str
      uuid: str
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class COptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the C create method, without relations"""
      id: str
  
  
  class CCreateWithoutRelationsInput(COptionalCreateWithoutRelationsInput):
      """Required arguments to the C create method, without relations"""
      char: str
      v_char: str
      text: str
      bit: str
      v_bit: str
      uuid: str
  
  
  class CCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'CCreateWithoutRelationsInput'
      connect: 'CWhereUniqueInput'
  
  
  class CCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['CCreateWithoutRelationsInput', List['CCreateWithoutRelationsInput']]
      connect: Union['CWhereUniqueInput', List['CWhereUniqueInput']]
  
  
  class CWhereUniqueInput(TypedDict, total=False):
      """Unique C arguments for searching"""
      id: str
  
  
  class CUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      char: str
      v_char: str
      text: str
      bit: str
      v_bit: str
      uuid: str
  
  
  class CUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: str
      char: str
      v_char: str
      text: str
      bit: str
      v_bit: str
      uuid: str
  
  
  class CUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['CCreateWithoutRelationsInput']
      connect: List['CWhereUniqueInput']
      set: List['CWhereUniqueInput']
      disconnect: List['CWhereUniqueInput']
      delete: List['CWhereUniqueInput']
  
      # TODO
      # update: List['CUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['CUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['CScalarWhereInput']
      # upsert: List['CUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['CCreateOrConnectWithoutRelationsInput']
  
  
  class CUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'CCreateWithoutRelationsInput'
      connect: 'CWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'CUpdateInput'
      # upsert: 'CUpsertWithoutRelationsInput'
      # connectOrCreate: 'CCreateOrConnectWithoutRelationsInput'
  
  
  class CUpsertInput(TypedDict):
      create: 'CCreateInput'
      update: 'CUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class COrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      char: 'SortOrder'
      v_char: 'SortOrder'
      text: 'SortOrder'
      bit: 'SortOrder'
      v_bit: 'SortOrder'
      uuid: 'SortOrder'
  
  
  # recursive C types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/latest/limitations/
  
  CRelationFilter = TypedDict(
      'CRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class CListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class CInclude(TypedDict, total=False):
      """C relational arguments"""
  
  
      
  
  class PostIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
      author: Union[bool, 'UserArgsFromCRecursive1']
  
  
  class PostIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
      author: Union[bool, 'UserArgsFromCRecursive2']
  
  
  class PostIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class PostArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyPostArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
      posts: Union[bool, 'FindManyPostArgsFromCRecursive1']
  
  
  class UserIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
      posts: Union[bool, 'FindManyPostArgsFromCRecursive2']
  
  
  class UserIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class UserArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyUserArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
      n: Union[bool, 'FindManyNArgsFromCRecursive1']
  
  
  class MIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
      n: Union[bool, 'FindManyNArgsFromCRecursive2']
  
  
  class MIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class MArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyMArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
      m: Union[bool, 'FindManyMArgsFromCRecursive1']
  
  
  class NIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
      m: Union[bool, 'FindManyMArgsFromCRecursive2']
  
  
  class NIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class NArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyNArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
      many: Union[bool, 'FindManyManyRequiredArgsFromCRecursive1']
  
  
  class OneOptionalIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
      many: Union[bool, 'FindManyManyRequiredArgsFromCRecursive2']
  
  
  class OneOptionalIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class OneOptionalArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyOneOptionalArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
      one: Union[bool, 'OneOptionalArgsFromCRecursive1']
  
  
  class ManyRequiredIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
      one: Union[bool, 'OneOptionalArgsFromCRecursive2']
  
  
  class ManyRequiredIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class ManyRequiredArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyManyRequiredArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class AIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class AIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class AIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class AArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyAArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class BIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class BIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class BArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyBArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class CIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class CIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class CArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyCArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class DIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class DIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class DArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyDArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class EIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class EIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class EArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyEArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyCArgs = FindManyCArgsFromC
  FindFirstCArgs = FindManyCArgsFromC
  
  
      
  
  class CWhereInput(TypedDict, total=False):
      """C arguments for searching"""
      id: Union[str, 'types.StringFilter']
      char: Union[str, 'types.StringFilter']
      v_char: Union[str, 'types.StringFilter']
      text: Union[str, 'types.StringFilter']
      bit: Union[str, 'types.StringFilter']
      v_bit: Union[str, 'types.StringFilter']
      uuid: Union[str, 'types.StringFilter']
  
      # should be noted that AND and NOT should be Union['CWhereInputRecursive1', List['CWhereInputRecursive1']]
      # but this causes mypy to hang \_()_/
      AND: List['CWhereInputRecursive1']
      OR: List['CWhereInputRecursive1']
      NOT: List['CWhereInputRecursive1']
  
  
  class CWhereInputRecursive1(TypedDict, total=False):
      """C arguments for searching"""
      id: Union[str, 'types.StringFilter']
      char: Union[str, 'types.StringFilter']
      v_char: Union[str, 'types.StringFilter']
      text: Union[str, 'types.StringFilter']
      bit: Union[str, 'types.StringFilter']
      v_bit: Union[str, 'types.StringFilter']
      uuid: Union[str, 'types.StringFilter']
  
      # should be noted that AND and NOT should be Union['CWhereInputRecursive2', List['CWhereInputRecursive2']]
      # but this causes mypy to hang \_()_/
      AND: List['CWhereInputRecursive2']
      OR: List['CWhereInputRecursive2']
      NOT: List['CWhereInputRecursive2']
  
  
  class CWhereInputRecursive2(TypedDict, total=False):
      """C arguments for searching"""
      id: Union[str, 'types.StringFilter']
      char: Union[str, 'types.StringFilter']
      v_char: Union[str, 'types.StringFilter']
      text: Union[str, 'types.StringFilter']
      bit: Union[str, 'types.StringFilter']
      v_bit: Union[str, 'types.StringFilter']
      uuid: Union[str, 'types.StringFilter']
  
  
  
  CKeys = Literal[
      'id',
      'char',
      'v_char',
      'text',
      'bit',
      'v_bit',
      'uuid',
  ]
  
  CRelationalFieldKeys = _NoneType
  
  # D types
  
  class DOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the D create method"""
      id: str
  
  
  class DCreateInput(DOptionalCreateInput):
      """Required arguments to the D create method"""
      bool: bool
      xml: str
      json_: 'fields.Json'
      jsonb: 'fields.Json'
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class DOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the D create method, without relations"""
      id: str
  
  
  class DCreateWithoutRelationsInput(DOptionalCreateWithoutRelationsInput):
      """Required arguments to the D create method, without relations"""
      bool: bool
      xml: str
      json_: 'fields.Json'
      jsonb: 'fields.Json'
  
  
  class DCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'DCreateWithoutRelationsInput'
      connect: 'DWhereUniqueInput'
  
  
  class DCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['DCreateWithoutRelationsInput', List['DCreateWithoutRelationsInput']]
      connect: Union['DWhereUniqueInput', List['DWhereUniqueInput']]
  
  
  class DWhereUniqueInput(TypedDict, total=False):
      """Unique D arguments for searching"""
      id: str
  
  
  class DUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      bool: bool
      xml: str
      json_: 'fields.Json'
      jsonb: 'fields.Json'
  
  
  class DUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: str
      bool: bool
      xml: str
      json_: 'fields.Json'
      jsonb: 'fields.Json'
  
  
  class DUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['DCreateWithoutRelationsInput']
      connect: List['DWhereUniqueInput']
      set: List['DWhereUniqueInput']
      disconnect: List['DWhereUniqueInput']
      delete: List['DWhereUniqueInput']
  
      # TODO
      # update: List['DUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['DUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['DScalarWhereInput']
      # upsert: List['DUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['DCreateOrConnectWithoutRelationsInput']
  
  
  class DUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'DCreateWithoutRelationsInput'
      connect: 'DWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'DUpdateInput'
      # upsert: 'DUpsertWithoutRelationsInput'
      # connectOrCreate: 'DCreateOrConnectWithoutRelationsInput'
  
  
  class DUpsertInput(TypedDict):
      create: 'DCreateInput'
      update: 'DUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class DOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      bool: 'SortOrder'
      xml: 'SortOrder'
      json_: 'SortOrder'
      jsonb: 'SortOrder'
  
  
  # recursive D types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/latest/limitations/
  
  DRelationFilter = TypedDict(
      'DRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class DListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class DInclude(TypedDict, total=False):
      """D relational arguments"""
  
  
      
  
  class PostIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
      author: Union[bool, 'UserArgsFromDRecursive1']
  
  
  class PostIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
      author: Union[bool, 'UserArgsFromDRecursive2']
  
  
  class PostIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class PostArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyPostArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
      posts: Union[bool, 'FindManyPostArgsFromDRecursive1']
  
  
  class UserIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
      posts: Union[bool, 'FindManyPostArgsFromDRecursive2']
  
  
  class UserIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class UserArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyUserArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
      n: Union[bool, 'FindManyNArgsFromDRecursive1']
  
  
  class MIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
      n: Union[bool, 'FindManyNArgsFromDRecursive2']
  
  
  class MIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class MArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyMArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
      m: Union[bool, 'FindManyMArgsFromDRecursive1']
  
  
  class NIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
      m: Union[bool, 'FindManyMArgsFromDRecursive2']
  
  
  class NIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class NArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyNArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
      many: Union[bool, 'FindManyManyRequiredArgsFromDRecursive1']
  
  
  class OneOptionalIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
      many: Union[bool, 'FindManyManyRequiredArgsFromDRecursive2']
  
  
  class OneOptionalIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class OneOptionalArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyOneOptionalArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
      one: Union[bool, 'OneOptionalArgsFromDRecursive1']
  
  
  class ManyRequiredIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
      one: Union[bool, 'OneOptionalArgsFromDRecursive2']
  
  
  class ManyRequiredIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class ManyRequiredArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyManyRequiredArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class AIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class AIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class AIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class AArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyAArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class BIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class BIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class BArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyBArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class CIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class CIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class CArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyCArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class DIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class DIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class DArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyDArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class EIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class EIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class EArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyEArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyDArgs = FindManyDArgsFromD
  FindFirstDArgs = FindManyDArgsFromD
  
  
      
  
  class DWhereInput(TypedDict, total=False):
      """D arguments for searching"""
      id: Union[str, 'types.StringFilter']
      bool: Union[bool, 'types.BooleanFilter']
      xml: Union[str, 'types.StringFilter']
      json_: Union['fields.Json', 'types.JsonFilter']
      jsonb: Union['fields.Json', 'types.JsonFilter']
  
      # should be noted that AND and NOT should be Union['DWhereInputRecursive1', List['DWhereInputRecursive1']]
      # but this causes mypy to hang \_()_/
      AND: List['DWhereInputRecursive1']
      OR: List['DWhereInputRecursive1']
      NOT: List['DWhereInputRecursive1']
  
  
  class DWhereInputRecursive1(TypedDict, total=False):
      """D arguments for searching"""
      id: Union[str, 'types.StringFilter']
      bool: Union[bool, 'types.BooleanFilter']
      xml: Union[str, 'types.StringFilter']
      json_: Union['fields.Json', 'types.JsonFilter']
      jsonb: Union['fields.Json', 'types.JsonFilter']
  
      # should be noted that AND and NOT should be Union['DWhereInputRecursive2', List['DWhereInputRecursive2']]
      # but this causes mypy to hang \_()_/
      AND: List['DWhereInputRecursive2']
      OR: List['DWhereInputRecursive2']
      NOT: List['DWhereInputRecursive2']
  
  
  class DWhereInputRecursive2(TypedDict, total=False):
      """D arguments for searching"""
      id: Union[str, 'types.StringFilter']
      bool: Union[bool, 'types.BooleanFilter']
      xml: Union[str, 'types.StringFilter']
      json_: Union['fields.Json', 'types.JsonFilter']
      jsonb: Union['fields.Json', 'types.JsonFilter']
  
  
  
  DKeys = Literal[
      'id',
      'bool',
      'xml',
      'json_',
      'jsonb',
  ]
  
  DRelationalFieldKeys = _NoneType
  
  # E types
  
  class EOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the E create method"""
      id: str
  
  
  class ECreateInput(EOptionalCreateInput):
      """Required arguments to the E create method"""
      date: datetime.datetime
      time: datetime.datetime
      ts: datetime.datetime
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class EOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the E create method, without relations"""
      id: str
  
  
  class ECreateWithoutRelationsInput(EOptionalCreateWithoutRelationsInput):
      """Required arguments to the E create method, without relations"""
      date: datetime.datetime
      time: datetime.datetime
      ts: datetime.datetime
  
  
  class ECreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'ECreateWithoutRelationsInput'
      connect: 'EWhereUniqueInput'
  
  
  class ECreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['ECreateWithoutRelationsInput', List['ECreateWithoutRelationsInput']]
      connect: Union['EWhereUniqueInput', List['EWhereUniqueInput']]
  
  
  class EWhereUniqueInput(TypedDict, total=False):
      """Unique E arguments for searching"""
      id: str
  
  
  class EUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      date: datetime.datetime
      time: datetime.datetime
      ts: datetime.datetime
  
  
  class EUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: str
      date: datetime.datetime
      time: datetime.datetime
      ts: datetime.datetime
  
  
  class EUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['ECreateWithoutRelationsInput']
      connect: List['EWhereUniqueInput']
      set: List['EWhereUniqueInput']
      disconnect: List['EWhereUniqueInput']
      delete: List['EWhereUniqueInput']
  
      # TODO
      # update: List['EUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['EUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['EScalarWhereInput']
      # upsert: List['EUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['ECreateOrConnectWithoutRelationsInput']
  
  
  class EUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'ECreateWithoutRelationsInput'
      connect: 'EWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'EUpdateInput'
      # upsert: 'EUpsertWithoutRelationsInput'
      # connectOrCreate: 'ECreateOrConnectWithoutRelationsInput'
  
  
  class EUpsertInput(TypedDict):
      create: 'ECreateInput'
      update: 'EUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class EOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      date: 'SortOrder'
      time: 'SortOrder'
      ts: 'SortOrder'
  
  
  # recursive E types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/latest/limitations/
  
  ERelationFilter = TypedDict(
      'ERelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class EListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class EInclude(TypedDict, total=False):
      """E relational arguments"""
  
  
      
  
  class PostIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
      author: Union[bool, 'UserArgsFromERecursive1']
  
  
  class PostIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
      author: Union[bool, 'UserArgsFromERecursive2']
  
  
  class PostIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class PostArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyPostArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
      posts: Union[bool, 'FindManyPostArgsFromERecursive1']
  
  
  class UserIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
      posts: Union[bool, 'FindManyPostArgsFromERecursive2']
  
  
  class UserIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class UserArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyUserArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
      n: Union[bool, 'FindManyNArgsFromERecursive1']
  
  
  class MIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
      n: Union[bool, 'FindManyNArgsFromERecursive2']
  
  
  class MIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class MArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyMArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
      m: Union[bool, 'FindManyMArgsFromERecursive1']
  
  
  class NIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
      m: Union[bool, 'FindManyMArgsFromERecursive2']
  
  
  class NIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class NArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyNArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
      many: Union[bool, 'FindManyManyRequiredArgsFromERecursive1']
  
  
  class OneOptionalIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
      many: Union[bool, 'FindManyManyRequiredArgsFromERecursive2']
  
  
  class OneOptionalIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class OneOptionalArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyOneOptionalArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
      one: Union[bool, 'OneOptionalArgsFromERecursive1']
  
  
  class ManyRequiredIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
      one: Union[bool, 'OneOptionalArgsFromERecursive2']
  
  
  class ManyRequiredIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class ManyRequiredArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyManyRequiredArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class AIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class AIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class AIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class AArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyAArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class BIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class BIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class BArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyBArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class CIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class CIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class CArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyCArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class DIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class DIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class DArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyDArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class EIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class EIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class EArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyEArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyEArgs = FindManyEArgsFromE
  FindFirstEArgs = FindManyEArgsFromE
  
  
      
  
  class EWhereInput(TypedDict, total=False):
      """E arguments for searching"""
      id: Union[str, 'types.StringFilter']
      date: Union[datetime.datetime, 'types.DateTimeFilter']
      time: Union[datetime.datetime, 'types.DateTimeFilter']
      ts: Union[datetime.datetime, 'types.DateTimeFilter']
  
      # should be noted that AND and NOT should be Union['EWhereInputRecursive1', List['EWhereInputRecursive1']]
      # but this causes mypy to hang \_()_/
      AND: List['EWhereInputRecursive1']
      OR: List['EWhereInputRecursive1']
      NOT: List['EWhereInputRecursive1']
  
  
  class EWhereInputRecursive1(TypedDict, total=False):
      """E arguments for searching"""
      id: Union[str, 'types.StringFilter']
      date: Union[datetime.datetime, 'types.DateTimeFilter']
      time: Union[datetime.datetime, 'types.DateTimeFilter']
      ts: Union[datetime.datetime, 'types.DateTimeFilter']
  
      # should be noted that AND and NOT should be Union['EWhereInputRecursive2', List['EWhereInputRecursive2']]
      # but this causes mypy to hang \_()_/
      AND: List['EWhereInputRecursive2']
      OR: List['EWhereInputRecursive2']
      NOT: List['EWhereInputRecursive2']
  
  
  class EWhereInputRecursive2(TypedDict, total=False):
      """E arguments for searching"""
      id: Union[str, 'types.StringFilter']
      date: Union[datetime.datetime, 'types.DateTimeFilter']
      time: Union[datetime.datetime, 'types.DateTimeFilter']
      ts: Union[datetime.datetime, 'types.DateTimeFilter']
  
  
  
  EKeys = Literal[
      'id',
      'date',
      'time',
      'ts',
  ]
  
  ERelationalFieldKeys = _NoneType
  
  
  
  # we have to import ourselves as types can be namespaced to types
  from . import types, enums, models, fields
  '
---
# name: test_sync[builder.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  
  if sys.version_info >= (3, 8):
      from typing import TypedDict, Literal
  else:
      from typing_extensions import TypedDict, Literal
  
  # -- template builder.py.jinja --
  
  # TODO: the QueryBuilder should validate and add type information context.
  #       currently we just naively iterate through arguments and encode them
  #       using standard json when we don't have any special casing for it.
  #       this makes it more difficult to add support for non-standard types
  #       such as the `Json` type.
  # TODO: optimise for performance (switch to c / cython?)
  # TODO: pass context around differently, relying on the builder instance is
  #       not ideal, context should be local to each node
  
  
  import json
  import logging
  import inspect
  from textwrap import indent
  from datetime import timezone
  from abc import abstractmethod, ABC
  from functools import singledispatch
  
  from . import fields
  from .types import Serializable
  from .errors import UnknownModelError, UnknownRelationalFieldError
  
  
  log: logging.Logger = logging.getLogger(__name__)
  
  ChildType = Union['AbstractNode', str]
  
  
  GLOBAL_ALIASES: Dict[str, str] = {
      'startswith': 'startsWith',
      'endswith': 'endsWith',
      'order_by': 'orderBy',
      'not_in': 'notIn',
      'is_not': 'isNot',
  }
  
  DEFAULT_FIELDS_MAPPING: Dict[str, List[str]] = {
      'Post': [
          'id',
          'created_at',
          'title',
          'content',
          'published',
          'author_id',
      ],
      'User': [
          'id',
          'email',
          'int',
          'optional_int',
          'float',
          'optional_float',
          'string',
          'optional_string',
          'enum',
          'optional_enum',
          'boolean',
          'optional_boolean',
      ],
      'M': [
          'id',
          'int',
          'optional_int',
          'float',
          'optional_float',
          'string',
          'optional_string',
          'enum',
          'optional_enum',
          'boolean',
          'optional_boolean',
      ],
      'N': [
          'id',
          'int',
          'optional_int',
          'float',
          'optional_float',
          'string',
          'optional_string',
          'json_',
          'optional_json',
          'enum',
          'optional_enum',
          'boolean',
          'optional_boolean',
      ],
      'OneOptional': [
          'id',
          'int',
          'optional_int',
          'float',
          'optional_float',
          'string',
          'optional_string',
          'enum',
          'optional_enum',
          'boolean',
          'optional_boolean',
      ],
      'ManyRequired': [
          'id',
          'one_optional_id',
          'int',
          'optional_int',
          'float',
          'optional_float',
          'string',
          'optional_string',
          'enum',
          'optional_enum',
          'boolean',
          'optional_boolean',
      ],
      'A': [
          'id',
          'email',
          'name',
          'int',
          'sInt',
          'inc_int',
          'inc_sInt',
          'bInt',
          'inc_bInt',
      ],
      'B': [
          'id',
          'float',
          'd_float',
      ],
      'C': [
          'id',
          'char',
          'v_char',
          'text',
          'bit',
          'v_bit',
          'uuid',
      ],
      'D': [
          'id',
          'bool',
          'xml',
          'json_',
          'jsonb',
      ],
      'E': [
          'id',
          'date',
          'time',
          'ts',
      ],
  }
  
  RELATIONAL_FIELD_MAPPINGS: Dict[str, Dict[str, str]] = {
      'Post': {
          'author': 'User',
      },
      'User': {
          'posts': 'Post',
      },
      'M': {
          'n': 'N',
      },
      'N': {
          'm': 'M',
      },
      'OneOptional': {
          'many': 'ManyRequired',
      },
      'ManyRequired': {
          'one': 'OneOptional',
      },
      'A': {
      },
      'B': {
      },
      'C': {
      },
      'D': {
      },
      'E': {
      },
  }
  
  
  class QueryBuilder:
      # prisma method
      method: str
  
      # GraphQL operation
      operation: str
  
      # prisma model
      model: Optional[str]
  
      # mapping of relational fields to include in the result
      include: Optional[Dict[str, Any]]
  
      # arguments to pass to the query
      arguments: Dict[str, Any]
  
      # list of fields to select
      root_selection: Optional[List[str]]
  
      def __init__(
          self,
          *,
          method: str,
          operation: str,
          arguments: Dict[str, Any],
          model: Optional[str] = None,
          root_selection: Optional[List[str]] = None
      ) -> None:
          self.model = model
          self.method = method
          self.operation = operation
          self.root_selection = root_selection
          self.arguments = args = self._transform_aliases(arguments)
          self.include = args.pop('include', None)
  
      def build(self) -> str:
          """Build the payload that should be sent to the QueryEngine"""
          data = {
              'variables': {},
              'operation_name': self.operation,
              'query': self.build_query(),
          }
          return dumps(data)
  
      def build_query(self) -> str:
          """Build the GraphQL query
  
          Example query:
  
          query {
            result: findUniqueUser
            (
              where: {
                id: "ckq23ky3003510r8zll5m2hma"
              }
            )
            {
              id
              name
              profile {
                id
                user_id
                bio
              }
            }
          }
          """
          query = self._create_root_node().render()
          log.debug('Generated query: \n%s', query)
          return query
  
      def _create_root_node(self) -> 'RootNode':
          root = RootNode(builder=self)
          root.add(ResultNode.create(self))
          root.add(
              Selection.create(
                  self,
                  model=self.model,
                  include=self.include,
                  root_selection=self.root_selection,
              )
          )
          return root
  
      def get_default_fields(self, model: str) -> List[str]:
          """Returns a list of all the scalar fields of a model
  
          Raises UnknownModelError if the current model cannot be found.
          """
          try:
              return DEFAULT_FIELDS_MAPPING[model].copy()
          except KeyError as exc:
              raise UnknownModelError(model) from exc
  
      def get_relational_model(self, current_model: str, field: str) -> str:
          """Returns the model that the field is related to.
  
          Raises UnknownModelError if the current model is invalid.
          Raises UnknownRelationalFieldError if the field does not exist.
          """
          try:
              mappings = RELATIONAL_FIELD_MAPPINGS[current_model]
          except KeyError as exc:
              raise UnknownModelError(current_model) from exc
  
          try:
              return mappings[field]
          except KeyError as exc:
              raise UnknownRelationalFieldError(model=current_model, field=field) from exc
  
      def _transform_aliases(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
          """Transform dict keys to match global aliases
  
          e.g. order_by -> orderBy
          """
          transformed = dict()
          for key, value in arguments.items():
              alias = GLOBAL_ALIASES.get(key, key)
              if isinstance(value, dict):
                  transformed[alias] = self._transform_aliases(arguments=value)
              else:
                  transformed[alias] = value
          return transformed
  
  
  class AbstractNode(ABC):
      @abstractmethod
      def render(self) -> Optional[str]:
          """Render the node to a string
  
          None is returned if the node should not be rendered.
          """
          ...
  
      def should_render(self) -> bool:
          """If True, rendering of the node is skipped
  
          Useful for some nodes as they should only actually
          be rendered if they have any children.
          """
          return True
  
  
  class Node(AbstractNode):
      """Base node handling rendering of child nodes"""
      joiner: str
      indent: str
      builder: QueryBuilder
      children: List[ChildType]
  
      def __init__(
          self,
          builder: QueryBuilder,
          *,
          joiner: str = '\n',
          indent: str = '  ',
          children: Optional[List[ChildType]] = None
      ) -> None:
          self.builder = builder
          self.joiner = joiner
          self.indent = indent
          self.children = children if children is not None else []
  
      def enter(self) -> Optional[str]:
          """Get the string used to enter the node.
  
          This string will be rendered *before* the children.
          """
          return None
  
      def depart(self) -> Optional[str]:
          """Get the string used to depart the node.
  
          This string will be rendered *after* the children.
          """
          return None
  
      def render(self) -> Optional[str]:
          """Render the node and it's children and to string.
  
          Rendering a node involves 4 steps:
  
          1. Entering the node
          2. Rendering it's children
          3. Departing the node
          4. Joining the previous steps together into a single string
          """
          if not self.should_render():
              return None
  
          strings: List[str] = []
          entered = self.enter()
          if entered is not None:
              strings.append(entered)
  
          for child in self.children:
              content: Optional[str] = None
  
              if isinstance(child, str):
                  content = child
              else:
                  content = child.render()
  
              if content:
                  strings.append(indent(content, self.indent))
  
          departed = self.depart()
          if departed is not None:
              strings.append(departed)
  
          return self.joiner.join(strings)
  
      def add(self, child: ChildType) -> None:
          """Add a child"""
          self.children.append(child)
  
      def create_children(self) -> List[ChildType]:
          """Create the node's children
  
          If children are passed to the constructor, the children
          returned from this method are used to extend the already
          set children.
          """
          return []
  
      @classmethod
      def create(cls, builder: Optional[QueryBuilder] = None, **kwargs: Any) -> 'Node':
          """Create the node and its children
  
          This is useful for subclasses that add extra attributes in __init__
          """
          kwargs.setdefault('builder', builder)
          node = cls(**kwargs)
          node.children.extend(node.create_children())
          return node
  
  
  class RootNode(Node):
      """Rendered node examples:
  
      query {
          <children>
      }
  
      or
  
      mutation {
          <children>
      }
      """
  
      def enter(self) -> str:
          return f'{self.builder.operation} {{'
  
      def depart(self) -> str:
          return '}'
  
      def render(self) -> str:
          content = super().render()
          if not content:  # pragma: no cover
              # this should never happen.
              # render() is typed to return None if the node
              # should not be rendered but as this node will
              # always be rendered it should always return
              # a non-empty string.
              raise RuntimeError('Could not generate query.')
          return content
  
  
  class ResultNode(Node):
      """Rendered node examples:
  
      result: findUniqueUser
          <children>
  
      or
  
      result: executeRaw
          <children>
      """
      def __init__(self, indent: str = '', **kwargs: Any) -> None:
          super().__init__(indent=indent, **kwargs)
  
      def enter(self) -> str:
          model = self.builder.model
          if model is not None:
              return f'result: {self.builder.method}{model}'
  
          return f'result: {self.builder.method}'
  
      def depart(self) -> Optional[str]:
          return None
  
      def create_children(self) -> List[ChildType]:
          return [
              Arguments.create(
                  self.builder,
                  arguments=self.builder.arguments,
              )
          ]
  
  
  class Arguments(Node):
      """Rendered node example:
  
      (
          key1: "1"
          key2: "[\"John\",\"123\"]"
          key3: true
          key4: {
              data: true
          }
      )
      """
      arguments: Dict[str, Any]
  
      def __init__(self, arguments: Dict[str, Any], **kwargs: Any) -> None:
          super().__init__(**kwargs)
          self.arguments = arguments
  
      def should_render(self) -> bool:
          return bool(self.children)
  
      def enter(self) -> str:
          return '('
  
      def depart(self) -> str:
          return ')'
  
      def create_children(self, arguments: Optional[Dict[str, Any]] = None) -> List[ChildType]:
          children: List[ChildType] = []
  
          for arg, value in self.arguments.items():
              if value is None:
                  # ignore None values for convenience
                  continue
  
              if isinstance(value, dict):
                  children.append(
                      Key(arg, node=Data.create(self.builder, data=value))
                  )
              elif isinstance(value, (list, tuple, set)):
                  # NOTE: we have a special case for execute_raw and query_raw
                  # here as prisma expects parameters to be passed as a json string
                  # value like "[\"John\",\"123\"]", and we encode twice to ensure
                  # that only the inner quotes are escaped
                  if self.builder.method in {'queryRaw', 'executeRaw'}:
                      children.append(f'{arg}: {dumps(dumps(value))}')
                  else:
                      children.append(Key(arg, node=ListNode.create(self.builder, data=value)))
              else:
                  children.append(f'{arg}: {dumps(value)}')
  
          return children
  
  
  class Data(Node):
      """Rendered node example:
  
      {
          key1: "a"
          key2: 3
          key3: [
              "name"
          ]
      }
      """
      data: Mapping[str, Any]
  
      def __init__(
          self,
          data: Mapping[str, Any],
          **kwargs: Any
      ) -> None:
          super().__init__(**kwargs)
          self.data = data
  
      def enter(self) -> str:
          return '{'
  
      def depart(self) -> str:
          return '}'
  
      def create_children(self) -> List[ChildType]:
          children: List[ChildType] = []
  
          for key, value in self.data.items():
              if isinstance(value, dict):
                  children.append(
                      Key(key, node=Data.create(self.builder, data=value))
                  )
              elif isinstance(value, (list, tuple, set)):
                  children.append(
                      Key(key, node=ListNode.create(self.builder, data=value))
                  )
              else:
                  children.append(f'{key}: {dumps(value)}')
  
          return children
  
  
  class ListNode(Node):
      data: Iterable[Any]
  
      def __init__(self, data: Iterable[Any], joiner: str = ',\n', **kwargs: Any) -> None:
          super().__init__(joiner=joiner, **kwargs)
          self.data = data
  
      def enter(self) -> str:
          return '['
  
      def depart(self) -> str:
          return ']'
  
      def create_children(self) -> List[ChildType]:
          children: List[ChildType] = []
  
          for item in self.data:
              if isinstance(item, dict):
                  children.append(Data.create(self.builder, data=item))
              else:
                  children.append(dumps(item))
  
          return children
  
  
  class Selection(Node):
      """Represents field selections
  
      Example no include:
  
      {
          id
          name
      }
  
      Example include={'posts': True}
  
      {
          id
          name
          posts {
              id
              title
          }
      }
  
      Example include={'posts': {'where': {'title': {'contains': 'Test'}}}}
  
      {
          id
          name
          posts(
              where: {
                  title: {
                      contains: 'Test'
                  }
              }
          )
          {
              id
              title
          }
      }
      """
      model: Optional[str]
      include: Optional[Dict[str, Any]]
      root_selection: Optional[List[str]]
  
      def __init__(
          self,
          model: Optional[str] = None,
          include: Optional[Dict[str, Any]] = None,
          root_selection: Optional[List[str]] = None,
          **kwargs: Any
      ) -> None:
          super().__init__(**kwargs)
          self.model = model
          self.include = include
          self.root_selection = root_selection
  
      def should_render(self) -> bool:
          return bool(self.children)
  
      def enter(self) -> str:
          return '{'
  
      def depart(self) -> str:
          return '}'
  
      def create_children(self) -> List[ChildType]:
          model = self.model
          include = self.include
          builder = self.builder
          children: List[ChildType] = []
  
          # root_selection, if present overrides the default fields
          # for a model as it is used by methods such as count()
          # that do not support returning model fields
          root_selection = self.root_selection
          if root_selection is not None:
              children.extend(root_selection)
          elif model is not None:
              children.extend(builder.get_default_fields(model))
  
          if include is not None:
              if model is None:
                  raise ValueError('Cannot include fields when model is None.')
  
              for key, value in include.items():
                  if value is True:
                      # e.g. posts { post_fields }
                      children.append(
                          Key(
                              key,
                              sep=' ',
                              node=Selection.create(
                                  builder,
                                  include=None,
                                  model=builder.get_relational_model(
                                      current_model=model, field=key
                                  ),
                              ),
                          )
                      )
                  elif isinstance(value, dict):
                      # e.g. given {'posts': {where': {'published': True}}} return
                      # posts( where: { published: true }) { post_fields }
                      args = value.copy()
                      nested_include = args.pop('include', None)
                      children.extend(
                          [
                              Key(
                                  key,
                                  sep='',
                                  node=Arguments.create(
                                      builder, arguments=args
                                  ),
                              ),
                              Selection.create(
                                  builder,
                                  include=nested_include,
                                  model=builder.get_relational_model(
                                      current_model=model, field=key
                                  ),
                              ),
                          ]
                      )
                  elif value is False:
                      continue
                  else:
                      raise TypeError(
                          f'Expected `bool` or `dict` include value but got {type(value)} instead.'
                      )
  
          return children
  
  
  class Key(AbstractNode):
      """Node for rendering a child node with a prefixed key"""
      key: str
      sep: str
      node: Node
  
      def __init__(self, key: str, node: Node, sep: str = ': ') -> None:
          self.key = key
          self.node = node
          self.sep = sep
  
      def render(self) -> str:
          content = self.node.render()
          if content:
              return f'{self.key}{self.sep}{content}'
          return f'{self.key}{self.sep}'
  
  
  @singledispatch
  def serializer(obj: Any) -> Serializable:
      """Single dispatch generic function for serializing objects to JSON"""
      if inspect.isclass(obj):
          typ = obj
      else:
          typ = type(obj)
  
      raise TypeError(f'Type {typ} not serializable')
  
  
  @serializer.register(datetime.datetime)
  def serialize_datetime(dt: datetime.datetime) -> str:
      """Format a datetime object to an ISO8601 string with a timezone.
  
      This assumes naive datetime objects are in UTC.
      """
      if dt.tzinfo is None:
          dt = dt.replace(tzinfo=timezone.utc)
      elif dt.tzinfo != timezone.utc:
          dt = dt.astimezone(timezone.utc)
  
      return dt.isoformat()
  
  
  @serializer.register(fields.Json)
  def serialize_json(obj: fields.Json) -> str:
      """Serialize a Json wrapper to a json string.
  
      This is used as a hook to override our default behaviour when building
      queries which would treat data like {'hello': 'world'} as a Data node
      when we instead want it to be rendered as a raw json string.
  
      This should only be used for fields that are of the `Json` type.
      """
      return dumps(obj.data)
  
  
  def dumps(obj: Any, **kwargs: Any) -> str:
      kwargs.setdefault('default', serializer)
      kwargs.setdefault('ensure_ascii', False)
      return json.dumps(obj, **kwargs)
  
  # black does not respect the fmt: off comment without this
  # fmt: on
  
  '
---
# name: test_sync[client.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  
  if sys.version_info >= (3, 8):
      from typing import TypedDict, Literal
  else:
      from typing_extensions import TypedDict, Literal
  
  # -- template client.py.jinja --
  from types import TracebackType
  from collections import defaultdict
  from pydantic import BaseModel, validate_arguments
  
  from . import types, models, errors
  from ._types import BaseModelT
  from .engine import QueryEngine
  from .builder import QueryBuilder
  
  
  __all__ = (
      'Client',
      'load_env',
  )
  
  SCHEMA = '''
  // NOTE: modified from https://github.com/prisma/prisma/blob/master/src/packages/client/src/__tests__/integration/happy/exhaustive-schema/schema.prisma
  
  datasource db {
    provider = "postgresql"
    url      = env("DB_URL")
  }
  
  generator db {
    provider             = "prisma-client-py"
    interface            = "sync"
    recursive_type_depth = 3
    output               = "../../../.tests_cache/generation/exhaustive/__prisma_sync_output__/prisma"
  }
  
  model Post {
    id         Int      @id @default(autoincrement())
    created_at DateTime @default(now())
    title      String
    content    String?
    published  Boolean  @default(false)
    author     User     @relation(fields: [author_id], references: [id])
    author_id  Int
  }
  
  model User {
    id               Int             @id @default(autoincrement())
    email            String          @unique
    int              Int
    optional_int     Int?
    float            Float
    optional_float   Float?
    string           String
    optional_string  String?
    enum             ABeautifulEnum
    optional_enum    ABeautifulEnum?
    boolean          Boolean
    optional_boolean Boolean?
    posts            Post[]
  }
  
  model M {
    id               Int             @id @default(autoincrement())
    n                N[]
    int              Int
    optional_int     Int?
    float            Float
    optional_float   Float?
    string           String
    optional_string  String?
    enum             ABeautifulEnum
    optional_enum    ABeautifulEnum?
    boolean          Boolean
    optional_boolean Boolean?
  }
  
  model N {
    id               Int             @id @default(autoincrement())
    m                M[]
    int              Int
    optional_int     Int?
    float            Float
    optional_float   Float?
    string           String
    optional_string  String?
    json_            Json
    optional_json    Json?
    enum             ABeautifulEnum
    optional_enum    ABeautifulEnum?
    boolean          Boolean
    optional_boolean Boolean?
  }
  
  model OneOptional {
    id               Int             @id @default(autoincrement())
    many             ManyRequired[]
    int              Int
    optional_int     Int?
    float            Float
    optional_float   Float?
    string           String
    optional_string  String?
    enum             ABeautifulEnum
    optional_enum    ABeautifulEnum?
    boolean          Boolean
    optional_boolean Boolean?
  }
  
  model ManyRequired {
    id  Int          @id @default(autoincrement())
    one OneOptional? @relation(fields: [one_optional_id], references: [id])
  
    one_optional_id  Int?
    int              Int
    optional_int     Int?
    float            Float
    optional_float   Float?
    string           String
    optional_string  String?
    enum             ABeautifulEnum
    optional_enum    ABeautifulEnum?
    boolean          Boolean
    optional_boolean Boolean?
  }
  
  enum ABeautifulEnum {
    A
    B
    C
  }
  
  model A {
    id       String  @id @default(uuid())
    email    String  @unique
    name     String?
    int      Int     @db.Integer
    sInt     Int     @db.SmallInt
    inc_int  Int     @default(autoincrement()) @db.Integer
    inc_sInt Int     @default(autoincrement()) @db.SmallInt
    bInt     BigInt  @db.BigInt
    inc_bInt BigInt  @default(autoincrement()) @db.BigInt
  }
  
  model B {
    id      String @id @default(cuid())
    float   Float  @db.Real
    d_float Float  @db.DoublePrecision
  
    // TODO
    // decFloat Decimal @db.Decimal(2, 1)
    // numFloat Decimal @db.Decimal(10, 6)
  }
  
  model C {
    id     String @id @default(cuid())
    char   String @db.Char(10)
    v_char String @db.VarChar(11)
    text   String @db.Text
    bit    String @db.Bit(4)
    v_bit  String @db.VarBit(5)
    uuid   String @db.Uuid
  }
  
  model D {
    id    String  @id @default(cuid())
    bool  Boolean @db.Boolean
    xml   String  @db.Xml
    json_ Json    @db.Json
    jsonb Json    @db.JsonB
  
    // TODO
    // byteA Bytes   @db.ByteA
  }
  
  model E {
    id   String   @id @default(cuid())
    date DateTime @db.Date
    time DateTime @db.Time(3)
    ts   DateTime @db.Timestamp(3)
  }
  
  '''
  
  
  def load_env(*, override: bool = True, **kwargs: Any) -> None:
      """Load environemntal variables from dotenv files
  
      Loads from the following files relative to the current
      working directory:
  
      - .env
      - prisma/.env
      """
      from dotenv import load_dotenv
  
      load_dotenv('.env', override=override, **kwargs)
      load_dotenv('prisma/.env', override=override, **kwargs)
  
  
  class Client:
      post: 'PostActions'
      user: 'UserActions'
      m: 'MActions'
      n: 'NActions'
      oneoptional: 'OneOptionalActions'
      manyrequired: 'ManyRequiredActions'
      a: 'AActions'
      b: 'BActions'
      c: 'CActions'
      d: 'DActions'
      e: 'EActions'
  
      def __init__(self, *, use_dotenv: bool = True, log_queries: bool = False) -> None:
          self.post = PostActions(self)
          self.user = UserActions(self)
          self.m = MActions(self)
          self.n = NActions(self)
          self.oneoptional = OneOptionalActions(self)
          self.manyrequired = ManyRequiredActions(self)
          self.a = AActions(self)
          self.b = BActions(self)
          self.c = CActions(self)
          self.d = DActions(self)
          self.e = EActions(self)
          self.__engine: Optional[QueryEngine] = None
          self._active_provider = 'postgresql'
          self._log_queries = log_queries
  
          if use_dotenv:
              load_env()
  
      def __del__(self) -> None:
          if self.__engine is not None:
              self.__engine.stop()
              self.__engine = None
  
      def is_connected(self) -> bool:
          """Returns True if the client is connected to the query engine, False otherwise."""
          return self.__engine is not None
  
      def connect(self, timeout: int = 10) -> None:
          """Connect to the Prisma query engine.
  
          It is required to call this before accessing data.
          """
          if self.__engine is None:
              self.__engine = QueryEngine(dml=SCHEMA, log_queries=self._log_queries)
  
          self.__engine.connect(timeout=timeout)
  
      def disconnect(self) -> None:
          """Disconnect the Prisma query engine."""
          if self.__engine is not None:
              self.__engine.disconnect()
              self.__engine.close_session()
              self.__engine = None
  
      def execute_raw(self, query: str, *args: Any) -> int:
          resp = self._execute(
              operation='mutation',
              method='executeRaw',
              arguments={
                  'query': query,
                  'parameters': args,
              }
          )
          return int(resp['data']['result'])
  
      @overload
      def query_first(self, query: str, *args: Any) -> Any:
          ...
  
      @overload
      def query_first(self, query: str, *args: Any, model: Type[BaseModelT]) -> Optional[BaseModelT]:
          ...
  
      def query_first(
          self, query: str, *args: Any, model: Optional[Type[BaseModelT]] = None
      ) -> Union[Optional[BaseModelT], Any]:
          if model is not None:
              results = self.query_raw(query, *args, model=model)
          else:
              results = self.query_raw(query, *args)
  
          if not results:
              return None
  
          return results[0]
  
      @overload
      def query_raw(self, query: str, *args: Any) -> Any:
          ...
  
      @overload
      def query_raw(self, query: str, *args: Any, model: Type[BaseModelT]) -> List[BaseModelT]:
          ...
  
      def query_raw(
          self, query: str, *args: Any, model: Optional[Type[BaseModelT]] = None
      ) -> Union[List[BaseModelT], Any]:
          resp = self._execute(
              operation='mutation',
              method='queryRaw',
              arguments={
                  'query': query,
                  'parameters': args,
              }
          )
          result = resp['data']['result']
          if model is not None:
              return [model.parse_obj(r) for r in result]
          return result
  
      def batch_(self) -> 'Batch':
          """Returns a context manager for grouping write queries into a single transaction."""
          return Batch(client=self)
  
      # TODO: don't return Any
      def _execute(
          self,
          method: str,
          operation: str,
          arguments: Dict[str, Any],
          model: Optional[str] = None,
          root_selection: Optional[List[str]] = None
      ) -> Any:
          builder = QueryBuilder(
              operation=operation,
              method=method,
              model=model,
              arguments=arguments,
              root_selection=root_selection,
          )
          return self._engine.request('POST', '/', content=builder.build())
  
      @property
      def _engine(self) -> QueryEngine:
          engine = self.__engine
          if engine is None:
              raise errors.ClientNotConnectedError()
          return engine
  
  
  # TODO: this should return the results as well
  # TODO: don't require copy-pasting arguments between actions and batch actions
  class Batch:
      post: 'PostBatchActions'
      user: 'UserBatchActions'
      m: 'MBatchActions'
      n: 'NBatchActions'
      oneoptional: 'OneOptionalBatchActions'
      manyrequired: 'ManyRequiredBatchActions'
      a: 'ABatchActions'
      b: 'BBatchActions'
      c: 'CBatchActions'
      d: 'DBatchActions'
      e: 'EBatchActions'
  
      def __init__(self, client: Client) -> None:
          self.__client = client
          self.__queries: List[str] = []
          self._active_provider = client._active_provider
          self.post = PostBatchActions(self)
          self.user = UserBatchActions(self)
          self.m = MBatchActions(self)
          self.n = NBatchActions(self)
          self.oneoptional = OneOptionalBatchActions(self)
          self.manyrequired = ManyRequiredBatchActions(self)
          self.a = ABatchActions(self)
          self.b = BBatchActions(self)
          self.c = CBatchActions(self)
          self.d = DBatchActions(self)
          self.e = EBatchActions(self)
  
      def _add(self, **kwargs: Any) -> None:
          builder = QueryBuilder(**kwargs)
          self.__queries.append(builder.build_query())
  
      def commit(self) -> None:
          """Execute the queries"""
          # TODO: normalise this, we should still call client._execute
          from .builder import dumps
  
          queries = self.__queries
          self.__queries = []
  
          payload = {
              'batch': [
                  {
                      'query': query,
                      'variables': {},
                  }
                  for query in queries
              ],
              'transaction': True,
          }
          self.__client._engine.request('POST', '/', content=dumps(payload))
  
      def __enter__(self) -> 'Batch':
          return self
  
      def __exit__(
          self,
          exc_type: Optional[Type[BaseException]],
          exc: Optional[BaseException],
          exc_tb: Optional[TracebackType],
      ) -> None:
          if exc is None:
              self.commit()
  
  
  class PostActions:
      def __init__(self, client: Client):
          self._client = client
  
      def create(
          self,
          data: types.PostCreateInput,
          include: Optional[types.PostInclude] = None
      ) -> models.Post:
          resp = self._client._execute(
              operation='mutation',
              method='createOne',
              model='Post',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return models.Post.parse_obj(resp['data']['result'])
  
      def create_many(
          self,
          data: List[types.PostCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = self._client._execute(
              operation='mutation',
              method='createMany',
              model='Post',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def delete(
          self,
          where: types.PostWhereUniqueInput,
          include: Optional[types.PostInclude] = None
      ) -> Optional[models.Post]:
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='Post',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.Post.parse_obj(resp['data']['result'])
  
      def find_unique(
          self,
          where: types.PostWhereUniqueInput,
          include: Optional[types.PostInclude] = None
      ) -> Optional[models.Post]:
          resp = self._client._execute(
              operation='query',
              method='findUnique',
              model='Post',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.Post.parse_obj(result)
  
      def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.PostWhereInput] = None,
          cursor: Optional[types.PostWhereUniqueInput] = None,
          include: Optional[types.PostInclude] = None,
          order: Optional[Union[types.PostOrderByInput, List[types.PostOrderByInput]]] = None,
      ) -> List[models.Post]:
          resp = self._client._execute(
              operation='query',
              method='findMany',
              model='Post',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [models.Post.parse_obj(r) for r in resp['data']['result']]
  
      def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.PostWhereInput] = None,
          cursor: Optional[types.PostWhereUniqueInput] = None,
          include: Optional[types.PostInclude] = None,
          order: Optional[Union[types.PostOrderByInput, List[types.PostOrderByInput]]] = None,
      ) -> Optional[models.Post]:
          resp = self._client._execute(
              operation='query',
              method='findFirst',
              model='Post',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.Post.parse_obj(result)
  
      def update(
          self,
          data: types.PostUpdateInput,
          where: types.PostWhereUniqueInput,
          include: Optional[types.PostInclude] = None
      ) -> Optional[models.Post]:
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='Post',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.Post.parse_obj(resp['data']['result'])
  
      def upsert(
          self,
          where: types.PostWhereUniqueInput,
          data: types.PostUpsertInput,
          include: Optional[types.PostInclude] = None,
      ) -> models.Post:
          resp = self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='Post',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return models.Post.parse_obj(resp['data']['result'])
  
      def update_many(
          self,
          data: types.PostUpdateManyMutationInput,
          where: types.PostWhereInput,
      ) -> int:
          resp = self._client._execute(
              operation='mutation',
              method='updateMany',
              model='Post',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def count(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.PostWhereInput] = None,
          cursor: Optional[types.PostWhereUniqueInput] = None,
          order: Optional[Union[types.PostOrderByInput, List[types.PostOrderByInput]]] = None,
      ) -> int:
          # TODO: support select
          resp = self._client._execute(
              operation='query',
              method='aggregate',
              model='Post',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=['_count { _all }'],
          )
          return cast(int, resp['data']['result']['_count']['_all'])
  
      def delete_many(
          self,
          where: Optional[types.PostWhereInput] = None
      ) -> int:
          resp = self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='Post',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class PostBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.PostCreateInput,
          include: Optional[types.PostInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='Post',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.PostCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='Post',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.PostWhereUniqueInput,
          include: Optional[types.PostInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='Post',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.PostUpdateInput,
          where: types.PostWhereUniqueInput,
          include: Optional[types.PostInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='Post',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.PostWhereUniqueInput,
          data: types.PostUpsertInput,
          include: Optional[types.PostInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='Post',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.PostUpdateManyMutationInput,
          where: types.PostWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='Post',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.PostWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='Post',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  class UserActions:
      def __init__(self, client: Client):
          self._client = client
  
      def create(
          self,
          data: types.UserCreateInput,
          include: Optional[types.UserInclude] = None
      ) -> models.User:
          resp = self._client._execute(
              operation='mutation',
              method='createOne',
              model='User',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return models.User.parse_obj(resp['data']['result'])
  
      def create_many(
          self,
          data: List[types.UserCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = self._client._execute(
              operation='mutation',
              method='createMany',
              model='User',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def delete(
          self,
          where: types.UserWhereUniqueInput,
          include: Optional[types.UserInclude] = None
      ) -> Optional[models.User]:
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='User',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.User.parse_obj(resp['data']['result'])
  
      def find_unique(
          self,
          where: types.UserWhereUniqueInput,
          include: Optional[types.UserInclude] = None
      ) -> Optional[models.User]:
          resp = self._client._execute(
              operation='query',
              method='findUnique',
              model='User',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.User.parse_obj(result)
  
      def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.UserWhereInput] = None,
          cursor: Optional[types.UserWhereUniqueInput] = None,
          include: Optional[types.UserInclude] = None,
          order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
      ) -> List[models.User]:
          resp = self._client._execute(
              operation='query',
              method='findMany',
              model='User',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [models.User.parse_obj(r) for r in resp['data']['result']]
  
      def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.UserWhereInput] = None,
          cursor: Optional[types.UserWhereUniqueInput] = None,
          include: Optional[types.UserInclude] = None,
          order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
      ) -> Optional[models.User]:
          resp = self._client._execute(
              operation='query',
              method='findFirst',
              model='User',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.User.parse_obj(result)
  
      def update(
          self,
          data: types.UserUpdateInput,
          where: types.UserWhereUniqueInput,
          include: Optional[types.UserInclude] = None
      ) -> Optional[models.User]:
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='User',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.User.parse_obj(resp['data']['result'])
  
      def upsert(
          self,
          where: types.UserWhereUniqueInput,
          data: types.UserUpsertInput,
          include: Optional[types.UserInclude] = None,
      ) -> models.User:
          resp = self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='User',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return models.User.parse_obj(resp['data']['result'])
  
      def update_many(
          self,
          data: types.UserUpdateManyMutationInput,
          where: types.UserWhereInput,
      ) -> int:
          resp = self._client._execute(
              operation='mutation',
              method='updateMany',
              model='User',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def count(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.UserWhereInput] = None,
          cursor: Optional[types.UserWhereUniqueInput] = None,
          order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
      ) -> int:
          # TODO: support select
          resp = self._client._execute(
              operation='query',
              method='aggregate',
              model='User',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=['_count { _all }'],
          )
          return cast(int, resp['data']['result']['_count']['_all'])
  
      def delete_many(
          self,
          where: Optional[types.UserWhereInput] = None
      ) -> int:
          resp = self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='User',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class UserBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.UserCreateInput,
          include: Optional[types.UserInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='User',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.UserCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='User',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.UserWhereUniqueInput,
          include: Optional[types.UserInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='User',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.UserUpdateInput,
          where: types.UserWhereUniqueInput,
          include: Optional[types.UserInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='User',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.UserWhereUniqueInput,
          data: types.UserUpsertInput,
          include: Optional[types.UserInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='User',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.UserUpdateManyMutationInput,
          where: types.UserWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='User',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.UserWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='User',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  class MActions:
      def __init__(self, client: Client):
          self._client = client
  
      def create(
          self,
          data: types.MCreateInput,
          include: Optional[types.MInclude] = None
      ) -> models.M:
          resp = self._client._execute(
              operation='mutation',
              method='createOne',
              model='M',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return models.M.parse_obj(resp['data']['result'])
  
      def create_many(
          self,
          data: List[types.MCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = self._client._execute(
              operation='mutation',
              method='createMany',
              model='M',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def delete(
          self,
          where: types.MWhereUniqueInput,
          include: Optional[types.MInclude] = None
      ) -> Optional[models.M]:
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='M',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.M.parse_obj(resp['data']['result'])
  
      def find_unique(
          self,
          where: types.MWhereUniqueInput,
          include: Optional[types.MInclude] = None
      ) -> Optional[models.M]:
          resp = self._client._execute(
              operation='query',
              method='findUnique',
              model='M',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.M.parse_obj(result)
  
      def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.MWhereInput] = None,
          cursor: Optional[types.MWhereUniqueInput] = None,
          include: Optional[types.MInclude] = None,
          order: Optional[Union[types.MOrderByInput, List[types.MOrderByInput]]] = None,
      ) -> List[models.M]:
          resp = self._client._execute(
              operation='query',
              method='findMany',
              model='M',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [models.M.parse_obj(r) for r in resp['data']['result']]
  
      def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.MWhereInput] = None,
          cursor: Optional[types.MWhereUniqueInput] = None,
          include: Optional[types.MInclude] = None,
          order: Optional[Union[types.MOrderByInput, List[types.MOrderByInput]]] = None,
      ) -> Optional[models.M]:
          resp = self._client._execute(
              operation='query',
              method='findFirst',
              model='M',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.M.parse_obj(result)
  
      def update(
          self,
          data: types.MUpdateInput,
          where: types.MWhereUniqueInput,
          include: Optional[types.MInclude] = None
      ) -> Optional[models.M]:
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='M',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.M.parse_obj(resp['data']['result'])
  
      def upsert(
          self,
          where: types.MWhereUniqueInput,
          data: types.MUpsertInput,
          include: Optional[types.MInclude] = None,
      ) -> models.M:
          resp = self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='M',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return models.M.parse_obj(resp['data']['result'])
  
      def update_many(
          self,
          data: types.MUpdateManyMutationInput,
          where: types.MWhereInput,
      ) -> int:
          resp = self._client._execute(
              operation='mutation',
              method='updateMany',
              model='M',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def count(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.MWhereInput] = None,
          cursor: Optional[types.MWhereUniqueInput] = None,
          order: Optional[Union[types.MOrderByInput, List[types.MOrderByInput]]] = None,
      ) -> int:
          # TODO: support select
          resp = self._client._execute(
              operation='query',
              method='aggregate',
              model='M',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=['_count { _all }'],
          )
          return cast(int, resp['data']['result']['_count']['_all'])
  
      def delete_many(
          self,
          where: Optional[types.MWhereInput] = None
      ) -> int:
          resp = self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='M',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class MBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.MCreateInput,
          include: Optional[types.MInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='M',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.MCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='M',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.MWhereUniqueInput,
          include: Optional[types.MInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='M',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.MUpdateInput,
          where: types.MWhereUniqueInput,
          include: Optional[types.MInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='M',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.MWhereUniqueInput,
          data: types.MUpsertInput,
          include: Optional[types.MInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='M',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.MUpdateManyMutationInput,
          where: types.MWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='M',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.MWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='M',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  class NActions:
      def __init__(self, client: Client):
          self._client = client
  
      def create(
          self,
          data: types.NCreateInput,
          include: Optional[types.NInclude] = None
      ) -> models.N:
          resp = self._client._execute(
              operation='mutation',
              method='createOne',
              model='N',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return models.N.parse_obj(resp['data']['result'])
  
      def create_many(
          self,
          data: List[types.NCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = self._client._execute(
              operation='mutation',
              method='createMany',
              model='N',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def delete(
          self,
          where: types.NWhereUniqueInput,
          include: Optional[types.NInclude] = None
      ) -> Optional[models.N]:
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='N',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.N.parse_obj(resp['data']['result'])
  
      def find_unique(
          self,
          where: types.NWhereUniqueInput,
          include: Optional[types.NInclude] = None
      ) -> Optional[models.N]:
          resp = self._client._execute(
              operation='query',
              method='findUnique',
              model='N',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.N.parse_obj(result)
  
      def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.NWhereInput] = None,
          cursor: Optional[types.NWhereUniqueInput] = None,
          include: Optional[types.NInclude] = None,
          order: Optional[Union[types.NOrderByInput, List[types.NOrderByInput]]] = None,
      ) -> List[models.N]:
          resp = self._client._execute(
              operation='query',
              method='findMany',
              model='N',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [models.N.parse_obj(r) for r in resp['data']['result']]
  
      def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.NWhereInput] = None,
          cursor: Optional[types.NWhereUniqueInput] = None,
          include: Optional[types.NInclude] = None,
          order: Optional[Union[types.NOrderByInput, List[types.NOrderByInput]]] = None,
      ) -> Optional[models.N]:
          resp = self._client._execute(
              operation='query',
              method='findFirst',
              model='N',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.N.parse_obj(result)
  
      def update(
          self,
          data: types.NUpdateInput,
          where: types.NWhereUniqueInput,
          include: Optional[types.NInclude] = None
      ) -> Optional[models.N]:
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='N',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.N.parse_obj(resp['data']['result'])
  
      def upsert(
          self,
          where: types.NWhereUniqueInput,
          data: types.NUpsertInput,
          include: Optional[types.NInclude] = None,
      ) -> models.N:
          resp = self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='N',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return models.N.parse_obj(resp['data']['result'])
  
      def update_many(
          self,
          data: types.NUpdateManyMutationInput,
          where: types.NWhereInput,
      ) -> int:
          resp = self._client._execute(
              operation='mutation',
              method='updateMany',
              model='N',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def count(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.NWhereInput] = None,
          cursor: Optional[types.NWhereUniqueInput] = None,
          order: Optional[Union[types.NOrderByInput, List[types.NOrderByInput]]] = None,
      ) -> int:
          # TODO: support select
          resp = self._client._execute(
              operation='query',
              method='aggregate',
              model='N',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=['_count { _all }'],
          )
          return cast(int, resp['data']['result']['_count']['_all'])
  
      def delete_many(
          self,
          where: Optional[types.NWhereInput] = None
      ) -> int:
          resp = self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='N',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class NBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.NCreateInput,
          include: Optional[types.NInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='N',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.NCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='N',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.NWhereUniqueInput,
          include: Optional[types.NInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='N',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.NUpdateInput,
          where: types.NWhereUniqueInput,
          include: Optional[types.NInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='N',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.NWhereUniqueInput,
          data: types.NUpsertInput,
          include: Optional[types.NInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='N',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.NUpdateManyMutationInput,
          where: types.NWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='N',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.NWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='N',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  class OneOptionalActions:
      def __init__(self, client: Client):
          self._client = client
  
      def create(
          self,
          data: types.OneOptionalCreateInput,
          include: Optional[types.OneOptionalInclude] = None
      ) -> models.OneOptional:
          resp = self._client._execute(
              operation='mutation',
              method='createOne',
              model='OneOptional',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return models.OneOptional.parse_obj(resp['data']['result'])
  
      def create_many(
          self,
          data: List[types.OneOptionalCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = self._client._execute(
              operation='mutation',
              method='createMany',
              model='OneOptional',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def delete(
          self,
          where: types.OneOptionalWhereUniqueInput,
          include: Optional[types.OneOptionalInclude] = None
      ) -> Optional[models.OneOptional]:
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='OneOptional',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.OneOptional.parse_obj(resp['data']['result'])
  
      def find_unique(
          self,
          where: types.OneOptionalWhereUniqueInput,
          include: Optional[types.OneOptionalInclude] = None
      ) -> Optional[models.OneOptional]:
          resp = self._client._execute(
              operation='query',
              method='findUnique',
              model='OneOptional',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.OneOptional.parse_obj(result)
  
      def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.OneOptionalWhereInput] = None,
          cursor: Optional[types.OneOptionalWhereUniqueInput] = None,
          include: Optional[types.OneOptionalInclude] = None,
          order: Optional[Union[types.OneOptionalOrderByInput, List[types.OneOptionalOrderByInput]]] = None,
      ) -> List[models.OneOptional]:
          resp = self._client._execute(
              operation='query',
              method='findMany',
              model='OneOptional',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [models.OneOptional.parse_obj(r) for r in resp['data']['result']]
  
      def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.OneOptionalWhereInput] = None,
          cursor: Optional[types.OneOptionalWhereUniqueInput] = None,
          include: Optional[types.OneOptionalInclude] = None,
          order: Optional[Union[types.OneOptionalOrderByInput, List[types.OneOptionalOrderByInput]]] = None,
      ) -> Optional[models.OneOptional]:
          resp = self._client._execute(
              operation='query',
              method='findFirst',
              model='OneOptional',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.OneOptional.parse_obj(result)
  
      def update(
          self,
          data: types.OneOptionalUpdateInput,
          where: types.OneOptionalWhereUniqueInput,
          include: Optional[types.OneOptionalInclude] = None
      ) -> Optional[models.OneOptional]:
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='OneOptional',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.OneOptional.parse_obj(resp['data']['result'])
  
      def upsert(
          self,
          where: types.OneOptionalWhereUniqueInput,
          data: types.OneOptionalUpsertInput,
          include: Optional[types.OneOptionalInclude] = None,
      ) -> models.OneOptional:
          resp = self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='OneOptional',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return models.OneOptional.parse_obj(resp['data']['result'])
  
      def update_many(
          self,
          data: types.OneOptionalUpdateManyMutationInput,
          where: types.OneOptionalWhereInput,
      ) -> int:
          resp = self._client._execute(
              operation='mutation',
              method='updateMany',
              model='OneOptional',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def count(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.OneOptionalWhereInput] = None,
          cursor: Optional[types.OneOptionalWhereUniqueInput] = None,
          order: Optional[Union[types.OneOptionalOrderByInput, List[types.OneOptionalOrderByInput]]] = None,
      ) -> int:
          # TODO: support select
          resp = self._client._execute(
              operation='query',
              method='aggregate',
              model='OneOptional',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=['_count { _all }'],
          )
          return cast(int, resp['data']['result']['_count']['_all'])
  
      def delete_many(
          self,
          where: Optional[types.OneOptionalWhereInput] = None
      ) -> int:
          resp = self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='OneOptional',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class OneOptionalBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.OneOptionalCreateInput,
          include: Optional[types.OneOptionalInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='OneOptional',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.OneOptionalCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='OneOptional',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.OneOptionalWhereUniqueInput,
          include: Optional[types.OneOptionalInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='OneOptional',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.OneOptionalUpdateInput,
          where: types.OneOptionalWhereUniqueInput,
          include: Optional[types.OneOptionalInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='OneOptional',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.OneOptionalWhereUniqueInput,
          data: types.OneOptionalUpsertInput,
          include: Optional[types.OneOptionalInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='OneOptional',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.OneOptionalUpdateManyMutationInput,
          where: types.OneOptionalWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='OneOptional',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.OneOptionalWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='OneOptional',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  class ManyRequiredActions:
      def __init__(self, client: Client):
          self._client = client
  
      def create(
          self,
          data: types.ManyRequiredCreateInput,
          include: Optional[types.ManyRequiredInclude] = None
      ) -> models.ManyRequired:
          resp = self._client._execute(
              operation='mutation',
              method='createOne',
              model='ManyRequired',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return models.ManyRequired.parse_obj(resp['data']['result'])
  
      def create_many(
          self,
          data: List[types.ManyRequiredCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = self._client._execute(
              operation='mutation',
              method='createMany',
              model='ManyRequired',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def delete(
          self,
          where: types.ManyRequiredWhereUniqueInput,
          include: Optional[types.ManyRequiredInclude] = None
      ) -> Optional[models.ManyRequired]:
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='ManyRequired',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.ManyRequired.parse_obj(resp['data']['result'])
  
      def find_unique(
          self,
          where: types.ManyRequiredWhereUniqueInput,
          include: Optional[types.ManyRequiredInclude] = None
      ) -> Optional[models.ManyRequired]:
          resp = self._client._execute(
              operation='query',
              method='findUnique',
              model='ManyRequired',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.ManyRequired.parse_obj(result)
  
      def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.ManyRequiredWhereInput] = None,
          cursor: Optional[types.ManyRequiredWhereUniqueInput] = None,
          include: Optional[types.ManyRequiredInclude] = None,
          order: Optional[Union[types.ManyRequiredOrderByInput, List[types.ManyRequiredOrderByInput]]] = None,
      ) -> List[models.ManyRequired]:
          resp = self._client._execute(
              operation='query',
              method='findMany',
              model='ManyRequired',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [models.ManyRequired.parse_obj(r) for r in resp['data']['result']]
  
      def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.ManyRequiredWhereInput] = None,
          cursor: Optional[types.ManyRequiredWhereUniqueInput] = None,
          include: Optional[types.ManyRequiredInclude] = None,
          order: Optional[Union[types.ManyRequiredOrderByInput, List[types.ManyRequiredOrderByInput]]] = None,
      ) -> Optional[models.ManyRequired]:
          resp = self._client._execute(
              operation='query',
              method='findFirst',
              model='ManyRequired',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.ManyRequired.parse_obj(result)
  
      def update(
          self,
          data: types.ManyRequiredUpdateInput,
          where: types.ManyRequiredWhereUniqueInput,
          include: Optional[types.ManyRequiredInclude] = None
      ) -> Optional[models.ManyRequired]:
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='ManyRequired',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.ManyRequired.parse_obj(resp['data']['result'])
  
      def upsert(
          self,
          where: types.ManyRequiredWhereUniqueInput,
          data: types.ManyRequiredUpsertInput,
          include: Optional[types.ManyRequiredInclude] = None,
      ) -> models.ManyRequired:
          resp = self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='ManyRequired',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return models.ManyRequired.parse_obj(resp['data']['result'])
  
      def update_many(
          self,
          data: types.ManyRequiredUpdateManyMutationInput,
          where: types.ManyRequiredWhereInput,
      ) -> int:
          resp = self._client._execute(
              operation='mutation',
              method='updateMany',
              model='ManyRequired',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def count(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.ManyRequiredWhereInput] = None,
          cursor: Optional[types.ManyRequiredWhereUniqueInput] = None,
          order: Optional[Union[types.ManyRequiredOrderByInput, List[types.ManyRequiredOrderByInput]]] = None,
      ) -> int:
          # TODO: support select
          resp = self._client._execute(
              operation='query',
              method='aggregate',
              model='ManyRequired',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=['_count { _all }'],
          )
          return cast(int, resp['data']['result']['_count']['_all'])
  
      def delete_many(
          self,
          where: Optional[types.ManyRequiredWhereInput] = None
      ) -> int:
          resp = self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='ManyRequired',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class ManyRequiredBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.ManyRequiredCreateInput,
          include: Optional[types.ManyRequiredInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='ManyRequired',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.ManyRequiredCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='ManyRequired',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.ManyRequiredWhereUniqueInput,
          include: Optional[types.ManyRequiredInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='ManyRequired',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.ManyRequiredUpdateInput,
          where: types.ManyRequiredWhereUniqueInput,
          include: Optional[types.ManyRequiredInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='ManyRequired',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.ManyRequiredWhereUniqueInput,
          data: types.ManyRequiredUpsertInput,
          include: Optional[types.ManyRequiredInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='ManyRequired',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.ManyRequiredUpdateManyMutationInput,
          where: types.ManyRequiredWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='ManyRequired',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.ManyRequiredWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='ManyRequired',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  class AActions:
      def __init__(self, client: Client):
          self._client = client
  
      def create(
          self,
          data: types.ACreateInput,
          include: Optional[types.AInclude] = None
      ) -> models.A:
          resp = self._client._execute(
              operation='mutation',
              method='createOne',
              model='A',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return models.A.parse_obj(resp['data']['result'])
  
      def create_many(
          self,
          data: List[types.ACreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = self._client._execute(
              operation='mutation',
              method='createMany',
              model='A',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def delete(
          self,
          where: types.AWhereUniqueInput,
          include: Optional[types.AInclude] = None
      ) -> Optional[models.A]:
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='A',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.A.parse_obj(resp['data']['result'])
  
      def find_unique(
          self,
          where: types.AWhereUniqueInput,
          include: Optional[types.AInclude] = None
      ) -> Optional[models.A]:
          resp = self._client._execute(
              operation='query',
              method='findUnique',
              model='A',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.A.parse_obj(result)
  
      def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.AWhereInput] = None,
          cursor: Optional[types.AWhereUniqueInput] = None,
          include: Optional[types.AInclude] = None,
          order: Optional[Union[types.AOrderByInput, List[types.AOrderByInput]]] = None,
      ) -> List[models.A]:
          resp = self._client._execute(
              operation='query',
              method='findMany',
              model='A',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [models.A.parse_obj(r) for r in resp['data']['result']]
  
      def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.AWhereInput] = None,
          cursor: Optional[types.AWhereUniqueInput] = None,
          include: Optional[types.AInclude] = None,
          order: Optional[Union[types.AOrderByInput, List[types.AOrderByInput]]] = None,
      ) -> Optional[models.A]:
          resp = self._client._execute(
              operation='query',
              method='findFirst',
              model='A',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.A.parse_obj(result)
  
      def update(
          self,
          data: types.AUpdateInput,
          where: types.AWhereUniqueInput,
          include: Optional[types.AInclude] = None
      ) -> Optional[models.A]:
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='A',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.A.parse_obj(resp['data']['result'])
  
      def upsert(
          self,
          where: types.AWhereUniqueInput,
          data: types.AUpsertInput,
          include: Optional[types.AInclude] = None,
      ) -> models.A:
          resp = self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='A',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return models.A.parse_obj(resp['data']['result'])
  
      def update_many(
          self,
          data: types.AUpdateManyMutationInput,
          where: types.AWhereInput,
      ) -> int:
          resp = self._client._execute(
              operation='mutation',
              method='updateMany',
              model='A',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def count(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.AWhereInput] = None,
          cursor: Optional[types.AWhereUniqueInput] = None,
          order: Optional[Union[types.AOrderByInput, List[types.AOrderByInput]]] = None,
      ) -> int:
          # TODO: support select
          resp = self._client._execute(
              operation='query',
              method='aggregate',
              model='A',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=['_count { _all }'],
          )
          return cast(int, resp['data']['result']['_count']['_all'])
  
      def delete_many(
          self,
          where: Optional[types.AWhereInput] = None
      ) -> int:
          resp = self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='A',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class ABatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.ACreateInput,
          include: Optional[types.AInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='A',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.ACreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='A',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.AWhereUniqueInput,
          include: Optional[types.AInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='A',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.AUpdateInput,
          where: types.AWhereUniqueInput,
          include: Optional[types.AInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='A',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.AWhereUniqueInput,
          data: types.AUpsertInput,
          include: Optional[types.AInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='A',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.AUpdateManyMutationInput,
          where: types.AWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='A',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.AWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='A',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  class BActions:
      def __init__(self, client: Client):
          self._client = client
  
      def create(
          self,
          data: types.BCreateInput,
          include: Optional[types.BInclude] = None
      ) -> models.B:
          resp = self._client._execute(
              operation='mutation',
              method='createOne',
              model='B',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return models.B.parse_obj(resp['data']['result'])
  
      def create_many(
          self,
          data: List[types.BCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = self._client._execute(
              operation='mutation',
              method='createMany',
              model='B',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def delete(
          self,
          where: types.BWhereUniqueInput,
          include: Optional[types.BInclude] = None
      ) -> Optional[models.B]:
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='B',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.B.parse_obj(resp['data']['result'])
  
      def find_unique(
          self,
          where: types.BWhereUniqueInput,
          include: Optional[types.BInclude] = None
      ) -> Optional[models.B]:
          resp = self._client._execute(
              operation='query',
              method='findUnique',
              model='B',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.B.parse_obj(result)
  
      def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.BWhereInput] = None,
          cursor: Optional[types.BWhereUniqueInput] = None,
          include: Optional[types.BInclude] = None,
          order: Optional[Union[types.BOrderByInput, List[types.BOrderByInput]]] = None,
      ) -> List[models.B]:
          resp = self._client._execute(
              operation='query',
              method='findMany',
              model='B',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [models.B.parse_obj(r) for r in resp['data']['result']]
  
      def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.BWhereInput] = None,
          cursor: Optional[types.BWhereUniqueInput] = None,
          include: Optional[types.BInclude] = None,
          order: Optional[Union[types.BOrderByInput, List[types.BOrderByInput]]] = None,
      ) -> Optional[models.B]:
          resp = self._client._execute(
              operation='query',
              method='findFirst',
              model='B',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.B.parse_obj(result)
  
      def update(
          self,
          data: types.BUpdateInput,
          where: types.BWhereUniqueInput,
          include: Optional[types.BInclude] = None
      ) -> Optional[models.B]:
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='B',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.B.parse_obj(resp['data']['result'])
  
      def upsert(
          self,
          where: types.BWhereUniqueInput,
          data: types.BUpsertInput,
          include: Optional[types.BInclude] = None,
      ) -> models.B:
          resp = self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='B',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return models.B.parse_obj(resp['data']['result'])
  
      def update_many(
          self,
          data: types.BUpdateManyMutationInput,
          where: types.BWhereInput,
      ) -> int:
          resp = self._client._execute(
              operation='mutation',
              method='updateMany',
              model='B',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def count(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.BWhereInput] = None,
          cursor: Optional[types.BWhereUniqueInput] = None,
          order: Optional[Union[types.BOrderByInput, List[types.BOrderByInput]]] = None,
      ) -> int:
          # TODO: support select
          resp = self._client._execute(
              operation='query',
              method='aggregate',
              model='B',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=['_count { _all }'],
          )
          return cast(int, resp['data']['result']['_count']['_all'])
  
      def delete_many(
          self,
          where: Optional[types.BWhereInput] = None
      ) -> int:
          resp = self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='B',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class BBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.BCreateInput,
          include: Optional[types.BInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='B',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.BCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='B',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.BWhereUniqueInput,
          include: Optional[types.BInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='B',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.BUpdateInput,
          where: types.BWhereUniqueInput,
          include: Optional[types.BInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='B',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.BWhereUniqueInput,
          data: types.BUpsertInput,
          include: Optional[types.BInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='B',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.BUpdateManyMutationInput,
          where: types.BWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='B',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.BWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='B',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  class CActions:
      def __init__(self, client: Client):
          self._client = client
  
      def create(
          self,
          data: types.CCreateInput,
          include: Optional[types.CInclude] = None
      ) -> models.C:
          resp = self._client._execute(
              operation='mutation',
              method='createOne',
              model='C',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return models.C.parse_obj(resp['data']['result'])
  
      def create_many(
          self,
          data: List[types.CCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = self._client._execute(
              operation='mutation',
              method='createMany',
              model='C',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def delete(
          self,
          where: types.CWhereUniqueInput,
          include: Optional[types.CInclude] = None
      ) -> Optional[models.C]:
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='C',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.C.parse_obj(resp['data']['result'])
  
      def find_unique(
          self,
          where: types.CWhereUniqueInput,
          include: Optional[types.CInclude] = None
      ) -> Optional[models.C]:
          resp = self._client._execute(
              operation='query',
              method='findUnique',
              model='C',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.C.parse_obj(result)
  
      def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.CWhereInput] = None,
          cursor: Optional[types.CWhereUniqueInput] = None,
          include: Optional[types.CInclude] = None,
          order: Optional[Union[types.COrderByInput, List[types.COrderByInput]]] = None,
      ) -> List[models.C]:
          resp = self._client._execute(
              operation='query',
              method='findMany',
              model='C',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [models.C.parse_obj(r) for r in resp['data']['result']]
  
      def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.CWhereInput] = None,
          cursor: Optional[types.CWhereUniqueInput] = None,
          include: Optional[types.CInclude] = None,
          order: Optional[Union[types.COrderByInput, List[types.COrderByInput]]] = None,
      ) -> Optional[models.C]:
          resp = self._client._execute(
              operation='query',
              method='findFirst',
              model='C',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.C.parse_obj(result)
  
      def update(
          self,
          data: types.CUpdateInput,
          where: types.CWhereUniqueInput,
          include: Optional[types.CInclude] = None
      ) -> Optional[models.C]:
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='C',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.C.parse_obj(resp['data']['result'])
  
      def upsert(
          self,
          where: types.CWhereUniqueInput,
          data: types.CUpsertInput,
          include: Optional[types.CInclude] = None,
      ) -> models.C:
          resp = self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='C',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return models.C.parse_obj(resp['data']['result'])
  
      def update_many(
          self,
          data: types.CUpdateManyMutationInput,
          where: types.CWhereInput,
      ) -> int:
          resp = self._client._execute(
              operation='mutation',
              method='updateMany',
              model='C',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def count(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.CWhereInput] = None,
          cursor: Optional[types.CWhereUniqueInput] = None,
          order: Optional[Union[types.COrderByInput, List[types.COrderByInput]]] = None,
      ) -> int:
          # TODO: support select
          resp = self._client._execute(
              operation='query',
              method='aggregate',
              model='C',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=['_count { _all }'],
          )
          return cast(int, resp['data']['result']['_count']['_all'])
  
      def delete_many(
          self,
          where: Optional[types.CWhereInput] = None
      ) -> int:
          resp = self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='C',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class CBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.CCreateInput,
          include: Optional[types.CInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='C',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.CCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='C',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.CWhereUniqueInput,
          include: Optional[types.CInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='C',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.CUpdateInput,
          where: types.CWhereUniqueInput,
          include: Optional[types.CInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='C',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.CWhereUniqueInput,
          data: types.CUpsertInput,
          include: Optional[types.CInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='C',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.CUpdateManyMutationInput,
          where: types.CWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='C',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.CWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='C',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  class DActions:
      def __init__(self, client: Client):
          self._client = client
  
      def create(
          self,
          data: types.DCreateInput,
          include: Optional[types.DInclude] = None
      ) -> models.D:
          resp = self._client._execute(
              operation='mutation',
              method='createOne',
              model='D',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return models.D.parse_obj(resp['data']['result'])
  
      def create_many(
          self,
          data: List[types.DCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = self._client._execute(
              operation='mutation',
              method='createMany',
              model='D',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def delete(
          self,
          where: types.DWhereUniqueInput,
          include: Optional[types.DInclude] = None
      ) -> Optional[models.D]:
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='D',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.D.parse_obj(resp['data']['result'])
  
      def find_unique(
          self,
          where: types.DWhereUniqueInput,
          include: Optional[types.DInclude] = None
      ) -> Optional[models.D]:
          resp = self._client._execute(
              operation='query',
              method='findUnique',
              model='D',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.D.parse_obj(result)
  
      def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.DWhereInput] = None,
          cursor: Optional[types.DWhereUniqueInput] = None,
          include: Optional[types.DInclude] = None,
          order: Optional[Union[types.DOrderByInput, List[types.DOrderByInput]]] = None,
      ) -> List[models.D]:
          resp = self._client._execute(
              operation='query',
              method='findMany',
              model='D',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [models.D.parse_obj(r) for r in resp['data']['result']]
  
      def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.DWhereInput] = None,
          cursor: Optional[types.DWhereUniqueInput] = None,
          include: Optional[types.DInclude] = None,
          order: Optional[Union[types.DOrderByInput, List[types.DOrderByInput]]] = None,
      ) -> Optional[models.D]:
          resp = self._client._execute(
              operation='query',
              method='findFirst',
              model='D',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.D.parse_obj(result)
  
      def update(
          self,
          data: types.DUpdateInput,
          where: types.DWhereUniqueInput,
          include: Optional[types.DInclude] = None
      ) -> Optional[models.D]:
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='D',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.D.parse_obj(resp['data']['result'])
  
      def upsert(
          self,
          where: types.DWhereUniqueInput,
          data: types.DUpsertInput,
          include: Optional[types.DInclude] = None,
      ) -> models.D:
          resp = self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='D',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return models.D.parse_obj(resp['data']['result'])
  
      def update_many(
          self,
          data: types.DUpdateManyMutationInput,
          where: types.DWhereInput,
      ) -> int:
          resp = self._client._execute(
              operation='mutation',
              method='updateMany',
              model='D',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def count(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.DWhereInput] = None,
          cursor: Optional[types.DWhereUniqueInput] = None,
          order: Optional[Union[types.DOrderByInput, List[types.DOrderByInput]]] = None,
      ) -> int:
          # TODO: support select
          resp = self._client._execute(
              operation='query',
              method='aggregate',
              model='D',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=['_count { _all }'],
          )
          return cast(int, resp['data']['result']['_count']['_all'])
  
      def delete_many(
          self,
          where: Optional[types.DWhereInput] = None
      ) -> int:
          resp = self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='D',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class DBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.DCreateInput,
          include: Optional[types.DInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='D',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.DCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='D',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.DWhereUniqueInput,
          include: Optional[types.DInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='D',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.DUpdateInput,
          where: types.DWhereUniqueInput,
          include: Optional[types.DInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='D',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.DWhereUniqueInput,
          data: types.DUpsertInput,
          include: Optional[types.DInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='D',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.DUpdateManyMutationInput,
          where: types.DWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='D',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.DWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='D',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  class EActions:
      def __init__(self, client: Client):
          self._client = client
  
      def create(
          self,
          data: types.ECreateInput,
          include: Optional[types.EInclude] = None
      ) -> models.E:
          resp = self._client._execute(
              operation='mutation',
              method='createOne',
              model='E',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return models.E.parse_obj(resp['data']['result'])
  
      def create_many(
          self,
          data: List[types.ECreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = self._client._execute(
              operation='mutation',
              method='createMany',
              model='E',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def delete(
          self,
          where: types.EWhereUniqueInput,
          include: Optional[types.EInclude] = None
      ) -> Optional[models.E]:
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='E',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.E.parse_obj(resp['data']['result'])
  
      def find_unique(
          self,
          where: types.EWhereUniqueInput,
          include: Optional[types.EInclude] = None
      ) -> Optional[models.E]:
          resp = self._client._execute(
              operation='query',
              method='findUnique',
              model='E',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.E.parse_obj(result)
  
      def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.EWhereInput] = None,
          cursor: Optional[types.EWhereUniqueInput] = None,
          include: Optional[types.EInclude] = None,
          order: Optional[Union[types.EOrderByInput, List[types.EOrderByInput]]] = None,
      ) -> List[models.E]:
          resp = self._client._execute(
              operation='query',
              method='findMany',
              model='E',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [models.E.parse_obj(r) for r in resp['data']['result']]
  
      def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.EWhereInput] = None,
          cursor: Optional[types.EWhereUniqueInput] = None,
          include: Optional[types.EInclude] = None,
          order: Optional[Union[types.EOrderByInput, List[types.EOrderByInput]]] = None,
      ) -> Optional[models.E]:
          resp = self._client._execute(
              operation='query',
              method='findFirst',
              model='E',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return models.E.parse_obj(result)
  
      def update(
          self,
          data: types.EUpdateInput,
          where: types.EWhereUniqueInput,
          include: Optional[types.EInclude] = None
      ) -> Optional[models.E]:
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='E',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return models.E.parse_obj(resp['data']['result'])
  
      def upsert(
          self,
          where: types.EWhereUniqueInput,
          data: types.EUpsertInput,
          include: Optional[types.EInclude] = None,
      ) -> models.E:
          resp = self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='E',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return models.E.parse_obj(resp['data']['result'])
  
      def update_many(
          self,
          data: types.EUpdateManyMutationInput,
          where: types.EWhereInput,
      ) -> int:
          resp = self._client._execute(
              operation='mutation',
              method='updateMany',
              model='E',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def count(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.EWhereInput] = None,
          cursor: Optional[types.EWhereUniqueInput] = None,
          order: Optional[Union[types.EOrderByInput, List[types.EOrderByInput]]] = None,
      ) -> int:
          # TODO: support select
          resp = self._client._execute(
              operation='query',
              method='aggregate',
              model='E',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=['_count { _all }'],
          )
          return cast(int, resp['data']['result']['_count']['_all'])
  
      def delete_many(
          self,
          where: Optional[types.EWhereInput] = None
      ) -> int:
          resp = self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='E',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class EBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.ECreateInput,
          include: Optional[types.EInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='E',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.ECreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='E',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.EWhereUniqueInput,
          include: Optional[types.EInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='E',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.EUpdateInput,
          where: types.EWhereUniqueInput,
          include: Optional[types.EInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='E',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.EWhereUniqueInput,
          data: types.EUpsertInput,
          include: Optional[types.EInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='E',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.EUpdateManyMutationInput,
          where: types.EWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='E',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.EWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='E',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  '
---
# name: test_sync[engine/query.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  
  if sys.version_info >= (3, 8):
      from typing import TypedDict, Literal
  else:
      from typing_extensions import TypedDict, Literal
  
  # -- template engine/query.py.jinja --
  
  import os
  import time
  import atexit
  import signal
  import asyncio
  import logging
  import subprocess
  from pathlib import Path
  
  from . import utils, errors
  from ..http import HTTP
  from ..utils import DEBUG
  from .._types import Method
  from ..binaries import platform
  from ..utils import time_since, _env_bool
  
  
  __all__ = ('QueryEngine',)
  
  log: logging.Logger = logging.getLogger(__name__)
  
  
  class QueryEngine:
      dml: str
      session: HTTP
  
      def __init__(self, *, dml: str, log_queries: bool = False):
          self.dml = dml
          self.session = HTTP()
          self._log_queries = log_queries
          self.url = None  # type: Optional[str]
          self.process = None  # type: Optional[subprocess.Popen[bytes]]
          self.file = None  # type: Optional[Path]
  
          # ensure the query engine process is terminated when we are
          atexit.register(self.stop)
  
      def __del__(self) -> None:
          self.stop()
  
      def stop(self) -> None:
          self.disconnect()
          self.close_session()
  
      def disconnect(self) -> None:
          log.debug('Disconnecting query engine...')
  
          if self.process is not None:
              if platform.name() == 'windows':
                  self.process.kill()
              else:
                  self.process.send_signal(signal.SIGINT)
  
              self.process.wait()
              self.process = None
  
          log.debug('Disconnected query engine')
  
      def close_session(self) -> None:
          if self.session and not self.session.closed:
              self.session.close()
  
      def connect(self, timeout: int = 10) -> None:
          log.debug('Connecting to query engine')
          if self.process is not None:
              raise errors.AlreadyConnectedError('Already connected to the query engine')
  
          start = time.monotonic()
          self.file = file = utils.ensure()
  
          try:
              self.spawn(file, timeout=timeout)
          except Exception:
              self.disconnect()
              raise
  
          log.debug('Connecting to query engine took %s', time_since(start))
  
      def spawn(self, file: Path, timeout: int = 10) -> None:
          port = utils.get_open_port()
          log.debug('Running query engine on port %i', port)
  
          self.url = f'http://localhost:{port}'
  
          env = os.environ.copy()
          env.update(
              PRISMA_DML=self.dml,
              RUST_LOG='error',
              RUST_LOG_FORMAT='json',
              PRISMA_CLIENT_ENGINE_TYPE='binary',
          )
  
          if DEBUG:
              env.update(RUST_LOG='info')
  
          # TODO: remove the noise from these query logs
          if self._log_queries:
              env.update(LOG_QUERIES='y')
  
          args: List[str] = [str(file.absolute()), '-p', str(port), '--enable-raw-queries']
          if _env_bool('__PRISMA_PY_PLAYGROUND'):
              env.update(RUST_LOG='info')
              args.append('--enable-playground')
  
          log.debug('Starting query engine...')
          self.process = subprocess.Popen(
              args,
              env=env,
              stdout=sys.stdout,
              stderr=sys.stderr,
          )
  
          last_exc = None
          for _ in range(int(timeout / 0.1)):
              try:
                  data = self.request('GET', '/status')
              except Exception as exc:  # pylint: disable=broad-except
                  last_exc = exc
                  log.debug(
                      'Could not connect to query engine due to %s; retrying...',
                      type(exc).__name__,
                  )
                  time.sleep(0.1)
  
                  continue
  
              if data.get('Errors') is not None:
                  log.debug('Could not connect due to gql errors; retrying...')
                  time.sleep(0.1)
  
                  continue
  
              break
          else:
              raise errors.EngineConnectionError(
                  'Could not connect to the query engine'
              ) from last_exc
  
      def request(self, method: Method, path: str, *, content: Any = None) -> Any:
          if self.url is None:
              raise errors.NotConnectedError('Not connected to the query engine')
  
          kwargs = {
              'headers': {
                  'Content-Type': 'application/json',
                  'Accept': 'application/json',
              }
          }
  
          if content is not None:
              kwargs['content'] = content
  
          url = self.url + path
          log.debug('Sending %s request to %s with content: %s', method, url, content)
  
          resp = self.session.request(method, url, **kwargs)
  
          if 300 > resp.status >= 200:
              response = resp.json()
              log.debug('%s %s returned %s', method, url, response)
  
              errors_data = response.get('errors')
              if errors_data:
                  return utils.handle_response_errors(resp, errors_data)
  
              return response
  
          if resp.status == 422:
              raise errors.UnprocessableEntityError(resp)
  
          # TODO: handle errors better
          raise errors.EngineRequestError(resp, resp.text())
  
  
  # black does not respect the fmt: off comment without this
  # fmt: on
  
  '
---
# name: test_sync[enums.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  
  if sys.version_info >= (3, 8):
      from typing import TypedDict, Literal
  else:
      from typing_extensions import TypedDict, Literal
  
  # -- template enums.py.jinja --
  from enum import Enum
  
  
  class ABeautifulEnum(str, Enum):
      A = 'A'
      B = 'B'
      C = 'C'
  
  
  '
---
# name: test_sync[fields.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  
  if sys.version_info >= (3, 8):
      from typing import TypedDict, Literal
  else:
      from typing_extensions import TypedDict, Literal
  
  # -- template fields.py.jinja --
  from pydantic import Json as _PydanticJson
  
  
  __all__ = (
      'Json',
  )
  
  
  _JsonKeys = Union[
      None,
      bool,
      float,
      int,
      str,
  ]
  
  
  # inherit from _PydanticJson so that pydantic will automatically
  # transform the json string into python objects.
  class Json(_PydanticJson):
      data: 'Serializable'
  
      def __init__(self, data: 'Serializable') -> None:
          self.data = data
          super().__init__()
  
      @classmethod
      def keys(cls, **data: 'Serializable') -> 'Json':
          return cls(data)
  
      if TYPE_CHECKING:
          # Fields that are of the `Json` type are automatically
          # de-serialized from json to the corresponding python type
          # when the model is created, e.g.
          #
          # User(json_obj='{"foo": null}') -> User(json_obj={'foo': None})
          #
          # As we don't know what the type will actually be at runtime
          # we add methods here for convenience so that naive access
          # to the field is still allowed, e.g.
          #
          # user.json_obj['foo']
          # user.json_obj[1]
          # user.json_obj[1:5]
          #
          # It should be noted that users will still have
          # to validate / cast fields to the type they are expecting
          # for any strict type binding or nested index calls to work, e.g.
          #
          # isinstance(user.json_obj, dict)
          # cast(Dict[str, Any], user.json_obj)
          # prisma.validate(ExpectedType, user.json_obj)  # NOTE: not implemented yet
          @overload  # type: ignore
          def __getitem__(self, i: slice) -> List['Serializable']:
              ...
  
          @overload
          def __getitem__(self, i: '_JsonKeys') -> 'Serializable':  # pyright: reportIncompatibleMethodOverride=false
              ...
  
          def __getitem__(self, i: Union['_JsonKeys', slice]) -> 'Serializable':
              ...
  
  
  from .types import Serializable
  '
---
# name: test_sync[http.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  
  if sys.version_info >= (3, 8):
      from typing import TypedDict, Literal
  else:
      from typing_extensions import TypedDict, Literal
  
  # -- template http.py.jinja --
  from ._sync_http import (
      HTTP as HTTP,
      Response as Response,
      client as client,
  )
  
  '
---
# name: test_sync[models.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  
  if sys.version_info >= (3, 8):
      from typing import TypedDict, Literal
  else:
      from typing_extensions import TypedDict, Literal
  
  # -- template models.py.jinja --
  import os
  from pydantic import BaseConfig, BaseModel, Field
  
  from . import types, enums, errors, fields
  from .generator import partial_models_ctx, PartialModelField
  
  
  class Config(BaseConfig):
      use_enum_values: bool = True
      allow_population_by_field_name: bool = True
  
  
  _created_partial_types: Set[str] = set()
  
  
  class Post(BaseModel):
      id: int
      created_at: datetime.datetime
      title: str
      content: Optional[str]
      published: bool
      author: Optional['models.User']
      author_id: int
  
      Config = Config
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.PostKeys']] = None,
          exclude: Optional[Iterable['types.PostKeys']] = None,
          required: Optional[Iterable['types.PostKeys']] = None,
          optional: Optional[Iterable['types.PostKeys']] = None,
          relations: Optional[Mapping['types.PostRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.PostKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _Post_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _Post_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _Post_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _Post_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  for field, type_ in relations.items():
                      if field not in _Post_relational_fields:
                          raise errors.UnknownRelationalFieldError('Post', field)
  
                      # TODO: this method of validating types is not ideal
                      # as it means we cannot two create partial types that
                      # reference each other
                      if type_ not in _created_partial_types:
                          raise ValueError(
                              f'Unknown partial type: "{type_}". '
                              f'Did you remember to generate the {type_} type before this one?'
                          )
  
                      # TODO: support non prisma.partials models
                      info = fields[field]
                      if info['is_list']:
                          info['type'] = f'List[\'partials.{type_}\']'
                      else:
                          info['type'] = f'\'partials.{type_}\''
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid Post / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class User(BaseModel):
      id: int
      email: str
      int: int
      optional_int: Optional[int]
      float: float
      optional_float: Optional[float]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
      posts: Optional[List['models.Post']]
  
      Config = Config
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.UserKeys']] = None,
          exclude: Optional[Iterable['types.UserKeys']] = None,
          required: Optional[Iterable['types.UserKeys']] = None,
          optional: Optional[Iterable['types.UserKeys']] = None,
          relations: Optional[Mapping['types.UserRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.UserKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _User_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _User_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _User_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _User_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  for field, type_ in relations.items():
                      if field not in _User_relational_fields:
                          raise errors.UnknownRelationalFieldError('User', field)
  
                      # TODO: this method of validating types is not ideal
                      # as it means we cannot two create partial types that
                      # reference each other
                      if type_ not in _created_partial_types:
                          raise ValueError(
                              f'Unknown partial type: "{type_}". '
                              f'Did you remember to generate the {type_} type before this one?'
                          )
  
                      # TODO: support non prisma.partials models
                      info = fields[field]
                      if info['is_list']:
                          info['type'] = f'List[\'partials.{type_}\']'
                      else:
                          info['type'] = f'\'partials.{type_}\''
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid User / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class M(BaseModel):
      id: int
      n: Optional[List['models.N']]
      int: int
      optional_int: Optional[int]
      float: float
      optional_float: Optional[float]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
      Config = Config
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.MKeys']] = None,
          exclude: Optional[Iterable['types.MKeys']] = None,
          required: Optional[Iterable['types.MKeys']] = None,
          optional: Optional[Iterable['types.MKeys']] = None,
          relations: Optional[Mapping['types.MRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.MKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _M_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _M_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _M_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _M_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  for field, type_ in relations.items():
                      if field not in _M_relational_fields:
                          raise errors.UnknownRelationalFieldError('M', field)
  
                      # TODO: this method of validating types is not ideal
                      # as it means we cannot two create partial types that
                      # reference each other
                      if type_ not in _created_partial_types:
                          raise ValueError(
                              f'Unknown partial type: "{type_}". '
                              f'Did you remember to generate the {type_} type before this one?'
                          )
  
                      # TODO: support non prisma.partials models
                      info = fields[field]
                      if info['is_list']:
                          info['type'] = f'List[\'partials.{type_}\']'
                      else:
                          info['type'] = f'\'partials.{type_}\''
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid M / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class N(BaseModel):
      id: int
      m: Optional[List['models.M']]
      int: int
      optional_int: Optional[int]
      float: float
      optional_float: Optional[float]
      string: str
      optional_string: Optional[str]
      json_: 'fields.Json'
      optional_json: Optional['fields.Json']
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
      Config = Config
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.NKeys']] = None,
          exclude: Optional[Iterable['types.NKeys']] = None,
          required: Optional[Iterable['types.NKeys']] = None,
          optional: Optional[Iterable['types.NKeys']] = None,
          relations: Optional[Mapping['types.NRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.NKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _N_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _N_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _N_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _N_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  for field, type_ in relations.items():
                      if field not in _N_relational_fields:
                          raise errors.UnknownRelationalFieldError('N', field)
  
                      # TODO: this method of validating types is not ideal
                      # as it means we cannot two create partial types that
                      # reference each other
                      if type_ not in _created_partial_types:
                          raise ValueError(
                              f'Unknown partial type: "{type_}". '
                              f'Did you remember to generate the {type_} type before this one?'
                          )
  
                      # TODO: support non prisma.partials models
                      info = fields[field]
                      if info['is_list']:
                          info['type'] = f'List[\'partials.{type_}\']'
                      else:
                          info['type'] = f'\'partials.{type_}\''
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid N / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class OneOptional(BaseModel):
      id: int
      many: Optional[List['models.ManyRequired']]
      int: int
      optional_int: Optional[int]
      float: float
      optional_float: Optional[float]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
      Config = Config
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.OneOptionalKeys']] = None,
          exclude: Optional[Iterable['types.OneOptionalKeys']] = None,
          required: Optional[Iterable['types.OneOptionalKeys']] = None,
          optional: Optional[Iterable['types.OneOptionalKeys']] = None,
          relations: Optional[Mapping['types.OneOptionalRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.OneOptionalKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _OneOptional_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _OneOptional_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _OneOptional_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _OneOptional_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  for field, type_ in relations.items():
                      if field not in _OneOptional_relational_fields:
                          raise errors.UnknownRelationalFieldError('OneOptional', field)
  
                      # TODO: this method of validating types is not ideal
                      # as it means we cannot two create partial types that
                      # reference each other
                      if type_ not in _created_partial_types:
                          raise ValueError(
                              f'Unknown partial type: "{type_}". '
                              f'Did you remember to generate the {type_} type before this one?'
                          )
  
                      # TODO: support non prisma.partials models
                      info = fields[field]
                      if info['is_list']:
                          info['type'] = f'List[\'partials.{type_}\']'
                      else:
                          info['type'] = f'\'partials.{type_}\''
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid OneOptional / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class ManyRequired(BaseModel):
      id: int
      one: Optional['models.OneOptional']
      one_optional_id: Optional[int]
      int: int
      optional_int: Optional[int]
      float: float
      optional_float: Optional[float]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
      Config = Config
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.ManyRequiredKeys']] = None,
          exclude: Optional[Iterable['types.ManyRequiredKeys']] = None,
          required: Optional[Iterable['types.ManyRequiredKeys']] = None,
          optional: Optional[Iterable['types.ManyRequiredKeys']] = None,
          relations: Optional[Mapping['types.ManyRequiredRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.ManyRequiredKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _ManyRequired_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _ManyRequired_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _ManyRequired_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _ManyRequired_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  for field, type_ in relations.items():
                      if field not in _ManyRequired_relational_fields:
                          raise errors.UnknownRelationalFieldError('ManyRequired', field)
  
                      # TODO: this method of validating types is not ideal
                      # as it means we cannot two create partial types that
                      # reference each other
                      if type_ not in _created_partial_types:
                          raise ValueError(
                              f'Unknown partial type: "{type_}". '
                              f'Did you remember to generate the {type_} type before this one?'
                          )
  
                      # TODO: support non prisma.partials models
                      info = fields[field]
                      if info['is_list']:
                          info['type'] = f'List[\'partials.{type_}\']'
                      else:
                          info['type'] = f'\'partials.{type_}\''
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid ManyRequired / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class A(BaseModel):
      id: str
      email: str
      name: Optional[str]
      int: int
      sInt: int
      inc_int: int
      inc_sInt: int
      bInt: int
      inc_bInt: int
  
      Config = Config
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.AKeys']] = None,
          exclude: Optional[Iterable['types.AKeys']] = None,
          required: Optional[Iterable['types.AKeys']] = None,
          optional: Optional[Iterable['types.AKeys']] = None,
          relations: Optional[Mapping['types.ARelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.AKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _A_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _A_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _A_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _A_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  raise ValueError('Model: "A" has no relational fields.')
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid A / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class B(BaseModel):
      id: str
      float: float
      d_float: float
  
      Config = Config
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.BKeys']] = None,
          exclude: Optional[Iterable['types.BKeys']] = None,
          required: Optional[Iterable['types.BKeys']] = None,
          optional: Optional[Iterable['types.BKeys']] = None,
          relations: Optional[Mapping['types.BRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.BKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _B_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _B_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _B_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _B_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  raise ValueError('Model: "B" has no relational fields.')
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid B / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class C(BaseModel):
      id: str
      char: str
      v_char: str
      text: str
      bit: str
      v_bit: str
      uuid: str
  
      Config = Config
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.CKeys']] = None,
          exclude: Optional[Iterable['types.CKeys']] = None,
          required: Optional[Iterable['types.CKeys']] = None,
          optional: Optional[Iterable['types.CKeys']] = None,
          relations: Optional[Mapping['types.CRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.CKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _C_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _C_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _C_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _C_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  raise ValueError('Model: "C" has no relational fields.')
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid C / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class D(BaseModel):
      id: str
      bool: bool
      xml: str
      json_: 'fields.Json'
      jsonb: 'fields.Json'
  
      Config = Config
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.DKeys']] = None,
          exclude: Optional[Iterable['types.DKeys']] = None,
          required: Optional[Iterable['types.DKeys']] = None,
          optional: Optional[Iterable['types.DKeys']] = None,
          relations: Optional[Mapping['types.DRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.DKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _D_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _D_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _D_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _D_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  raise ValueError('Model: "D" has no relational fields.')
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid D / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class E(BaseModel):
      id: str
      date: datetime.datetime
      time: datetime.datetime
      ts: datetime.datetime
  
      Config = Config
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.EKeys']] = None,
          exclude: Optional[Iterable['types.EKeys']] = None,
          required: Optional[Iterable['types.EKeys']] = None,
          optional: Optional[Iterable['types.EKeys']] = None,
          relations: Optional[Mapping['types.ERelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.EKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _E_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _E_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _E_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _E_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  raise ValueError('Model: "E" has no relational fields.')
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid E / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  
  _Post_relational_fields: Set[str] = {
          'author',
      }
  _Post_fields: Dict['types.PostKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'created_at': {
          'name': 'created_at',
          'is_list': False,
          'optional': False,
          'type': 'datetime.datetime',
      },
      'title': {
          'name': 'title',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'content': {
          'name': 'content',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'published': {
          'name': 'published',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'author': {
          'name': 'author',
          'is_list': False,
          'optional': True,
          'type': 'models.User',
      },
      'author_id': {
          'name': 'author_id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
  }
  
  _User_relational_fields: Set[str] = {
          'posts',
      }
  _User_fields: Dict['types.UserKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'email': {
          'name': 'email',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'int': {
          'name': 'int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'optional_int': {
          'name': 'optional_int',
          'is_list': False,
          'optional': True,
          'type': 'int',
      },
      'float': {
          'name': 'float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
      'optional_float': {
          'name': 'optional_float',
          'is_list': False,
          'optional': True,
          'type': 'float',
      },
      'string': {
          'name': 'string',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'optional_string': {
          'name': 'optional_string',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'enum': {
          'name': 'enum',
          'is_list': False,
          'optional': False,
          'type': 'enums.ABeautifulEnum',
      },
      'optional_enum': {
          'name': 'optional_enum',
          'is_list': False,
          'optional': True,
          'type': 'enums.ABeautifulEnum',
      },
      'boolean': {
          'name': 'boolean',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'optional_boolean': {
          'name': 'optional_boolean',
          'is_list': False,
          'optional': True,
          'type': 'bool',
      },
      'posts': {
          'name': 'posts',
          'is_list': True,
          'optional': True,
          'type': 'List[\'models.Post\']',
      },
  }
  
  _M_relational_fields: Set[str] = {
          'n',
      }
  _M_fields: Dict['types.MKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'n': {
          'name': 'n',
          'is_list': True,
          'optional': True,
          'type': 'List[\'models.N\']',
      },
      'int': {
          'name': 'int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'optional_int': {
          'name': 'optional_int',
          'is_list': False,
          'optional': True,
          'type': 'int',
      },
      'float': {
          'name': 'float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
      'optional_float': {
          'name': 'optional_float',
          'is_list': False,
          'optional': True,
          'type': 'float',
      },
      'string': {
          'name': 'string',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'optional_string': {
          'name': 'optional_string',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'enum': {
          'name': 'enum',
          'is_list': False,
          'optional': False,
          'type': 'enums.ABeautifulEnum',
      },
      'optional_enum': {
          'name': 'optional_enum',
          'is_list': False,
          'optional': True,
          'type': 'enums.ABeautifulEnum',
      },
      'boolean': {
          'name': 'boolean',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'optional_boolean': {
          'name': 'optional_boolean',
          'is_list': False,
          'optional': True,
          'type': 'bool',
      },
  }
  
  _N_relational_fields: Set[str] = {
          'm',
      }
  _N_fields: Dict['types.NKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'm': {
          'name': 'm',
          'is_list': True,
          'optional': True,
          'type': 'List[\'models.M\']',
      },
      'int': {
          'name': 'int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'optional_int': {
          'name': 'optional_int',
          'is_list': False,
          'optional': True,
          'type': 'int',
      },
      'float': {
          'name': 'float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
      'optional_float': {
          'name': 'optional_float',
          'is_list': False,
          'optional': True,
          'type': 'float',
      },
      'string': {
          'name': 'string',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'optional_string': {
          'name': 'optional_string',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'json_': {
          'name': 'json_',
          'is_list': False,
          'optional': False,
          'type': 'fields.Json',
      },
      'optional_json': {
          'name': 'optional_json',
          'is_list': False,
          'optional': True,
          'type': 'fields.Json',
      },
      'enum': {
          'name': 'enum',
          'is_list': False,
          'optional': False,
          'type': 'enums.ABeautifulEnum',
      },
      'optional_enum': {
          'name': 'optional_enum',
          'is_list': False,
          'optional': True,
          'type': 'enums.ABeautifulEnum',
      },
      'boolean': {
          'name': 'boolean',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'optional_boolean': {
          'name': 'optional_boolean',
          'is_list': False,
          'optional': True,
          'type': 'bool',
      },
  }
  
  _OneOptional_relational_fields: Set[str] = {
          'many',
      }
  _OneOptional_fields: Dict['types.OneOptionalKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'many': {
          'name': 'many',
          'is_list': True,
          'optional': True,
          'type': 'List[\'models.ManyRequired\']',
      },
      'int': {
          'name': 'int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'optional_int': {
          'name': 'optional_int',
          'is_list': False,
          'optional': True,
          'type': 'int',
      },
      'float': {
          'name': 'float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
      'optional_float': {
          'name': 'optional_float',
          'is_list': False,
          'optional': True,
          'type': 'float',
      },
      'string': {
          'name': 'string',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'optional_string': {
          'name': 'optional_string',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'enum': {
          'name': 'enum',
          'is_list': False,
          'optional': False,
          'type': 'enums.ABeautifulEnum',
      },
      'optional_enum': {
          'name': 'optional_enum',
          'is_list': False,
          'optional': True,
          'type': 'enums.ABeautifulEnum',
      },
      'boolean': {
          'name': 'boolean',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'optional_boolean': {
          'name': 'optional_boolean',
          'is_list': False,
          'optional': True,
          'type': 'bool',
      },
  }
  
  _ManyRequired_relational_fields: Set[str] = {
          'one',
      }
  _ManyRequired_fields: Dict['types.ManyRequiredKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'one': {
          'name': 'one',
          'is_list': False,
          'optional': True,
          'type': 'models.OneOptional',
      },
      'one_optional_id': {
          'name': 'one_optional_id',
          'is_list': False,
          'optional': True,
          'type': 'int',
      },
      'int': {
          'name': 'int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'optional_int': {
          'name': 'optional_int',
          'is_list': False,
          'optional': True,
          'type': 'int',
      },
      'float': {
          'name': 'float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
      'optional_float': {
          'name': 'optional_float',
          'is_list': False,
          'optional': True,
          'type': 'float',
      },
      'string': {
          'name': 'string',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'optional_string': {
          'name': 'optional_string',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'enum': {
          'name': 'enum',
          'is_list': False,
          'optional': False,
          'type': 'enums.ABeautifulEnum',
      },
      'optional_enum': {
          'name': 'optional_enum',
          'is_list': False,
          'optional': True,
          'type': 'enums.ABeautifulEnum',
      },
      'boolean': {
          'name': 'boolean',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'optional_boolean': {
          'name': 'optional_boolean',
          'is_list': False,
          'optional': True,
          'type': 'bool',
      },
  }
  
  _A_relational_fields: Set[str] = set()  # pyright: reportUnusedVariable=false
  _A_fields: Dict['types.AKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'email': {
          'name': 'email',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'name': {
          'name': 'name',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'int': {
          'name': 'int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'sInt': {
          'name': 'sInt',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'inc_int': {
          'name': 'inc_int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'inc_sInt': {
          'name': 'inc_sInt',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'bInt': {
          'name': 'bInt',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'inc_bInt': {
          'name': 'inc_bInt',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
  }
  
  _B_relational_fields: Set[str] = set()  # pyright: reportUnusedVariable=false
  _B_fields: Dict['types.BKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'float': {
          'name': 'float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
      'd_float': {
          'name': 'd_float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
  }
  
  _C_relational_fields: Set[str] = set()  # pyright: reportUnusedVariable=false
  _C_fields: Dict['types.CKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'char': {
          'name': 'char',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'v_char': {
          'name': 'v_char',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'text': {
          'name': 'text',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'bit': {
          'name': 'bit',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'v_bit': {
          'name': 'v_bit',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'uuid': {
          'name': 'uuid',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
  }
  
  _D_relational_fields: Set[str] = set()  # pyright: reportUnusedVariable=false
  _D_fields: Dict['types.DKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'bool': {
          'name': 'bool',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'xml': {
          'name': 'xml',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'json_': {
          'name': 'json_',
          'is_list': False,
          'optional': False,
          'type': 'fields.Json',
      },
      'jsonb': {
          'name': 'jsonb',
          'is_list': False,
          'optional': False,
          'type': 'fields.Json',
      },
  }
  
  _E_relational_fields: Set[str] = set()  # pyright: reportUnusedVariable=false
  _E_fields: Dict['types.EKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'date': {
          'name': 'date',
          'is_list': False,
          'optional': False,
          'type': 'datetime.datetime',
      },
      'time': {
          'name': 'time',
          'is_list': False,
          'optional': False,
          'type': 'datetime.datetime',
      },
      'ts': {
          'name': 'ts',
          'is_list': False,
          'optional': False,
          'type': 'datetime.datetime',
      },
  }
  
  
  
  # we have to import ourselves as relation types are namespaced to models
  # e.g. models.Post
  from . import models
  
  # required to support relationships between models
  Post.update_forward_refs()
  User.update_forward_refs()
  M.update_forward_refs()
  N.update_forward_refs()
  OneOptional.update_forward_refs()
  ManyRequired.update_forward_refs()
  A.update_forward_refs()
  B.update_forward_refs()
  C.update_forward_refs()
  D.update_forward_refs()
  E.update_forward_refs()
  
  '
---
# name: test_sync[partials.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  
  if sys.version_info >= (3, 8):
      from typing import TypedDict, Literal
  else:
      from typing_extensions import TypedDict, Literal
  
  # -- template partials.py.jinja --
  from pydantic import BaseModel, Field
  from . import types, models, fields
  
  
  
  # users can modify relational types which are then namespaced to partials.
  # so we have to import ourselves in order to resolve forward references
  from . import partials
  
  
  # fmt: on
  
  '
---
# name: test_sync[types.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  
  if sys.version_info >= (3, 8):
      from typing import TypedDict, Literal
  else:
      from typing_extensions import TypedDict, Literal
  
  # -- template types.py.jinja --
  from .utils import _NoneType
  
  
  
  # TODO: cleanup whitespace control
  # TODO: add an argument to signify that the last iteration should be skipped
  
  
  SortOrder = Literal['asc', 'desc']
  
  # types that can be serialized to json by our query builder
  Serializable = Union[
      None,
      bool,
      float,
      int,
      str,
      datetime.datetime,
      List[Any],
      Dict[None, Any],
      Dict[bool, Any],
      Dict[float, Any],
      Dict[int, Any],
      Dict[str, Any],
  ]
  
  
      
  
  StringFilter = TypedDict(
      'StringFilter',
      {
          'equals': str,
          'not_in': List[str],
          'lt': str,
          'lte': str,
          'gt': str,
          'gte': str,
          'contains': str,
          'startswith': str,
          'endswith': str,
          'in': List[str],
          'not': Union[str, 'StringFilterRecursive1'],
      },
      total=False,
  )
  
  
  StringFilterRecursive1 = TypedDict(
      'StringFilterRecursive1',
      {
          'equals': str,
          'not_in': List[str],
          'lt': str,
          'lte': str,
          'gt': str,
          'gte': str,
          'contains': str,
          'startswith': str,
          'endswith': str,
          'in': List[str],
          'not': Union[str, 'StringFilterRecursive2'],
      },
      total=False,
  )
  
  
  StringFilterRecursive2 = TypedDict(
      'StringFilterRecursive2',
      {
          'equals': str,
          'not_in': List[str],
          'lt': str,
          'lte': str,
          'gt': str,
          'gte': str,
          'contains': str,
          'startswith': str,
          'endswith': str,
          'in': List[str],
              },
      total=False,
  )
  
      
  
  DateTimeFilter = TypedDict(
      'DateTimeFilter',
      {
          'equals': datetime.datetime,
          'not_in': List[datetime.datetime],
          'lt': datetime.datetime,
          'lte': datetime.datetime,
          'gt': datetime.datetime,
          'gte': datetime.datetime,
          'in': List[datetime.datetime],
          'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
      },
      total=False,
  )
  
  
  DateTimeFilterRecursive1 = TypedDict(
      'DateTimeFilterRecursive1',
      {
          'equals': datetime.datetime,
          'not_in': List[datetime.datetime],
          'lt': datetime.datetime,
          'lte': datetime.datetime,
          'gt': datetime.datetime,
          'gte': datetime.datetime,
          'in': List[datetime.datetime],
          'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
      },
      total=False,
  )
  
  
  DateTimeFilterRecursive2 = TypedDict(
      'DateTimeFilterRecursive2',
      {
          'equals': datetime.datetime,
          'not_in': List[datetime.datetime],
          'lt': datetime.datetime,
          'lte': datetime.datetime,
          'gt': datetime.datetime,
          'gte': datetime.datetime,
          'in': List[datetime.datetime],
              },
      total=False,
  )
  
  
      
  
  BooleanFilter = TypedDict(
      'BooleanFilter',
      {
          'equals': bool,
          'not': Union[bool, 'BooleanFilterRecursive1'],
      },
      total=False,
  )
  
  
  BooleanFilterRecursive1 = TypedDict(
      'BooleanFilterRecursive1',
      {
          'equals': bool,
          'not': Union[bool, 'BooleanFilterRecursive2'],
      },
      total=False,
  )
  
  
  BooleanFilterRecursive2 = TypedDict(
      'BooleanFilterRecursive2',
      {
          'equals': bool,
              },
      total=False,
  )
  
  
      
  
  IntFilter = TypedDict(
      'IntFilter',
      {
          'equals': int,
          'not_in': List[int],
          'lt': int,
          'lte': int,
          'gt': int,
          'gte': int,
          'in': List[int],
          'not': Union[int, 'IntFilterRecursive1'],
      },
      total=False,
  )
  
  
  IntFilterRecursive1 = TypedDict(
      'IntFilterRecursive1',
      {
          'equals': int,
          'not_in': List[int],
          'lt': int,
          'lte': int,
          'gt': int,
          'gte': int,
          'in': List[int],
          'not': Union[int, 'IntFilterRecursive2'],
      },
      total=False,
  )
  
  
  IntFilterRecursive2 = TypedDict(
      'IntFilterRecursive2',
      {
          'equals': int,
          'not_in': List[int],
          'lt': int,
          'lte': int,
          'gt': int,
          'gte': int,
          'in': List[int],
              },
      total=False,
  )
  
  
  BigIntFilter = IntFilter
      
  
  FloatFilter = TypedDict(
      'FloatFilter',
      {
          'equals': float,
          'not_in': List[float],
          'lt': float,
          'lte': float,
          'gt': float,
          'gte': float,
          'in': List[float],
          'not': Union[float, 'FloatFilterRecursive1'],
      },
      total=False,
  )
  
  
  FloatFilterRecursive1 = TypedDict(
      'FloatFilterRecursive1',
      {
          'equals': float,
          'not_in': List[float],
          'lt': float,
          'lte': float,
          'gt': float,
          'gte': float,
          'in': List[float],
          'not': Union[float, 'FloatFilterRecursive2'],
      },
      total=False,
  )
  
  
  FloatFilterRecursive2 = TypedDict(
      'FloatFilterRecursive2',
      {
          'equals': float,
          'not_in': List[float],
          'lt': float,
          'lte': float,
          'gt': float,
          'gte': float,
          'in': List[float],
              },
      total=False,
  )
  
  # TODO: preview feature for improving JSON filtering
  JsonFilter = TypedDict(
      'JsonFilter',
      {
          'equals': 'fields.Json',
          'not': 'fields.Json',
      },
      total=False,
  )
  
  
  class _FloatSetInput(TypedDict):
      set: float
  
  
  class _FloatDivideInput(TypedDict):
      divide: float
  
  
  class _FloatMultiplyInput(TypedDict):
      multiply: float
  
  
  class _FloatIncrementInput(TypedDict):
      increment: float
  
  
  class _FloatDecrementInput(TypedDict):
      decrement: float
  
  
  class _IntSetInput(TypedDict):
      set: int
  
  
  class _IntDivideInput(TypedDict):
      divide: int
  
  
  class _IntMultiplyInput(TypedDict):
      multiply: int
  
  
  class _IntIncrementInput(TypedDict):
      increment: int
  
  
  class _IntDecrementInput(TypedDict):
      decrement: int
  
  
  AtomicFloatInput = Union[
      _FloatSetInput,
      _FloatDivideInput,
      _FloatMultiplyInput,
      _FloatIncrementInput,
      _FloatDecrementInput,
  ]
  AtomicIntInput = Union[
      _IntSetInput,
      _IntDivideInput,
      _IntMultiplyInput,
      _IntIncrementInput,
      _IntDecrementInput,
  ]
  AtomicBigIntInput = AtomicIntInput
  
  
  # Post types
  
  class PostOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the Post create method"""
      id: int
      created_at: datetime.datetime
      content: Optional[str]
      published: bool
      author: 'UserCreateNestedWithoutRelationsInput'
  
  
  class PostCreateInput(PostOptionalCreateInput):
      """Required arguments to the Post create method"""
      title: str
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class PostOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the Post create method, without relations"""
      id: int
      created_at: datetime.datetime
      content: Optional[str]
      published: bool
  
  
  class PostCreateWithoutRelationsInput(PostOptionalCreateWithoutRelationsInput):
      """Required arguments to the Post create method, without relations"""
      title: str
  
  
  class PostCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'PostCreateWithoutRelationsInput'
      connect: 'PostWhereUniqueInput'
  
  
  class PostCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['PostCreateWithoutRelationsInput', List['PostCreateWithoutRelationsInput']]
      connect: Union['PostWhereUniqueInput', List['PostWhereUniqueInput']]
  
  
  class PostWhereUniqueInput(TypedDict, total=False):
      """Unique Post arguments for searching"""
      id: int
  
  
  class PostUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      created_at: datetime.datetime
      title: str
      content: Optional[str]
      published: bool
      author: 'UserUpdateOneWithoutRelationsInput'
  
  
  class PostUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: Union[AtomicIntInput, int]
      created_at: datetime.datetime
      title: str
      content: Optional[str]
      published: bool
      author: 'UserUpdateOneWithoutRelationsInput'
  
  
  class PostUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['PostCreateWithoutRelationsInput']
      connect: List['PostWhereUniqueInput']
      set: List['PostWhereUniqueInput']
      disconnect: List['PostWhereUniqueInput']
      delete: List['PostWhereUniqueInput']
  
      # TODO
      # update: List['PostUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['PostUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['PostScalarWhereInput']
      # upsert: List['PostUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['PostCreateOrConnectWithoutRelationsInput']
  
  
  class PostUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'PostCreateWithoutRelationsInput'
      connect: 'PostWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'PostUpdateInput'
      # upsert: 'PostUpsertWithoutRelationsInput'
      # connectOrCreate: 'PostCreateOrConnectWithoutRelationsInput'
  
  
  class PostUpsertInput(TypedDict):
      create: 'PostCreateInput'
      update: 'PostUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class PostOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      created_at: 'SortOrder'
      title: 'SortOrder'
      content: 'SortOrder'
      published: 'SortOrder'
      author_id: 'SortOrder'
  
  
  # recursive Post types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/latest/limitations/
  
  PostRelationFilter = TypedDict(
      'PostRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class PostListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class PostInclude(TypedDict, total=False):
      """Post relational arguments"""
      author: Union[bool, 'UserArgsFromPost']
  
  
      
  
  class PostIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
      author: Union[bool, 'UserArgsFromPostRecursive1']
  
  
  class PostIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
      author: Union[bool, 'UserArgsFromPostRecursive2']
  
  
  class PostIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class PostArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyPostArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
      posts: Union[bool, 'FindManyPostArgsFromPostRecursive1']
  
  
  class UserIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
      posts: Union[bool, 'FindManyPostArgsFromPostRecursive2']
  
  
  class UserIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class UserArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyUserArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
      n: Union[bool, 'FindManyNArgsFromPostRecursive1']
  
  
  class MIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
      n: Union[bool, 'FindManyNArgsFromPostRecursive2']
  
  
  class MIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class MArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyMArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
      m: Union[bool, 'FindManyMArgsFromPostRecursive1']
  
  
  class NIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
      m: Union[bool, 'FindManyMArgsFromPostRecursive2']
  
  
  class NIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class NArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyNArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
      many: Union[bool, 'FindManyManyRequiredArgsFromPostRecursive1']
  
  
  class OneOptionalIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
      many: Union[bool, 'FindManyManyRequiredArgsFromPostRecursive2']
  
  
  class OneOptionalIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class OneOptionalArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyOneOptionalArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
      one: Union[bool, 'OneOptionalArgsFromPostRecursive1']
  
  
  class ManyRequiredIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
      one: Union[bool, 'OneOptionalArgsFromPostRecursive2']
  
  
  class ManyRequiredIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class ManyRequiredArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyManyRequiredArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class AIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class AIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class AIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class AArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyAArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class BIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class BIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class BArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyBArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class CIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class CIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class CArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyCArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class DIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class DIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class DArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyDArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class EIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class EIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class EArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyEArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyPostArgs = FindManyPostArgsFromPost
  FindFirstPostArgs = FindManyPostArgsFromPost
  
  
      
  
  class PostWhereInput(TypedDict, total=False):
      """Post arguments for searching"""
      id: Union[int, 'types.IntFilter']
      created_at: Union[datetime.datetime, 'types.DateTimeFilter']
      title: Union[str, 'types.StringFilter']
      content: Union[str, 'types.StringFilter']
      published: Union[bool, 'types.BooleanFilter']
      author: 'UserRelationFilter'
      author_id: Union[int, 'types.IntFilter']
  
      # should be noted that AND and NOT should be Union['PostWhereInputRecursive1', List['PostWhereInputRecursive1']]
      # but this causes mypy to hang \_()_/
      AND: List['PostWhereInputRecursive1']
      OR: List['PostWhereInputRecursive1']
      NOT: List['PostWhereInputRecursive1']
  
  
  class PostWhereInputRecursive1(TypedDict, total=False):
      """Post arguments for searching"""
      id: Union[int, 'types.IntFilter']
      created_at: Union[datetime.datetime, 'types.DateTimeFilter']
      title: Union[str, 'types.StringFilter']
      content: Union[str, 'types.StringFilter']
      published: Union[bool, 'types.BooleanFilter']
      author: 'UserRelationFilter'
      author_id: Union[int, 'types.IntFilter']
  
      # should be noted that AND and NOT should be Union['PostWhereInputRecursive2', List['PostWhereInputRecursive2']]
      # but this causes mypy to hang \_()_/
      AND: List['PostWhereInputRecursive2']
      OR: List['PostWhereInputRecursive2']
      NOT: List['PostWhereInputRecursive2']
  
  
  class PostWhereInputRecursive2(TypedDict, total=False):
      """Post arguments for searching"""
      id: Union[int, 'types.IntFilter']
      created_at: Union[datetime.datetime, 'types.DateTimeFilter']
      title: Union[str, 'types.StringFilter']
      content: Union[str, 'types.StringFilter']
      published: Union[bool, 'types.BooleanFilter']
      author: 'UserRelationFilter'
      author_id: Union[int, 'types.IntFilter']
  
  
  
  PostKeys = Literal[
      'id',
      'created_at',
      'title',
      'content',
      'published',
      'author',
      'author_id',
  ]
  
  PostRelationalFieldKeys = Literal[
          'author',
      ]
  
  # User types
  
  class UserOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the User create method"""
      id: int
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
      posts: 'PostCreateManyNestedWithoutRelationsInput'
  
  
  class UserCreateInput(UserOptionalCreateInput):
      """Required arguments to the User create method"""
      email: str
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class UserOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the User create method, without relations"""
      id: int
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class UserCreateWithoutRelationsInput(UserOptionalCreateWithoutRelationsInput):
      """Required arguments to the User create method, without relations"""
      email: str
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  class UserCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'UserCreateWithoutRelationsInput'
      connect: 'UserWhereUniqueInput'
  
  
  class UserCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['UserCreateWithoutRelationsInput', List['UserCreateWithoutRelationsInput']]
      connect: Union['UserWhereUniqueInput', List['UserWhereUniqueInput']]
  
  
  class UserWhereUniqueInput(TypedDict, total=False):
      """Unique User arguments for searching"""
      id: int
      email: str
  
  
  class UserUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
      posts: 'PostUpdateManyWithoutRelationsInput'
  
  
  class UserUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: Union[AtomicIntInput, int]
      email: str
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
      posts: 'PostUpdateManyWithoutRelationsInput'
  
  
  class UserUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['UserCreateWithoutRelationsInput']
      connect: List['UserWhereUniqueInput']
      set: List['UserWhereUniqueInput']
      disconnect: List['UserWhereUniqueInput']
      delete: List['UserWhereUniqueInput']
  
      # TODO
      # update: List['UserUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['UserUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['UserScalarWhereInput']
      # upsert: List['UserUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['UserCreateOrConnectWithoutRelationsInput']
  
  
  class UserUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'UserCreateWithoutRelationsInput'
      connect: 'UserWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'UserUpdateInput'
      # upsert: 'UserUpsertWithoutRelationsInput'
      # connectOrCreate: 'UserCreateOrConnectWithoutRelationsInput'
  
  
  class UserUpsertInput(TypedDict):
      create: 'UserCreateInput'
      update: 'UserUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class UserOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      email: 'SortOrder'
      int: 'SortOrder'
      optional_int: 'SortOrder'
      float: 'SortOrder'
      optional_float: 'SortOrder'
      string: 'SortOrder'
      optional_string: 'SortOrder'
      enum: 'SortOrder'
      optional_enum: 'SortOrder'
      boolean: 'SortOrder'
      optional_boolean: 'SortOrder'
  
  
  # recursive User types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/latest/limitations/
  
  UserRelationFilter = TypedDict(
      'UserRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class UserListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class UserInclude(TypedDict, total=False):
      """User relational arguments"""
      posts: Union[bool, 'FindManyPostArgsFromUser']
  
  
      
  
  class PostIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
      author: Union[bool, 'UserArgsFromUserRecursive1']
  
  
  class PostIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
      author: Union[bool, 'UserArgsFromUserRecursive2']
  
  
  class PostIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class PostArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyPostArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
      posts: Union[bool, 'FindManyPostArgsFromUserRecursive1']
  
  
  class UserIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
      posts: Union[bool, 'FindManyPostArgsFromUserRecursive2']
  
  
  class UserIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class UserArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyUserArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
      n: Union[bool, 'FindManyNArgsFromUserRecursive1']
  
  
  class MIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
      n: Union[bool, 'FindManyNArgsFromUserRecursive2']
  
  
  class MIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class MArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyMArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
      m: Union[bool, 'FindManyMArgsFromUserRecursive1']
  
  
  class NIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
      m: Union[bool, 'FindManyMArgsFromUserRecursive2']
  
  
  class NIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class NArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyNArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
      many: Union[bool, 'FindManyManyRequiredArgsFromUserRecursive1']
  
  
  class OneOptionalIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
      many: Union[bool, 'FindManyManyRequiredArgsFromUserRecursive2']
  
  
  class OneOptionalIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class OneOptionalArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyOneOptionalArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
      one: Union[bool, 'OneOptionalArgsFromUserRecursive1']
  
  
  class ManyRequiredIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
      one: Union[bool, 'OneOptionalArgsFromUserRecursive2']
  
  
  class ManyRequiredIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class ManyRequiredArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyManyRequiredArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class AIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class AIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class AIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class AArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyAArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class BIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class BIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class BArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyBArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class CIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class CIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class CArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyCArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class DIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class DIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class DArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyDArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class EIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class EIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class EArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyEArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyUserArgs = FindManyUserArgsFromUser
  FindFirstUserArgs = FindManyUserArgsFromUser
  
  
      
  
  class UserWhereInput(TypedDict, total=False):
      """User arguments for searching"""
      id: Union[int, 'types.IntFilter']
      email: Union[str, 'types.StringFilter']
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
      posts: 'PostListRelationFilter'
  
      # should be noted that AND and NOT should be Union['UserWhereInputRecursive1', List['UserWhereInputRecursive1']]
      # but this causes mypy to hang \_()_/
      AND: List['UserWhereInputRecursive1']
      OR: List['UserWhereInputRecursive1']
      NOT: List['UserWhereInputRecursive1']
  
  
  class UserWhereInputRecursive1(TypedDict, total=False):
      """User arguments for searching"""
      id: Union[int, 'types.IntFilter']
      email: Union[str, 'types.StringFilter']
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
      posts: 'PostListRelationFilter'
  
      # should be noted that AND and NOT should be Union['UserWhereInputRecursive2', List['UserWhereInputRecursive2']]
      # but this causes mypy to hang \_()_/
      AND: List['UserWhereInputRecursive2']
      OR: List['UserWhereInputRecursive2']
      NOT: List['UserWhereInputRecursive2']
  
  
  class UserWhereInputRecursive2(TypedDict, total=False):
      """User arguments for searching"""
      id: Union[int, 'types.IntFilter']
      email: Union[str, 'types.StringFilter']
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
      posts: 'PostListRelationFilter'
  
  
  
  UserKeys = Literal[
      'id',
      'email',
      'int',
      'optional_int',
      'float',
      'optional_float',
      'string',
      'optional_string',
      'enum',
      'optional_enum',
      'boolean',
      'optional_boolean',
      'posts',
  ]
  
  UserRelationalFieldKeys = Literal[
          'posts',
      ]
  
  # M types
  
  class MOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the M create method"""
      id: int
      n: 'NCreateManyNestedWithoutRelationsInput'
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class MCreateInput(MOptionalCreateInput):
      """Required arguments to the M create method"""
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class MOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the M create method, without relations"""
      id: int
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class MCreateWithoutRelationsInput(MOptionalCreateWithoutRelationsInput):
      """Required arguments to the M create method, without relations"""
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  class MCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'MCreateWithoutRelationsInput'
      connect: 'MWhereUniqueInput'
  
  
  class MCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['MCreateWithoutRelationsInput', List['MCreateWithoutRelationsInput']]
      connect: Union['MWhereUniqueInput', List['MWhereUniqueInput']]
  
  
  class MWhereUniqueInput(TypedDict, total=False):
      """Unique M arguments for searching"""
      id: int
  
  
  class MUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      n: 'NUpdateManyWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class MUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: Union[AtomicIntInput, int]
      n: 'NUpdateManyWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class MUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['MCreateWithoutRelationsInput']
      connect: List['MWhereUniqueInput']
      set: List['MWhereUniqueInput']
      disconnect: List['MWhereUniqueInput']
      delete: List['MWhereUniqueInput']
  
      # TODO
      # update: List['MUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['MUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['MScalarWhereInput']
      # upsert: List['MUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['MCreateOrConnectWithoutRelationsInput']
  
  
  class MUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'MCreateWithoutRelationsInput'
      connect: 'MWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'MUpdateInput'
      # upsert: 'MUpsertWithoutRelationsInput'
      # connectOrCreate: 'MCreateOrConnectWithoutRelationsInput'
  
  
  class MUpsertInput(TypedDict):
      create: 'MCreateInput'
      update: 'MUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class MOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      int: 'SortOrder'
      optional_int: 'SortOrder'
      float: 'SortOrder'
      optional_float: 'SortOrder'
      string: 'SortOrder'
      optional_string: 'SortOrder'
      enum: 'SortOrder'
      optional_enum: 'SortOrder'
      boolean: 'SortOrder'
      optional_boolean: 'SortOrder'
  
  
  # recursive M types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/latest/limitations/
  
  MRelationFilter = TypedDict(
      'MRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class MListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class MInclude(TypedDict, total=False):
      """M relational arguments"""
      n: Union[bool, 'FindManyNArgsFromM']
  
  
      
  
  class PostIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
      author: Union[bool, 'UserArgsFromMRecursive1']
  
  
  class PostIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
      author: Union[bool, 'UserArgsFromMRecursive2']
  
  
  class PostIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class PostArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyPostArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
      posts: Union[bool, 'FindManyPostArgsFromMRecursive1']
  
  
  class UserIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
      posts: Union[bool, 'FindManyPostArgsFromMRecursive2']
  
  
  class UserIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class UserArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyUserArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
      n: Union[bool, 'FindManyNArgsFromMRecursive1']
  
  
  class MIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
      n: Union[bool, 'FindManyNArgsFromMRecursive2']
  
  
  class MIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class MArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyMArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
      m: Union[bool, 'FindManyMArgsFromMRecursive1']
  
  
  class NIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
      m: Union[bool, 'FindManyMArgsFromMRecursive2']
  
  
  class NIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class NArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyNArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
      many: Union[bool, 'FindManyManyRequiredArgsFromMRecursive1']
  
  
  class OneOptionalIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
      many: Union[bool, 'FindManyManyRequiredArgsFromMRecursive2']
  
  
  class OneOptionalIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class OneOptionalArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyOneOptionalArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
      one: Union[bool, 'OneOptionalArgsFromMRecursive1']
  
  
  class ManyRequiredIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
      one: Union[bool, 'OneOptionalArgsFromMRecursive2']
  
  
  class ManyRequiredIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class ManyRequiredArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyManyRequiredArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class AIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class AIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class AIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class AArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyAArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class BIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class BIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class BArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyBArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class CIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class CIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class CArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyCArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class DIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class DIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class DArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyDArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class EIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class EIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class EArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyEArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyMArgs = FindManyMArgsFromM
  FindFirstMArgs = FindManyMArgsFromM
  
  
      
  
  class MWhereInput(TypedDict, total=False):
      """M arguments for searching"""
      id: Union[int, 'types.IntFilter']
      n: 'NListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['MWhereInputRecursive1', List['MWhereInputRecursive1']]
      # but this causes mypy to hang \_()_/
      AND: List['MWhereInputRecursive1']
      OR: List['MWhereInputRecursive1']
      NOT: List['MWhereInputRecursive1']
  
  
  class MWhereInputRecursive1(TypedDict, total=False):
      """M arguments for searching"""
      id: Union[int, 'types.IntFilter']
      n: 'NListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['MWhereInputRecursive2', List['MWhereInputRecursive2']]
      # but this causes mypy to hang \_()_/
      AND: List['MWhereInputRecursive2']
      OR: List['MWhereInputRecursive2']
      NOT: List['MWhereInputRecursive2']
  
  
  class MWhereInputRecursive2(TypedDict, total=False):
      """M arguments for searching"""
      id: Union[int, 'types.IntFilter']
      n: 'NListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
  
  
  MKeys = Literal[
      'id',
      'n',
      'int',
      'optional_int',
      'float',
      'optional_float',
      'string',
      'optional_string',
      'enum',
      'optional_enum',
      'boolean',
      'optional_boolean',
  ]
  
  MRelationalFieldKeys = Literal[
          'n',
      ]
  
  # N types
  
  class NOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the N create method"""
      id: int
      m: 'MCreateManyNestedWithoutRelationsInput'
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_json: Optional['fields.Json']
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class NCreateInput(NOptionalCreateInput):
      """Required arguments to the N create method"""
      int: int
      float: float
      string: str
      json_: 'fields.Json'
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class NOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the N create method, without relations"""
      id: int
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_json: Optional['fields.Json']
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class NCreateWithoutRelationsInput(NOptionalCreateWithoutRelationsInput):
      """Required arguments to the N create method, without relations"""
      int: int
      float: float
      string: str
      json_: 'fields.Json'
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  class NCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'NCreateWithoutRelationsInput'
      connect: 'NWhereUniqueInput'
  
  
  class NCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['NCreateWithoutRelationsInput', List['NCreateWithoutRelationsInput']]
      connect: Union['NWhereUniqueInput', List['NWhereUniqueInput']]
  
  
  class NWhereUniqueInput(TypedDict, total=False):
      """Unique N arguments for searching"""
      id: int
  
  
  class NUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      m: 'MUpdateManyWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      json_: 'fields.Json'
      optional_json: Optional['fields.Json']
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class NUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: Union[AtomicIntInput, int]
      m: 'MUpdateManyWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      json_: 'fields.Json'
      optional_json: Optional['fields.Json']
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class NUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['NCreateWithoutRelationsInput']
      connect: List['NWhereUniqueInput']
      set: List['NWhereUniqueInput']
      disconnect: List['NWhereUniqueInput']
      delete: List['NWhereUniqueInput']
  
      # TODO
      # update: List['NUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['NUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['NScalarWhereInput']
      # upsert: List['NUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['NCreateOrConnectWithoutRelationsInput']
  
  
  class NUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'NCreateWithoutRelationsInput'
      connect: 'NWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'NUpdateInput'
      # upsert: 'NUpsertWithoutRelationsInput'
      # connectOrCreate: 'NCreateOrConnectWithoutRelationsInput'
  
  
  class NUpsertInput(TypedDict):
      create: 'NCreateInput'
      update: 'NUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class NOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      int: 'SortOrder'
      optional_int: 'SortOrder'
      float: 'SortOrder'
      optional_float: 'SortOrder'
      string: 'SortOrder'
      optional_string: 'SortOrder'
      json_: 'SortOrder'
      optional_json: 'SortOrder'
      enum: 'SortOrder'
      optional_enum: 'SortOrder'
      boolean: 'SortOrder'
      optional_boolean: 'SortOrder'
  
  
  # recursive N types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/latest/limitations/
  
  NRelationFilter = TypedDict(
      'NRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class NListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class NInclude(TypedDict, total=False):
      """N relational arguments"""
      m: Union[bool, 'FindManyMArgsFromN']
  
  
      
  
  class PostIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
      author: Union[bool, 'UserArgsFromNRecursive1']
  
  
  class PostIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
      author: Union[bool, 'UserArgsFromNRecursive2']
  
  
  class PostIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class PostArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyPostArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
      posts: Union[bool, 'FindManyPostArgsFromNRecursive1']
  
  
  class UserIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
      posts: Union[bool, 'FindManyPostArgsFromNRecursive2']
  
  
  class UserIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class UserArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyUserArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
      n: Union[bool, 'FindManyNArgsFromNRecursive1']
  
  
  class MIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
      n: Union[bool, 'FindManyNArgsFromNRecursive2']
  
  
  class MIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class MArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyMArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
      m: Union[bool, 'FindManyMArgsFromNRecursive1']
  
  
  class NIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
      m: Union[bool, 'FindManyMArgsFromNRecursive2']
  
  
  class NIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class NArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyNArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
      many: Union[bool, 'FindManyManyRequiredArgsFromNRecursive1']
  
  
  class OneOptionalIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
      many: Union[bool, 'FindManyManyRequiredArgsFromNRecursive2']
  
  
  class OneOptionalIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class OneOptionalArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyOneOptionalArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
      one: Union[bool, 'OneOptionalArgsFromNRecursive1']
  
  
  class ManyRequiredIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
      one: Union[bool, 'OneOptionalArgsFromNRecursive2']
  
  
  class ManyRequiredIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class ManyRequiredArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyManyRequiredArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class AIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class AIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class AIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class AArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyAArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class BIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class BIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class BArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyBArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class CIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class CIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class CArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyCArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class DIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class DIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class DArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyDArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class EIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class EIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class EArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyEArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyNArgs = FindManyNArgsFromN
  FindFirstNArgs = FindManyNArgsFromN
  
  
      
  
  class NWhereInput(TypedDict, total=False):
      """N arguments for searching"""
      id: Union[int, 'types.IntFilter']
      m: 'MListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      json_: Union['fields.Json', 'types.JsonFilter']
      optional_json: Union['fields.Json', 'types.JsonFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['NWhereInputRecursive1', List['NWhereInputRecursive1']]
      # but this causes mypy to hang \_()_/
      AND: List['NWhereInputRecursive1']
      OR: List['NWhereInputRecursive1']
      NOT: List['NWhereInputRecursive1']
  
  
  class NWhereInputRecursive1(TypedDict, total=False):
      """N arguments for searching"""
      id: Union[int, 'types.IntFilter']
      m: 'MListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      json_: Union['fields.Json', 'types.JsonFilter']
      optional_json: Union['fields.Json', 'types.JsonFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['NWhereInputRecursive2', List['NWhereInputRecursive2']]
      # but this causes mypy to hang \_()_/
      AND: List['NWhereInputRecursive2']
      OR: List['NWhereInputRecursive2']
      NOT: List['NWhereInputRecursive2']
  
  
  class NWhereInputRecursive2(TypedDict, total=False):
      """N arguments for searching"""
      id: Union[int, 'types.IntFilter']
      m: 'MListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      json_: Union['fields.Json', 'types.JsonFilter']
      optional_json: Union['fields.Json', 'types.JsonFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
  
  
  NKeys = Literal[
      'id',
      'm',
      'int',
      'optional_int',
      'float',
      'optional_float',
      'string',
      'optional_string',
      'json_',
      'optional_json',
      'enum',
      'optional_enum',
      'boolean',
      'optional_boolean',
  ]
  
  NRelationalFieldKeys = Literal[
          'm',
      ]
  
  # OneOptional types
  
  class OneOptionalOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the OneOptional create method"""
      id: int
      many: 'ManyRequiredCreateManyNestedWithoutRelationsInput'
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class OneOptionalCreateInput(OneOptionalOptionalCreateInput):
      """Required arguments to the OneOptional create method"""
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class OneOptionalOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the OneOptional create method, without relations"""
      id: int
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class OneOptionalCreateWithoutRelationsInput(OneOptionalOptionalCreateWithoutRelationsInput):
      """Required arguments to the OneOptional create method, without relations"""
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  class OneOptionalCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'OneOptionalCreateWithoutRelationsInput'
      connect: 'OneOptionalWhereUniqueInput'
  
  
  class OneOptionalCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['OneOptionalCreateWithoutRelationsInput', List['OneOptionalCreateWithoutRelationsInput']]
      connect: Union['OneOptionalWhereUniqueInput', List['OneOptionalWhereUniqueInput']]
  
  
  class OneOptionalWhereUniqueInput(TypedDict, total=False):
      """Unique OneOptional arguments for searching"""
      id: int
  
  
  class OneOptionalUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      many: 'ManyRequiredUpdateManyWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class OneOptionalUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: Union[AtomicIntInput, int]
      many: 'ManyRequiredUpdateManyWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class OneOptionalUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['OneOptionalCreateWithoutRelationsInput']
      connect: List['OneOptionalWhereUniqueInput']
      set: List['OneOptionalWhereUniqueInput']
      disconnect: List['OneOptionalWhereUniqueInput']
      delete: List['OneOptionalWhereUniqueInput']
  
      # TODO
      # update: List['OneOptionalUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['OneOptionalUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['OneOptionalScalarWhereInput']
      # upsert: List['OneOptionalUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['OneOptionalCreateOrConnectWithoutRelationsInput']
  
  
  class OneOptionalUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'OneOptionalCreateWithoutRelationsInput'
      connect: 'OneOptionalWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'OneOptionalUpdateInput'
      # upsert: 'OneOptionalUpsertWithoutRelationsInput'
      # connectOrCreate: 'OneOptionalCreateOrConnectWithoutRelationsInput'
  
  
  class OneOptionalUpsertInput(TypedDict):
      create: 'OneOptionalCreateInput'
      update: 'OneOptionalUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class OneOptionalOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      int: 'SortOrder'
      optional_int: 'SortOrder'
      float: 'SortOrder'
      optional_float: 'SortOrder'
      string: 'SortOrder'
      optional_string: 'SortOrder'
      enum: 'SortOrder'
      optional_enum: 'SortOrder'
      boolean: 'SortOrder'
      optional_boolean: 'SortOrder'
  
  
  # recursive OneOptional types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/latest/limitations/
  
  OneOptionalRelationFilter = TypedDict(
      'OneOptionalRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class OneOptionalListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class OneOptionalInclude(TypedDict, total=False):
      """OneOptional relational arguments"""
      many: Union[bool, 'FindManyManyRequiredArgsFromOneOptional']
  
  
      
  
  class PostIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      author: Union[bool, 'UserArgsFromOneOptionalRecursive1']
  
  
  class PostIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      author: Union[bool, 'UserArgsFromOneOptionalRecursive2']
  
  
  class PostIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class PostArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyPostArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      posts: Union[bool, 'FindManyPostArgsFromOneOptionalRecursive1']
  
  
  class UserIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      posts: Union[bool, 'FindManyPostArgsFromOneOptionalRecursive2']
  
  
  class UserIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class UserArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyUserArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      n: Union[bool, 'FindManyNArgsFromOneOptionalRecursive1']
  
  
  class MIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      n: Union[bool, 'FindManyNArgsFromOneOptionalRecursive2']
  
  
  class MIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class MArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyMArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      m: Union[bool, 'FindManyMArgsFromOneOptionalRecursive1']
  
  
  class NIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      m: Union[bool, 'FindManyMArgsFromOneOptionalRecursive2']
  
  
  class NIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class NArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyNArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      many: Union[bool, 'FindManyManyRequiredArgsFromOneOptionalRecursive1']
  
  
  class OneOptionalIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      many: Union[bool, 'FindManyManyRequiredArgsFromOneOptionalRecursive2']
  
  
  class OneOptionalIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class OneOptionalArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyOneOptionalArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      one: Union[bool, 'OneOptionalArgsFromOneOptionalRecursive1']
  
  
  class ManyRequiredIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      one: Union[bool, 'OneOptionalArgsFromOneOptionalRecursive2']
  
  
  class ManyRequiredIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class ManyRequiredArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyManyRequiredArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class AIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class AIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class AIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class AArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyAArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class BIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class BIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class BArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyBArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class CIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class CIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class CArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyCArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class DIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class DIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class DArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyDArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class EIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class EIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class EArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyEArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyOneOptionalArgs = FindManyOneOptionalArgsFromOneOptional
  FindFirstOneOptionalArgs = FindManyOneOptionalArgsFromOneOptional
  
  
      
  
  class OneOptionalWhereInput(TypedDict, total=False):
      """OneOptional arguments for searching"""
      id: Union[int, 'types.IntFilter']
      many: 'ManyRequiredListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['OneOptionalWhereInputRecursive1', List['OneOptionalWhereInputRecursive1']]
      # but this causes mypy to hang \_()_/
      AND: List['OneOptionalWhereInputRecursive1']
      OR: List['OneOptionalWhereInputRecursive1']
      NOT: List['OneOptionalWhereInputRecursive1']
  
  
  class OneOptionalWhereInputRecursive1(TypedDict, total=False):
      """OneOptional arguments for searching"""
      id: Union[int, 'types.IntFilter']
      many: 'ManyRequiredListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['OneOptionalWhereInputRecursive2', List['OneOptionalWhereInputRecursive2']]
      # but this causes mypy to hang \_()_/
      AND: List['OneOptionalWhereInputRecursive2']
      OR: List['OneOptionalWhereInputRecursive2']
      NOT: List['OneOptionalWhereInputRecursive2']
  
  
  class OneOptionalWhereInputRecursive2(TypedDict, total=False):
      """OneOptional arguments for searching"""
      id: Union[int, 'types.IntFilter']
      many: 'ManyRequiredListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
  
  
  OneOptionalKeys = Literal[
      'id',
      'many',
      'int',
      'optional_int',
      'float',
      'optional_float',
      'string',
      'optional_string',
      'enum',
      'optional_enum',
      'boolean',
      'optional_boolean',
  ]
  
  OneOptionalRelationalFieldKeys = Literal[
          'many',
      ]
  
  # ManyRequired types
  
  class ManyRequiredOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the ManyRequired create method"""
      id: int
      one: 'OneOptionalCreateNestedWithoutRelationsInput'
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class ManyRequiredCreateInput(ManyRequiredOptionalCreateInput):
      """Required arguments to the ManyRequired create method"""
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class ManyRequiredOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the ManyRequired create method, without relations"""
      id: int
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class ManyRequiredCreateWithoutRelationsInput(ManyRequiredOptionalCreateWithoutRelationsInput):
      """Required arguments to the ManyRequired create method, without relations"""
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  class ManyRequiredCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'ManyRequiredCreateWithoutRelationsInput'
      connect: 'ManyRequiredWhereUniqueInput'
  
  
  class ManyRequiredCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['ManyRequiredCreateWithoutRelationsInput', List['ManyRequiredCreateWithoutRelationsInput']]
      connect: Union['ManyRequiredWhereUniqueInput', List['ManyRequiredWhereUniqueInput']]
  
  
  class ManyRequiredWhereUniqueInput(TypedDict, total=False):
      """Unique ManyRequired arguments for searching"""
      id: int
  
  
  class ManyRequiredUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      one: 'OneOptionalUpdateOneWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class ManyRequiredUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: Union[AtomicIntInput, int]
      one: 'OneOptionalUpdateOneWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class ManyRequiredUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['ManyRequiredCreateWithoutRelationsInput']
      connect: List['ManyRequiredWhereUniqueInput']
      set: List['ManyRequiredWhereUniqueInput']
      disconnect: List['ManyRequiredWhereUniqueInput']
      delete: List['ManyRequiredWhereUniqueInput']
  
      # TODO
      # update: List['ManyRequiredUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['ManyRequiredUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['ManyRequiredScalarWhereInput']
      # upsert: List['ManyRequiredUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['ManyRequiredCreateOrConnectWithoutRelationsInput']
  
  
  class ManyRequiredUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'ManyRequiredCreateWithoutRelationsInput'
      connect: 'ManyRequiredWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'ManyRequiredUpdateInput'
      # upsert: 'ManyRequiredUpsertWithoutRelationsInput'
      # connectOrCreate: 'ManyRequiredCreateOrConnectWithoutRelationsInput'
  
  
  class ManyRequiredUpsertInput(TypedDict):
      create: 'ManyRequiredCreateInput'
      update: 'ManyRequiredUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class ManyRequiredOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      one_optional_id: 'SortOrder'
      int: 'SortOrder'
      optional_int: 'SortOrder'
      float: 'SortOrder'
      optional_float: 'SortOrder'
      string: 'SortOrder'
      optional_string: 'SortOrder'
      enum: 'SortOrder'
      optional_enum: 'SortOrder'
      boolean: 'SortOrder'
      optional_boolean: 'SortOrder'
  
  
  # recursive ManyRequired types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/latest/limitations/
  
  ManyRequiredRelationFilter = TypedDict(
      'ManyRequiredRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class ManyRequiredListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class ManyRequiredInclude(TypedDict, total=False):
      """ManyRequired relational arguments"""
      one: Union[bool, 'OneOptionalArgsFromManyRequired']
  
  
      
  
  class PostIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      author: Union[bool, 'UserArgsFromManyRequiredRecursive1']
  
  
  class PostIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      author: Union[bool, 'UserArgsFromManyRequiredRecursive2']
  
  
  class PostIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class PostArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyPostArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      posts: Union[bool, 'FindManyPostArgsFromManyRequiredRecursive1']
  
  
  class UserIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      posts: Union[bool, 'FindManyPostArgsFromManyRequiredRecursive2']
  
  
  class UserIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class UserArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyUserArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      n: Union[bool, 'FindManyNArgsFromManyRequiredRecursive1']
  
  
  class MIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      n: Union[bool, 'FindManyNArgsFromManyRequiredRecursive2']
  
  
  class MIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class MArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyMArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      m: Union[bool, 'FindManyMArgsFromManyRequiredRecursive1']
  
  
  class NIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      m: Union[bool, 'FindManyMArgsFromManyRequiredRecursive2']
  
  
  class NIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class NArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyNArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      many: Union[bool, 'FindManyManyRequiredArgsFromManyRequiredRecursive1']
  
  
  class OneOptionalIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      many: Union[bool, 'FindManyManyRequiredArgsFromManyRequiredRecursive2']
  
  
  class OneOptionalIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class OneOptionalArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyOneOptionalArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      one: Union[bool, 'OneOptionalArgsFromManyRequiredRecursive1']
  
  
  class ManyRequiredIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      one: Union[bool, 'OneOptionalArgsFromManyRequiredRecursive2']
  
  
  class ManyRequiredIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class ManyRequiredArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyManyRequiredArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class AIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class AIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class AIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class AArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyAArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class BIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class BIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class BArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyBArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class CIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class CIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class CArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyCArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class DIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class DIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class DArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyDArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class EIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class EIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class EArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyEArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyManyRequiredArgs = FindManyManyRequiredArgsFromManyRequired
  FindFirstManyRequiredArgs = FindManyManyRequiredArgsFromManyRequired
  
  
      
  
  class ManyRequiredWhereInput(TypedDict, total=False):
      """ManyRequired arguments for searching"""
      id: Union[int, 'types.IntFilter']
      one: 'OneOptionalRelationFilter'
      one_optional_id: Union[int, 'types.IntFilter']
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['ManyRequiredWhereInputRecursive1', List['ManyRequiredWhereInputRecursive1']]
      # but this causes mypy to hang \_()_/
      AND: List['ManyRequiredWhereInputRecursive1']
      OR: List['ManyRequiredWhereInputRecursive1']
      NOT: List['ManyRequiredWhereInputRecursive1']
  
  
  class ManyRequiredWhereInputRecursive1(TypedDict, total=False):
      """ManyRequired arguments for searching"""
      id: Union[int, 'types.IntFilter']
      one: 'OneOptionalRelationFilter'
      one_optional_id: Union[int, 'types.IntFilter']
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['ManyRequiredWhereInputRecursive2', List['ManyRequiredWhereInputRecursive2']]
      # but this causes mypy to hang \_()_/
      AND: List['ManyRequiredWhereInputRecursive2']
      OR: List['ManyRequiredWhereInputRecursive2']
      NOT: List['ManyRequiredWhereInputRecursive2']
  
  
  class ManyRequiredWhereInputRecursive2(TypedDict, total=False):
      """ManyRequired arguments for searching"""
      id: Union[int, 'types.IntFilter']
      one: 'OneOptionalRelationFilter'
      one_optional_id: Union[int, 'types.IntFilter']
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
  
  
  ManyRequiredKeys = Literal[
      'id',
      'one',
      'one_optional_id',
      'int',
      'optional_int',
      'float',
      'optional_float',
      'string',
      'optional_string',
      'enum',
      'optional_enum',
      'boolean',
      'optional_boolean',
  ]
  
  ManyRequiredRelationalFieldKeys = Literal[
          'one',
      ]
  
  # A types
  
  class AOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the A create method"""
      id: str
      name: Optional[str]
      inc_int: int
      inc_sInt: int
      inc_bInt: int
  
  
  class ACreateInput(AOptionalCreateInput):
      """Required arguments to the A create method"""
      email: str
      int: int
      sInt: int
      bInt: int
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class AOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the A create method, without relations"""
      id: str
      name: Optional[str]
      inc_int: int
      inc_sInt: int
      inc_bInt: int
  
  
  class ACreateWithoutRelationsInput(AOptionalCreateWithoutRelationsInput):
      """Required arguments to the A create method, without relations"""
      email: str
      int: int
      sInt: int
      bInt: int
  
  
  class ACreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'ACreateWithoutRelationsInput'
      connect: 'AWhereUniqueInput'
  
  
  class ACreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['ACreateWithoutRelationsInput', List['ACreateWithoutRelationsInput']]
      connect: Union['AWhereUniqueInput', List['AWhereUniqueInput']]
  
  
  class AWhereUniqueInput(TypedDict, total=False):
      """Unique A arguments for searching"""
      id: str
      email: str
  
  
  class AUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      name: Optional[str]
      int: Union[AtomicIntInput, int]
      sInt: Union[AtomicIntInput, int]
      inc_int: Union[AtomicIntInput, int]
      inc_sInt: Union[AtomicIntInput, int]
      bInt: Union[AtomicBigIntInput, int]
      inc_bInt: Union[AtomicBigIntInput, int]
  
  
  class AUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: str
      email: str
      name: Optional[str]
      int: Union[AtomicIntInput, int]
      sInt: Union[AtomicIntInput, int]
      inc_int: Union[AtomicIntInput, int]
      inc_sInt: Union[AtomicIntInput, int]
      bInt: Union[AtomicBigIntInput, int]
      inc_bInt: Union[AtomicBigIntInput, int]
  
  
  class AUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['ACreateWithoutRelationsInput']
      connect: List['AWhereUniqueInput']
      set: List['AWhereUniqueInput']
      disconnect: List['AWhereUniqueInput']
      delete: List['AWhereUniqueInput']
  
      # TODO
      # update: List['AUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['AUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['AScalarWhereInput']
      # upsert: List['AUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['ACreateOrConnectWithoutRelationsInput']
  
  
  class AUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'ACreateWithoutRelationsInput'
      connect: 'AWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'AUpdateInput'
      # upsert: 'AUpsertWithoutRelationsInput'
      # connectOrCreate: 'ACreateOrConnectWithoutRelationsInput'
  
  
  class AUpsertInput(TypedDict):
      create: 'ACreateInput'
      update: 'AUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class AOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      email: 'SortOrder'
      name: 'SortOrder'
      int: 'SortOrder'
      sInt: 'SortOrder'
      inc_int: 'SortOrder'
      inc_sInt: 'SortOrder'
      bInt: 'SortOrder'
      inc_bInt: 'SortOrder'
  
  
  # recursive A types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/latest/limitations/
  
  ARelationFilter = TypedDict(
      'ARelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class AListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class AInclude(TypedDict, total=False):
      """A relational arguments"""
  
  
      
  
  class PostIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
      author: Union[bool, 'UserArgsFromARecursive1']
  
  
  class PostIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
      author: Union[bool, 'UserArgsFromARecursive2']
  
  
  class PostIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class PostArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyPostArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
      posts: Union[bool, 'FindManyPostArgsFromARecursive1']
  
  
  class UserIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
      posts: Union[bool, 'FindManyPostArgsFromARecursive2']
  
  
  class UserIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class UserArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyUserArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
      n: Union[bool, 'FindManyNArgsFromARecursive1']
  
  
  class MIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
      n: Union[bool, 'FindManyNArgsFromARecursive2']
  
  
  class MIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class MArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyMArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
      m: Union[bool, 'FindManyMArgsFromARecursive1']
  
  
  class NIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
      m: Union[bool, 'FindManyMArgsFromARecursive2']
  
  
  class NIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class NArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyNArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
      many: Union[bool, 'FindManyManyRequiredArgsFromARecursive1']
  
  
  class OneOptionalIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
      many: Union[bool, 'FindManyManyRequiredArgsFromARecursive2']
  
  
  class OneOptionalIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class OneOptionalArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyOneOptionalArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
      one: Union[bool, 'OneOptionalArgsFromARecursive1']
  
  
  class ManyRequiredIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
      one: Union[bool, 'OneOptionalArgsFromARecursive2']
  
  
  class ManyRequiredIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class ManyRequiredArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyManyRequiredArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class AIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class AIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class AIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class AArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyAArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class BIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class BIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class BArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyBArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class CIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class CIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class CArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyCArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class DIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class DIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class DArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyDArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class EIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class EIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class EArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyEArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyAArgs = FindManyAArgsFromA
  FindFirstAArgs = FindManyAArgsFromA
  
  
      
  
  class AWhereInput(TypedDict, total=False):
      """A arguments for searching"""
      id: Union[str, 'types.StringFilter']
      email: Union[str, 'types.StringFilter']
      name: Union[str, 'types.StringFilter']
      int: Union[int, 'types.IntFilter']
      sInt: Union[int, 'types.IntFilter']
      inc_int: Union[int, 'types.IntFilter']
      inc_sInt: Union[int, 'types.IntFilter']
      bInt: Union[int, 'types.BigIntFilter']
      inc_bInt: Union[int, 'types.BigIntFilter']
  
      # should be noted that AND and NOT should be Union['AWhereInputRecursive1', List['AWhereInputRecursive1']]
      # but this causes mypy to hang \_()_/
      AND: List['AWhereInputRecursive1']
      OR: List['AWhereInputRecursive1']
      NOT: List['AWhereInputRecursive1']
  
  
  class AWhereInputRecursive1(TypedDict, total=False):
      """A arguments for searching"""
      id: Union[str, 'types.StringFilter']
      email: Union[str, 'types.StringFilter']
      name: Union[str, 'types.StringFilter']
      int: Union[int, 'types.IntFilter']
      sInt: Union[int, 'types.IntFilter']
      inc_int: Union[int, 'types.IntFilter']
      inc_sInt: Union[int, 'types.IntFilter']
      bInt: Union[int, 'types.BigIntFilter']
      inc_bInt: Union[int, 'types.BigIntFilter']
  
      # should be noted that AND and NOT should be Union['AWhereInputRecursive2', List['AWhereInputRecursive2']]
      # but this causes mypy to hang \_()_/
      AND: List['AWhereInputRecursive2']
      OR: List['AWhereInputRecursive2']
      NOT: List['AWhereInputRecursive2']
  
  
  class AWhereInputRecursive2(TypedDict, total=False):
      """A arguments for searching"""
      id: Union[str, 'types.StringFilter']
      email: Union[str, 'types.StringFilter']
      name: Union[str, 'types.StringFilter']
      int: Union[int, 'types.IntFilter']
      sInt: Union[int, 'types.IntFilter']
      inc_int: Union[int, 'types.IntFilter']
      inc_sInt: Union[int, 'types.IntFilter']
      bInt: Union[int, 'types.BigIntFilter']
      inc_bInt: Union[int, 'types.BigIntFilter']
  
  
  
  AKeys = Literal[
      'id',
      'email',
      'name',
      'int',
      'sInt',
      'inc_int',
      'inc_sInt',
      'bInt',
      'inc_bInt',
  ]
  
  ARelationalFieldKeys = _NoneType
  
  # B types
  
  class BOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the B create method"""
      id: str
  
  
  class BCreateInput(BOptionalCreateInput):
      """Required arguments to the B create method"""
      float: float
      d_float: float
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class BOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the B create method, without relations"""
      id: str
  
  
  class BCreateWithoutRelationsInput(BOptionalCreateWithoutRelationsInput):
      """Required arguments to the B create method, without relations"""
      float: float
      d_float: float
  
  
  class BCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'BCreateWithoutRelationsInput'
      connect: 'BWhereUniqueInput'
  
  
  class BCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['BCreateWithoutRelationsInput', List['BCreateWithoutRelationsInput']]
      connect: Union['BWhereUniqueInput', List['BWhereUniqueInput']]
  
  
  class BWhereUniqueInput(TypedDict, total=False):
      """Unique B arguments for searching"""
      id: str
  
  
  class BUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      float: Union[AtomicFloatInput, float]
      d_float: Union[AtomicFloatInput, float]
  
  
  class BUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: str
      float: Union[AtomicFloatInput, float]
      d_float: Union[AtomicFloatInput, float]
  
  
  class BUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['BCreateWithoutRelationsInput']
      connect: List['BWhereUniqueInput']
      set: List['BWhereUniqueInput']
      disconnect: List['BWhereUniqueInput']
      delete: List['BWhereUniqueInput']
  
      # TODO
      # update: List['BUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['BUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['BScalarWhereInput']
      # upsert: List['BUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['BCreateOrConnectWithoutRelationsInput']
  
  
  class BUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'BCreateWithoutRelationsInput'
      connect: 'BWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'BUpdateInput'
      # upsert: 'BUpsertWithoutRelationsInput'
      # connectOrCreate: 'BCreateOrConnectWithoutRelationsInput'
  
  
  class BUpsertInput(TypedDict):
      create: 'BCreateInput'
      update: 'BUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class BOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      float: 'SortOrder'
      d_float: 'SortOrder'
  
  
  # recursive B types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/latest/limitations/
  
  BRelationFilter = TypedDict(
      'BRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class BListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class BInclude(TypedDict, total=False):
      """B relational arguments"""
  
  
      
  
  class PostIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
      author: Union[bool, 'UserArgsFromBRecursive1']
  
  
  class PostIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
      author: Union[bool, 'UserArgsFromBRecursive2']
  
  
  class PostIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class PostArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyPostArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
      posts: Union[bool, 'FindManyPostArgsFromBRecursive1']
  
  
  class UserIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
      posts: Union[bool, 'FindManyPostArgsFromBRecursive2']
  
  
  class UserIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class UserArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyUserArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
      n: Union[bool, 'FindManyNArgsFromBRecursive1']
  
  
  class MIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
      n: Union[bool, 'FindManyNArgsFromBRecursive2']
  
  
  class MIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class MArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyMArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
      m: Union[bool, 'FindManyMArgsFromBRecursive1']
  
  
  class NIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
      m: Union[bool, 'FindManyMArgsFromBRecursive2']
  
  
  class NIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class NArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyNArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
      many: Union[bool, 'FindManyManyRequiredArgsFromBRecursive1']
  
  
  class OneOptionalIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
      many: Union[bool, 'FindManyManyRequiredArgsFromBRecursive2']
  
  
  class OneOptionalIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class OneOptionalArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyOneOptionalArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
      one: Union[bool, 'OneOptionalArgsFromBRecursive1']
  
  
  class ManyRequiredIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
      one: Union[bool, 'OneOptionalArgsFromBRecursive2']
  
  
  class ManyRequiredIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class ManyRequiredArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyManyRequiredArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class AIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class AIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class AIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class AArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyAArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class BIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class BIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class BArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyBArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class CIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class CIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class CArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyCArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class DIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class DIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class DArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyDArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class EIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class EIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class EArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyEArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyBArgs = FindManyBArgsFromB
  FindFirstBArgs = FindManyBArgsFromB
  
  
      
  
  class BWhereInput(TypedDict, total=False):
      """B arguments for searching"""
      id: Union[str, 'types.StringFilter']
      float: Union[float, 'types.FloatFilter']
      d_float: Union[float, 'types.FloatFilter']
  
      # should be noted that AND and NOT should be Union['BWhereInputRecursive1', List['BWhereInputRecursive1']]
      # but this causes mypy to hang \_()_/
      AND: List['BWhereInputRecursive1']
      OR: List['BWhereInputRecursive1']
      NOT: List['BWhereInputRecursive1']
  
  
  class BWhereInputRecursive1(TypedDict, total=False):
      """B arguments for searching"""
      id: Union[str, 'types.StringFilter']
      float: Union[float, 'types.FloatFilter']
      d_float: Union[float, 'types.FloatFilter']
  
      # should be noted that AND and NOT should be Union['BWhereInputRecursive2', List['BWhereInputRecursive2']]
      # but this causes mypy to hang \_()_/
      AND: List['BWhereInputRecursive2']
      OR: List['BWhereInputRecursive2']
      NOT: List['BWhereInputRecursive2']
  
  
  class BWhereInputRecursive2(TypedDict, total=False):
      """B arguments for searching"""
      id: Union[str, 'types.StringFilter']
      float: Union[float, 'types.FloatFilter']
      d_float: Union[float, 'types.FloatFilter']
  
  
  
  BKeys = Literal[
      'id',
      'float',
      'd_float',
  ]
  
  BRelationalFieldKeys = _NoneType
  
  # C types
  
  class COptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the C create method"""
      id: str
  
  
  class CCreateInput(COptionalCreateInput):
      """Required arguments to the C create method"""
      char: str
      v_char: str
      text: str
      bit: str
      v_bit: str
      uuid: str
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class COptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the C create method, without relations"""
      id: str
  
  
  class CCreateWithoutRelationsInput(COptionalCreateWithoutRelationsInput):
      """Required arguments to the C create method, without relations"""
      char: str
      v_char: str
      text: str
      bit: str
      v_bit: str
      uuid: str
  
  
  class CCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'CCreateWithoutRelationsInput'
      connect: 'CWhereUniqueInput'
  
  
  class CCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['CCreateWithoutRelationsInput', List['CCreateWithoutRelationsInput']]
      connect: Union['CWhereUniqueInput', List['CWhereUniqueInput']]
  
  
  class CWhereUniqueInput(TypedDict, total=False):
      """Unique C arguments for searching"""
      id: str
  
  
  class CUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      char: str
      v_char: str
      text: str
      bit: str
      v_bit: str
      uuid: str
  
  
  class CUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: str
      char: str
      v_char: str
      text: str
      bit: str
      v_bit: str
      uuid: str
  
  
  class CUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['CCreateWithoutRelationsInput']
      connect: List['CWhereUniqueInput']
      set: List['CWhereUniqueInput']
      disconnect: List['CWhereUniqueInput']
      delete: List['CWhereUniqueInput']
  
      # TODO
      # update: List['CUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['CUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['CScalarWhereInput']
      # upsert: List['CUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['CCreateOrConnectWithoutRelationsInput']
  
  
  class CUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'CCreateWithoutRelationsInput'
      connect: 'CWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'CUpdateInput'
      # upsert: 'CUpsertWithoutRelationsInput'
      # connectOrCreate: 'CCreateOrConnectWithoutRelationsInput'
  
  
  class CUpsertInput(TypedDict):
      create: 'CCreateInput'
      update: 'CUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class COrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      char: 'SortOrder'
      v_char: 'SortOrder'
      text: 'SortOrder'
      bit: 'SortOrder'
      v_bit: 'SortOrder'
      uuid: 'SortOrder'
  
  
  # recursive C types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/latest/limitations/
  
  CRelationFilter = TypedDict(
      'CRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class CListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class CInclude(TypedDict, total=False):
      """C relational arguments"""
  
  
      
  
  class PostIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
      author: Union[bool, 'UserArgsFromCRecursive1']
  
  
  class PostIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
      author: Union[bool, 'UserArgsFromCRecursive2']
  
  
  class PostIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class PostArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyPostArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
      posts: Union[bool, 'FindManyPostArgsFromCRecursive1']
  
  
  class UserIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
      posts: Union[bool, 'FindManyPostArgsFromCRecursive2']
  
  
  class UserIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class UserArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyUserArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
      n: Union[bool, 'FindManyNArgsFromCRecursive1']
  
  
  class MIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
      n: Union[bool, 'FindManyNArgsFromCRecursive2']
  
  
  class MIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class MArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyMArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
      m: Union[bool, 'FindManyMArgsFromCRecursive1']
  
  
  class NIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
      m: Union[bool, 'FindManyMArgsFromCRecursive2']
  
  
  class NIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class NArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyNArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
      many: Union[bool, 'FindManyManyRequiredArgsFromCRecursive1']
  
  
  class OneOptionalIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
      many: Union[bool, 'FindManyManyRequiredArgsFromCRecursive2']
  
  
  class OneOptionalIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class OneOptionalArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyOneOptionalArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
      one: Union[bool, 'OneOptionalArgsFromCRecursive1']
  
  
  class ManyRequiredIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
      one: Union[bool, 'OneOptionalArgsFromCRecursive2']
  
  
  class ManyRequiredIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class ManyRequiredArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyManyRequiredArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class AIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class AIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class AIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class AArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyAArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class BIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class BIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class BArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyBArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class CIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class CIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class CArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyCArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class DIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class DIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class DArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyDArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class EIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class EIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class EArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyEArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyCArgs = FindManyCArgsFromC
  FindFirstCArgs = FindManyCArgsFromC
  
  
      
  
  class CWhereInput(TypedDict, total=False):
      """C arguments for searching"""
      id: Union[str, 'types.StringFilter']
      char: Union[str, 'types.StringFilter']
      v_char: Union[str, 'types.StringFilter']
      text: Union[str, 'types.StringFilter']
      bit: Union[str, 'types.StringFilter']
      v_bit: Union[str, 'types.StringFilter']
      uuid: Union[str, 'types.StringFilter']
  
      # should be noted that AND and NOT should be Union['CWhereInputRecursive1', List['CWhereInputRecursive1']]
      # but this causes mypy to hang \_()_/
      AND: List['CWhereInputRecursive1']
      OR: List['CWhereInputRecursive1']
      NOT: List['CWhereInputRecursive1']
  
  
  class CWhereInputRecursive1(TypedDict, total=False):
      """C arguments for searching"""
      id: Union[str, 'types.StringFilter']
      char: Union[str, 'types.StringFilter']
      v_char: Union[str, 'types.StringFilter']
      text: Union[str, 'types.StringFilter']
      bit: Union[str, 'types.StringFilter']
      v_bit: Union[str, 'types.StringFilter']
      uuid: Union[str, 'types.StringFilter']
  
      # should be noted that AND and NOT should be Union['CWhereInputRecursive2', List['CWhereInputRecursive2']]
      # but this causes mypy to hang \_()_/
      AND: List['CWhereInputRecursive2']
      OR: List['CWhereInputRecursive2']
      NOT: List['CWhereInputRecursive2']
  
  
  class CWhereInputRecursive2(TypedDict, total=False):
      """C arguments for searching"""
      id: Union[str, 'types.StringFilter']
      char: Union[str, 'types.StringFilter']
      v_char: Union[str, 'types.StringFilter']
      text: Union[str, 'types.StringFilter']
      bit: Union[str, 'types.StringFilter']
      v_bit: Union[str, 'types.StringFilter']
      uuid: Union[str, 'types.StringFilter']
  
  
  
  CKeys = Literal[
      'id',
      'char',
      'v_char',
      'text',
      'bit',
      'v_bit',
      'uuid',
  ]
  
  CRelationalFieldKeys = _NoneType
  
  # D types
  
  class DOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the D create method"""
      id: str
  
  
  class DCreateInput(DOptionalCreateInput):
      """Required arguments to the D create method"""
      bool: bool
      xml: str
      json_: 'fields.Json'
      jsonb: 'fields.Json'
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class DOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the D create method, without relations"""
      id: str
  
  
  class DCreateWithoutRelationsInput(DOptionalCreateWithoutRelationsInput):
      """Required arguments to the D create method, without relations"""
      bool: bool
      xml: str
      json_: 'fields.Json'
      jsonb: 'fields.Json'
  
  
  class DCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'DCreateWithoutRelationsInput'
      connect: 'DWhereUniqueInput'
  
  
  class DCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['DCreateWithoutRelationsInput', List['DCreateWithoutRelationsInput']]
      connect: Union['DWhereUniqueInput', List['DWhereUniqueInput']]
  
  
  class DWhereUniqueInput(TypedDict, total=False):
      """Unique D arguments for searching"""
      id: str
  
  
  class DUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      bool: bool
      xml: str
      json_: 'fields.Json'
      jsonb: 'fields.Json'
  
  
  class DUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: str
      bool: bool
      xml: str
      json_: 'fields.Json'
      jsonb: 'fields.Json'
  
  
  class DUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['DCreateWithoutRelationsInput']
      connect: List['DWhereUniqueInput']
      set: List['DWhereUniqueInput']
      disconnect: List['DWhereUniqueInput']
      delete: List['DWhereUniqueInput']
  
      # TODO
      # update: List['DUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['DUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['DScalarWhereInput']
      # upsert: List['DUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['DCreateOrConnectWithoutRelationsInput']
  
  
  class DUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'DCreateWithoutRelationsInput'
      connect: 'DWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'DUpdateInput'
      # upsert: 'DUpsertWithoutRelationsInput'
      # connectOrCreate: 'DCreateOrConnectWithoutRelationsInput'
  
  
  class DUpsertInput(TypedDict):
      create: 'DCreateInput'
      update: 'DUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class DOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      bool: 'SortOrder'
      xml: 'SortOrder'
      json_: 'SortOrder'
      jsonb: 'SortOrder'
  
  
  # recursive D types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/latest/limitations/
  
  DRelationFilter = TypedDict(
      'DRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class DListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class DInclude(TypedDict, total=False):
      """D relational arguments"""
  
  
      
  
  class PostIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
      author: Union[bool, 'UserArgsFromDRecursive1']
  
  
  class PostIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
      author: Union[bool, 'UserArgsFromDRecursive2']
  
  
  class PostIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class PostArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyPostArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
      posts: Union[bool, 'FindManyPostArgsFromDRecursive1']
  
  
  class UserIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
      posts: Union[bool, 'FindManyPostArgsFromDRecursive2']
  
  
  class UserIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class UserArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyUserArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
      n: Union[bool, 'FindManyNArgsFromDRecursive1']
  
  
  class MIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
      n: Union[bool, 'FindManyNArgsFromDRecursive2']
  
  
  class MIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class MArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyMArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
      m: Union[bool, 'FindManyMArgsFromDRecursive1']
  
  
  class NIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
      m: Union[bool, 'FindManyMArgsFromDRecursive2']
  
  
  class NIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class NArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyNArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
      many: Union[bool, 'FindManyManyRequiredArgsFromDRecursive1']
  
  
  class OneOptionalIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
      many: Union[bool, 'FindManyManyRequiredArgsFromDRecursive2']
  
  
  class OneOptionalIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class OneOptionalArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyOneOptionalArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
      one: Union[bool, 'OneOptionalArgsFromDRecursive1']
  
  
  class ManyRequiredIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
      one: Union[bool, 'OneOptionalArgsFromDRecursive2']
  
  
  class ManyRequiredIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class ManyRequiredArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyManyRequiredArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class AIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class AIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class AIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class AArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyAArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class BIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class BIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class BArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyBArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class CIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class CIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class CArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyCArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class DIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class DIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class DArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyDArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class EIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class EIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class EArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyEArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyDArgs = FindManyDArgsFromD
  FindFirstDArgs = FindManyDArgsFromD
  
  
      
  
  class DWhereInput(TypedDict, total=False):
      """D arguments for searching"""
      id: Union[str, 'types.StringFilter']
      bool: Union[bool, 'types.BooleanFilter']
      xml: Union[str, 'types.StringFilter']
      json_: Union['fields.Json', 'types.JsonFilter']
      jsonb: Union['fields.Json', 'types.JsonFilter']
  
      # should be noted that AND and NOT should be Union['DWhereInputRecursive1', List['DWhereInputRecursive1']]
      # but this causes mypy to hang \_()_/
      AND: List['DWhereInputRecursive1']
      OR: List['DWhereInputRecursive1']
      NOT: List['DWhereInputRecursive1']
  
  
  class DWhereInputRecursive1(TypedDict, total=False):
      """D arguments for searching"""
      id: Union[str, 'types.StringFilter']
      bool: Union[bool, 'types.BooleanFilter']
      xml: Union[str, 'types.StringFilter']
      json_: Union['fields.Json', 'types.JsonFilter']
      jsonb: Union['fields.Json', 'types.JsonFilter']
  
      # should be noted that AND and NOT should be Union['DWhereInputRecursive2', List['DWhereInputRecursive2']]
      # but this causes mypy to hang \_()_/
      AND: List['DWhereInputRecursive2']
      OR: List['DWhereInputRecursive2']
      NOT: List['DWhereInputRecursive2']
  
  
  class DWhereInputRecursive2(TypedDict, total=False):
      """D arguments for searching"""
      id: Union[str, 'types.StringFilter']
      bool: Union[bool, 'types.BooleanFilter']
      xml: Union[str, 'types.StringFilter']
      json_: Union['fields.Json', 'types.JsonFilter']
      jsonb: Union['fields.Json', 'types.JsonFilter']
  
  
  
  DKeys = Literal[
      'id',
      'bool',
      'xml',
      'json_',
      'jsonb',
  ]
  
  DRelationalFieldKeys = _NoneType
  
  # E types
  
  class EOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the E create method"""
      id: str
  
  
  class ECreateInput(EOptionalCreateInput):
      """Required arguments to the E create method"""
      date: datetime.datetime
      time: datetime.datetime
      ts: datetime.datetime
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class EOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the E create method, without relations"""
      id: str
  
  
  class ECreateWithoutRelationsInput(EOptionalCreateWithoutRelationsInput):
      """Required arguments to the E create method, without relations"""
      date: datetime.datetime
      time: datetime.datetime
      ts: datetime.datetime
  
  
  class ECreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'ECreateWithoutRelationsInput'
      connect: 'EWhereUniqueInput'
  
  
  class ECreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['ECreateWithoutRelationsInput', List['ECreateWithoutRelationsInput']]
      connect: Union['EWhereUniqueInput', List['EWhereUniqueInput']]
  
  
  class EWhereUniqueInput(TypedDict, total=False):
      """Unique E arguments for searching"""
      id: str
  
  
  class EUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      date: datetime.datetime
      time: datetime.datetime
      ts: datetime.datetime
  
  
  class EUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: str
      date: datetime.datetime
      time: datetime.datetime
      ts: datetime.datetime
  
  
  class EUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['ECreateWithoutRelationsInput']
      connect: List['EWhereUniqueInput']
      set: List['EWhereUniqueInput']
      disconnect: List['EWhereUniqueInput']
      delete: List['EWhereUniqueInput']
  
      # TODO
      # update: List['EUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['EUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['EScalarWhereInput']
      # upsert: List['EUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['ECreateOrConnectWithoutRelationsInput']
  
  
  class EUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'ECreateWithoutRelationsInput'
      connect: 'EWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'EUpdateInput'
      # upsert: 'EUpsertWithoutRelationsInput'
      # connectOrCreate: 'ECreateOrConnectWithoutRelationsInput'
  
  
  class EUpsertInput(TypedDict):
      create: 'ECreateInput'
      update: 'EUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class EOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      date: 'SortOrder'
      time: 'SortOrder'
      ts: 'SortOrder'
  
  
  # recursive E types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/latest/limitations/
  
  ERelationFilter = TypedDict(
      'ERelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class EListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class EInclude(TypedDict, total=False):
      """E relational arguments"""
  
  
      
  
  class PostIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
      author: Union[bool, 'UserArgsFromERecursive1']
  
  
  class PostIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
      author: Union[bool, 'UserArgsFromERecursive2']
  
  
  class PostIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class PostArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyPostArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
      posts: Union[bool, 'FindManyPostArgsFromERecursive1']
  
  
  class UserIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
      posts: Union[bool, 'FindManyPostArgsFromERecursive2']
  
  
  class UserIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class UserArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyUserArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
      n: Union[bool, 'FindManyNArgsFromERecursive1']
  
  
  class MIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
      n: Union[bool, 'FindManyNArgsFromERecursive2']
  
  
  class MIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class MArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyMArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
      m: Union[bool, 'FindManyMArgsFromERecursive1']
  
  
  class NIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
      m: Union[bool, 'FindManyMArgsFromERecursive2']
  
  
  class NIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class NArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyNArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
      many: Union[bool, 'FindManyManyRequiredArgsFromERecursive1']
  
  
  class OneOptionalIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
      many: Union[bool, 'FindManyManyRequiredArgsFromERecursive2']
  
  
  class OneOptionalIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class OneOptionalArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyOneOptionalArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
      one: Union[bool, 'OneOptionalArgsFromERecursive1']
  
  
  class ManyRequiredIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
      one: Union[bool, 'OneOptionalArgsFromERecursive2']
  
  
  class ManyRequiredIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class ManyRequiredArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyManyRequiredArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class AIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class AIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class AIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class AArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyAArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class BIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class BIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class BArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyBArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class CIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class CIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class CArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyCArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class DIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class DIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class DArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyDArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class EIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class EIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class EArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyEArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyEArgs = FindManyEArgsFromE
  FindFirstEArgs = FindManyEArgsFromE
  
  
      
  
  class EWhereInput(TypedDict, total=False):
      """E arguments for searching"""
      id: Union[str, 'types.StringFilter']
      date: Union[datetime.datetime, 'types.DateTimeFilter']
      time: Union[datetime.datetime, 'types.DateTimeFilter']
      ts: Union[datetime.datetime, 'types.DateTimeFilter']
  
      # should be noted that AND and NOT should be Union['EWhereInputRecursive1', List['EWhereInputRecursive1']]
      # but this causes mypy to hang \_()_/
      AND: List['EWhereInputRecursive1']
      OR: List['EWhereInputRecursive1']
      NOT: List['EWhereInputRecursive1']
  
  
  class EWhereInputRecursive1(TypedDict, total=False):
      """E arguments for searching"""
      id: Union[str, 'types.StringFilter']
      date: Union[datetime.datetime, 'types.DateTimeFilter']
      time: Union[datetime.datetime, 'types.DateTimeFilter']
      ts: Union[datetime.datetime, 'types.DateTimeFilter']
  
      # should be noted that AND and NOT should be Union['EWhereInputRecursive2', List['EWhereInputRecursive2']]
      # but this causes mypy to hang \_()_/
      AND: List['EWhereInputRecursive2']
      OR: List['EWhereInputRecursive2']
      NOT: List['EWhereInputRecursive2']
  
  
  class EWhereInputRecursive2(TypedDict, total=False):
      """E arguments for searching"""
      id: Union[str, 'types.StringFilter']
      date: Union[datetime.datetime, 'types.DateTimeFilter']
      time: Union[datetime.datetime, 'types.DateTimeFilter']
      ts: Union[datetime.datetime, 'types.DateTimeFilter']
  
  
  
  EKeys = Literal[
      'id',
      'date',
      'time',
      'ts',
  ]
  
  ERelationalFieldKeys = _NoneType
  
  
  
  # we have to import ourselves as types can be namespaced to types
  from . import types, enums, models, fields
  '
---
