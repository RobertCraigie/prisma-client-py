# name: test_async[actions.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Callable,
      Generic,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  from typing_extensions import TypedDict, Literal
  
  # -- template actions.py.jinja --
  import warnings
  
  from . import types, errors
  from ._types import BaseModelT
  
  
  if TYPE_CHECKING:
      from .client import Client
  
  
  class PostActions:
      def __init__(self, client: 'Client', model: Type['models.Post']) -> None:
          self._client = client
          self._model = model
  
      async def query_raw(
          self,
          query: str,
          *args: Any,
      ) -> List['models.Post']:
          """Execute a raw SQL query
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          List[prisma.models.Post]
              The records returned by the SQL query
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          users = await Post.prisma().query_raw(
              'SELECT * FROM Post WHERE id = $1',
              1103527590,
          )
          ```
          """
          return await self._client.query_raw(query, *args, model=self._model)
  
      async def query_first(
          self,
          query: str,
          *args: Any,
      ) -> Optional['models.Post']:
          """Execute a raw SQL query, returning the first result
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          prisma.models.Post
              The first record returned by the SQL query
          None
              The raw SQL query did not return any records
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          user = await Post.prisma().query_first(
              'SELECT * FROM Post WHERE created_at = $1',
              datetime.datetime.utcnow(),
          )
          ```
          """
          return await self._client.query_first(query, *args, model=self._model)
  
      async def create(
          self,
          data: types.PostCreateInput,
          include: Optional[types.PostInclude] = None
      ) -> 'models.Post':
          """Create a new Post record.
  
          Parameters
          ----------
          data
              Post record data
          include
              Specifies which relations should be loaded on the returned Post model
  
          Returns
          -------
          prisma.models.Post
              The created Post record
  
          Raises
          ------
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # create a Post record from just the required fields
          post = await Post.prisma().create(
              data={
                  # data to create a Post record
                  'title': 'dhheabfhf',
                  'author_id': 662824084,
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='createOne',
              model='Post',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      async def create_many(
          self,
          data: List[types.PostCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          """Create multiple Post records at once.
  
          This function is *not* available when using SQLite.
  
          Parameters
          ----------
          data
              List of Post record data
          skip_duplicates
              Boolean flag for ignoring unique constraint errors
  
          Returns
          -------
          int
              The total number of records created
  
          Raises
          ------
          prisma.errors.UnsupportedDatabaseError
              Attempting to query when using SQLite
          prisma.errors.UniqueViolationError
              A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          total = await Post.prisma().create_many(
              data=[
                  {
                      # data to create a Post record
                      'title': 'bbehjachib',
                      'author_id': 2035015474,
                  },
                  {
                      # data to create a Post record
                      'title': 'dgiiaaijj',
                      'author_id': 1508029952,
                  },
              ],
              skip_duplicates=True,
          )
          ```
          """
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = await self._client._execute(
              operation='mutation',
              method='createMany',
              model='Post',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def delete(
          self,
          where: types.PostWhereUniqueInput,
          include: Optional[types.PostInclude] = None
      ) -> Optional['models.Post']:
          """Delete a single Post record.
  
          Parameters
          ----------
          where
              Post filter to select the record to be deleted, must be unique
          include
              Specifies which relations should be loaded on the returned Post model
  
          Returns
          -------
          prisma.models.Post
              The deleted Post record
          None
              Could not find a record to delete
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          post = await Post.prisma().delete(
              where={
                  'id': 486256185,
              },
          )
          ```
          """
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='Post',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      async def find_unique(
          self,
          where: types.PostWhereUniqueInput,
          include: Optional[types.PostInclude] = None
      ) -> Optional['models.Post']:
          """Find a unique Post record.
  
          Parameters
          ----------
          where
              Post filter to find the record, must be unique
          include
              Specifies which relations should be loaded on the returned Post model
  
          Returns
          -------
          prisma.models.Post
              The found Post record
          None
              No record matching the given input could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          post = await Post.prisma().find_unique(
              where={
                  'id': 1062517886,
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findUnique',
              model='Post',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      async def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.PostWhereInput] = None,
          cursor: Optional[types.PostWhereUniqueInput] = None,
          include: Optional[types.PostInclude] = None,
          order: Optional[Union[types.PostOrderByInput, List[types.PostOrderByInput]]] = None,
      ) -> List['models.Post']:
          """Find multiple Post records.
  
          An empty list is returned if no records could be found.
  
          Parameters
          ----------
          take
              Limit the maximum number of Post records returned
          skip
              Ignore the first N results
          where
              Post filter to select records
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned Post model
          order
              Order the returned Post records by any field
  
          Returns
          -------
          List[prisma.models.Post]
              The list of all Post records that could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the first 10 Post records
          posts = await Post.prisma().find_many(take=10)
  
          # find the first 5 Post records ordered by the title field
          posts = await Post.prisma().find_many(
              take=5,
              order={
                  'title': 'desc',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findMany',
              model='Post',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [self._model.parse_obj(r) for r in resp['data']['result']]
  
      async def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.PostWhereInput] = None,
          cursor: Optional[types.PostWhereUniqueInput] = None,
          include: Optional[types.PostInclude] = None,
          order: Optional[Union[types.PostOrderByInput, List[types.PostOrderByInput]]] = None,
      ) -> Optional['models.Post']:
          """Find a single Post record.
  
          Parameters
          ----------
          skip
              Ignore the first N records
          where
              Post filter to select the record
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned Post model
          order
              Order the returned Post records by any field
  
          Returns
          -------
          prisma.models.Post
              The first Post record found, matching the given arguments
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the second Post record ordered by the content field
          post = await Post.prisma().find_first(
              skip=1,
              order={
                  'content': 'desc',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findFirst',
              model='Post',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      async def update(
          self,
          data: types.PostUpdateInput,
          where: types.PostWhereUniqueInput,
          include: Optional[types.PostInclude] = None
      ) -> Optional['models.Post']:
          """Update a single Post record.
  
          Parameters
          ----------
          data
              Post record data specifying what to update
          where
              Post filter to select the unique record to create / update
          include
              Specifies which relations should be loaded on the returned Post model
  
          Returns
          -------
          prisma.models.Post
              The updated Post record
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          post = await Post.prisma().update(
              where={
                  'id': 267834847,
              },
              data={
                  # data to update the Post record to
              },
          )
          ```
          """
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='Post',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      async def upsert(
          self,
          where: types.PostWhereUniqueInput,
          data: types.PostUpsertInput,
          include: Optional[types.PostInclude] = None,
      ) -> 'models.Post':
          """Updates an existing record or create a new one
  
          Parameters
          ----------
          where
              Post filter to select the unique record to create / update
          data
              Data specifying what fields to set on create and update
          include
              Specifies which relations should be loaded on the returned Post model
  
          Returns
          -------
          prisma.models.Post
              The created or updated Post record
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          post = await Post.prisma().upsert(
              where={
                  'id': 180171308,
              },
              data={
                  'create': {
                      'id': 180171308,
                      'title': 'dgiiaaijj',
                      'author_id': 1508029952,
                  },
                  'update': {
                      'title': 'dgiiaaijj',
                      'author_id': 1508029952,
                  },
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='Post',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      async def update_many(
          self,
          data: types.PostUpdateManyMutationInput,
          where: types.PostWhereInput,
      ) -> int:
          """Update multiple Post records
  
          Parameters
          ----------
          data
              Post data to update the selected Post records to
          where
              Filter to select the Post records to update
  
          Returns
          -------
          int
              The total number of Post records that were updated
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # update all Post records
          total = await Post.prisma().update_many(
              data={
                  'published': False
              },
              where={}
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='updateMany',
              model='Post',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      @overload
      async def count(
          self,
          select: None = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.PostWhereInput] = None,
          cursor: Optional[types.PostWhereUniqueInput] = None,
          order: Optional[Union[types.PostOrderByInput, List[types.PostOrderByInput]]] = None,
      ) -> int:
          """Count the number of Post records present in the database
  
          Parameters
          ----------
          select
              Select the Post fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              Post filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.PostCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = await Post.prisma().count()
  
          # results: prisma.types.PostCountAggregateOutput
          results = await Post.prisma().count(
              select={
                  '_all': True,
                  'author_id': True,
              },
          )
          ```
          """
  
  
      @overload
      async def count(
          self,
          select: types.PostCountAggregateInput,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.PostWhereInput] = None,
          cursor: Optional[types.PostWhereUniqueInput] = None,
          order: Optional[Union[types.PostOrderByInput, List[types.PostOrderByInput]]] = None,
      ) -> types.PostCountAggregateOutput:
          ...
  
      async def count(
          self,
          select: Optional[types.PostCountAggregateInput] = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.PostWhereInput] = None,
          cursor: Optional[types.PostWhereUniqueInput] = None,
          order: Optional[Union[types.PostOrderByInput, List[types.PostOrderByInput]]] = None,
      ) -> Union[int, types.PostCountAggregateOutput]:
          """Count the number of Post records present in the database
  
          Parameters
          ----------
          select
              Select the Post fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              Post filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.PostCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = await Post.prisma().count()
  
          # results: prisma.types.PostCountAggregateOutput
          results = await Post.prisma().count(
              select={
                  '_all': True,
                  'id': True,
              },
          )
          ```
          """
  
          # TODO: this selection building should be moved to the QueryBuilder
          #
          # note the distinction between checking for `not select` here and `select is None`
          # later is to handle the case that the given select dictionary is empty, this
          # is a limitation of our types.
          if not select:
              root_selection = ['_count { _all }']
          else:
  
              root_selection = [
                  '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
              ]
  
          if order is not None:
              warnings.warn(
                  'The `order` argument is redundant and will be removed in the next release',
                  DeprecationWarning,
                  stacklevel=2,
              )
  
          resp = await self._client._execute(
              operation='query',
              method='aggregate',
              model='Post',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=root_selection,
          )
  
          if select is None:
              return cast(int, resp['data']['result']['_count']['_all'])
          else:
              return cast(types.PostCountAggregateOutput, resp['data']['result']['_count'])
  
      async def delete_many(
          self,
          where: Optional[types.PostWhereInput] = None
      ) -> int:
          """Delete multiple Post records.
  
          Parameters
          ----------
          where
              Optional Post filter to find the records to be deleted
  
          Returns
          -------
          int
              The total number of Post records that were deleted
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # delete all Post records
          total = await Post.prisma().delete_many()
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='Post',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  class UserActions:
      def __init__(self, client: 'Client', model: Type['models.User']) -> None:
          self._client = client
          self._model = model
  
      async def query_raw(
          self,
          query: str,
          *args: Any,
      ) -> List['models.User']:
          """Execute a raw SQL query
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          List[prisma.models.User]
              The records returned by the SQL query
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          users = await User.prisma().query_raw(
              'SELECT * FROM User WHERE id = $1',
              595337866,
          )
          ```
          """
          return await self._client.query_raw(query, *args, model=self._model)
  
      async def query_first(
          self,
          query: str,
          *args: Any,
      ) -> Optional['models.User']:
          """Execute a raw SQL query, returning the first result
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          prisma.models.User
              The first record returned by the SQL query
          None
              The raw SQL query did not return any records
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          user = await User.prisma().query_first(
              'SELECT * FROM User WHERE email = $1',
              'hjaecfifb',
          )
          ```
          """
          return await self._client.query_first(query, *args, model=self._model)
  
      async def create(
          self,
          data: types.UserCreateInput,
          include: Optional[types.UserInclude] = None
      ) -> 'models.User':
          """Create a new User record.
  
          Parameters
          ----------
          data
              User record data
          include
              Specifies which relations should be loaded on the returned User model
  
          Returns
          -------
          prisma.models.User
              The created User record
  
          Raises
          ------
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # create a User record from just the required fields
          user = await User.prisma().create(
              data={
                  # data to create a User record
                  'email': 'cbbbjbfcii',
                  'int': 1149758321,
                  'float': 1644289366.138829,
                  'string': 'bgehebiafc',
                  'enum': enums.ABeautifulEnum.A,
                  'boolean': False,
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='createOne',
              model='User',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      async def create_many(
          self,
          data: List[types.UserCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          """Create multiple User records at once.
  
          This function is *not* available when using SQLite.
  
          Parameters
          ----------
          data
              List of User record data
          skip_duplicates
              Boolean flag for ignoring unique constraint errors
  
          Returns
          -------
          int
              The total number of records created
  
          Raises
          ------
          prisma.errors.UnsupportedDatabaseError
              Attempting to query when using SQLite
          prisma.errors.UniqueViolationError
              A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          total = await User.prisma().create_many(
              data=[
                  {
                      # data to create a User record
                      'email': 'bhghchehcc',
                      'int': 326272115,
                      'float': 1343201072.67578,
                      'string': 'heejgedji',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': False,
                  },
                  {
                      # data to create a User record
                      'email': 'bbbgbhfjge',
                      'int': 861472101,
                      'float': 1303003706.168663,
                      'string': 'caaaedabfc',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': False,
                  },
              ],
              skip_duplicates=True,
          )
          ```
          """
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = await self._client._execute(
              operation='mutation',
              method='createMany',
              model='User',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def delete(
          self,
          where: types.UserWhereUniqueInput,
          include: Optional[types.UserInclude] = None
      ) -> Optional['models.User']:
          """Delete a single User record.
  
          Parameters
          ----------
          where
              User filter to select the record to be deleted, must be unique
          include
              Specifies which relations should be loaded on the returned User model
  
          Returns
          -------
          prisma.models.User
              The deleted User record
          None
              Could not find a record to delete
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          user = await User.prisma().delete(
              where={
                  'id': 1860847622,
              },
          )
          ```
          """
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='User',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      async def find_unique(
          self,
          where: types.UserWhereUniqueInput,
          include: Optional[types.UserInclude] = None
      ) -> Optional['models.User']:
          """Find a unique User record.
  
          Parameters
          ----------
          where
              User filter to find the record, must be unique
          include
              Specifies which relations should be loaded on the returned User model
  
          Returns
          -------
          prisma.models.User
              The found User record
          None
              No record matching the given input could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          user = await User.prisma().find_unique(
              where={
                  'id': 1448521415,
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findUnique',
              model='User',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      async def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.UserWhereInput] = None,
          cursor: Optional[types.UserWhereUniqueInput] = None,
          include: Optional[types.UserInclude] = None,
          order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
      ) -> List['models.User']:
          """Find multiple User records.
  
          An empty list is returned if no records could be found.
  
          Parameters
          ----------
          take
              Limit the maximum number of User records returned
          skip
              Ignore the first N results
          where
              User filter to select records
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned User model
          order
              Order the returned User records by any field
  
          Returns
          -------
          List[prisma.models.User]
              The list of all User records that could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the first 10 User records
          users = await User.prisma().find_many(take=10)
  
          # find the first 5 User records ordered by the int field
          users = await User.prisma().find_many(
              take=5,
              order={
                  'int': 'desc',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findMany',
              model='User',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [self._model.parse_obj(r) for r in resp['data']['result']]
  
      async def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.UserWhereInput] = None,
          cursor: Optional[types.UserWhereUniqueInput] = None,
          include: Optional[types.UserInclude] = None,
          order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
      ) -> Optional['models.User']:
          """Find a single User record.
  
          Parameters
          ----------
          skip
              Ignore the first N records
          where
              User filter to select the record
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned User model
          order
              Order the returned User records by any field
  
          Returns
          -------
          prisma.models.User
              The first User record found, matching the given arguments
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the second User record ordered by the optional_int field
          user = await User.prisma().find_first(
              skip=1,
              order={
                  'optional_int': 'desc',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findFirst',
              model='User',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      async def update(
          self,
          data: types.UserUpdateInput,
          where: types.UserWhereUniqueInput,
          include: Optional[types.UserInclude] = None
      ) -> Optional['models.User']:
          """Update a single User record.
  
          Parameters
          ----------
          data
              User record data specifying what to update
          where
              User filter to select the unique record to create / update
          include
              Specifies which relations should be loaded on the returned User model
  
          Returns
          -------
          prisma.models.User
              The updated User record
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          user = await User.prisma().update(
              where={
                  'id': 1628650740,
              },
              data={
                  # data to update the User record to
              },
          )
          ```
          """
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='User',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      async def upsert(
          self,
          where: types.UserWhereUniqueInput,
          data: types.UserUpsertInput,
          include: Optional[types.UserInclude] = None,
      ) -> 'models.User':
          """Updates an existing record or create a new one
  
          Parameters
          ----------
          where
              User filter to select the unique record to create / update
          data
              Data specifying what fields to set on create and update
          include
              Specifies which relations should be loaded on the returned User model
  
          Returns
          -------
          prisma.models.User
              The created or updated User record
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          user = await User.prisma().upsert(
              where={
                  'id': 1249606685,
              },
              data={
                  'create': {
                      'id': 1249606685,
                      'email': 'bbbgbhfjge',
                      'int': 861472101,
                      'float': 1303003706.168663,
                      'string': 'caaaedabfc',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': False,
                  },
                  'update': {
                      'email': 'bbbgbhfjge',
                      'int': 861472101,
                      'float': 1303003706.168663,
                      'string': 'caaaedabfc',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': False,
                  },
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='User',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      async def update_many(
          self,
          data: types.UserUpdateManyMutationInput,
          where: types.UserWhereInput,
      ) -> int:
          """Update multiple User records
  
          Parameters
          ----------
          data
              User data to update the selected User records to
          where
              Filter to select the User records to update
  
          Returns
          -------
          int
              The total number of User records that were updated
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # update all User records
          total = await User.prisma().update_many(
              data={
                  'float': 835903122.76371
              },
              where={}
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='updateMany',
              model='User',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      @overload
      async def count(
          self,
          select: None = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.UserWhereInput] = None,
          cursor: Optional[types.UserWhereUniqueInput] = None,
          order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
      ) -> int:
          """Count the number of User records present in the database
  
          Parameters
          ----------
          select
              Select the User fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              User filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.UserCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = await User.prisma().count()
  
          # results: prisma.types.UserCountAggregateOutput
          results = await User.prisma().count(
              select={
                  '_all': True,
                  'optional_float': True,
              },
          )
          ```
          """
  
  
      @overload
      async def count(
          self,
          select: types.UserCountAggregateInput,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.UserWhereInput] = None,
          cursor: Optional[types.UserWhereUniqueInput] = None,
          order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
      ) -> types.UserCountAggregateOutput:
          ...
  
      async def count(
          self,
          select: Optional[types.UserCountAggregateInput] = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.UserWhereInput] = None,
          cursor: Optional[types.UserWhereUniqueInput] = None,
          order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
      ) -> Union[int, types.UserCountAggregateOutput]:
          """Count the number of User records present in the database
  
          Parameters
          ----------
          select
              Select the User fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              User filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.UserCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = await User.prisma().count()
  
          # results: prisma.types.UserCountAggregateOutput
          results = await User.prisma().count(
              select={
                  '_all': True,
                  'string': True,
              },
          )
          ```
          """
  
          # TODO: this selection building should be moved to the QueryBuilder
          #
          # note the distinction between checking for `not select` here and `select is None`
          # later is to handle the case that the given select dictionary is empty, this
          # is a limitation of our types.
          if not select:
              root_selection = ['_count { _all }']
          else:
  
              root_selection = [
                  '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
              ]
  
          if order is not None:
              warnings.warn(
                  'The `order` argument is redundant and will be removed in the next release',
                  DeprecationWarning,
                  stacklevel=2,
              )
  
          resp = await self._client._execute(
              operation='query',
              method='aggregate',
              model='User',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=root_selection,
          )
  
          if select is None:
              return cast(int, resp['data']['result']['_count']['_all'])
          else:
              return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])
  
      async def delete_many(
          self,
          where: Optional[types.UserWhereInput] = None
      ) -> int:
          """Delete multiple User records.
  
          Parameters
          ----------
          where
              Optional User filter to find the records to be deleted
  
          Returns
          -------
          int
              The total number of User records that were deleted
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # delete all User records
          total = await User.prisma().delete_many()
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='User',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  class MActions:
      def __init__(self, client: 'Client', model: Type['models.M']) -> None:
          self._client = client
          self._model = model
  
      async def query_raw(
          self,
          query: str,
          *args: Any,
      ) -> List['models.M']:
          """Execute a raw SQL query
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          List[prisma.models.M]
              The records returned by the SQL query
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          users = await M.prisma().query_raw(
              'SELECT * FROM M WHERE id = $1',
              429995104,
          )
          ```
          """
          return await self._client.query_raw(query, *args, model=self._model)
  
      async def query_first(
          self,
          query: str,
          *args: Any,
      ) -> Optional['models.M']:
          """Execute a raw SQL query, returning the first result
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          prisma.models.M
              The first record returned by the SQL query
          None
              The raw SQL query did not return any records
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          user = await M.prisma().query_first(
              'SELECT * FROM M WHERE int = $1',
              1775811865,
          )
          ```
          """
          return await self._client.query_first(query, *args, model=self._model)
  
      async def create(
          self,
          data: types.MCreateInput,
          include: Optional[types.MInclude] = None
      ) -> 'models.M':
          """Create a new M record.
  
          Parameters
          ----------
          data
              M record data
          include
              Specifies which relations should be loaded on the returned M model
  
          Returns
          -------
          prisma.models.M
              The created M record
  
          Raises
          ------
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # create a M record from just the required fields
          m = await M.prisma().create(
              data={
                  # data to create a M record
                  'int': 893145566,
                  'float': 995405759.210273,
                  'string': 'chbfcacbd',
                  'enum': enums.ABeautifulEnum.A,
                  'boolean': True,
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='createOne',
              model='M',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      async def create_many(
          self,
          data: List[types.MCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          """Create multiple M records at once.
  
          This function is *not* available when using SQLite.
  
          Parameters
          ----------
          data
              List of M record data
          skip_duplicates
              Boolean flag for ignoring unique constraint errors
  
          Returns
          -------
          int
              The total number of records created
  
          Raises
          ------
          prisma.errors.UnsupportedDatabaseError
              Attempting to query when using SQLite
          prisma.errors.UniqueViolationError
              A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          total = await M.prisma().create_many(
              data=[
                  {
                      # data to create a M record
                      'int': 2058258651,
                      'float': 1583689592.87844,
                      'string': 'bghfciaafe',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': False,
                  },
                  {
                      # data to create a M record
                      'int': 2054802212,
                      'float': 60335757.68446,
                      'string': 'bgcffadich',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': True,
                  },
              ],
              skip_duplicates=True,
          )
          ```
          """
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = await self._client._execute(
              operation='mutation',
              method='createMany',
              model='M',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def delete(
          self,
          where: types.MWhereUniqueInput,
          include: Optional[types.MInclude] = None
      ) -> Optional['models.M']:
          """Delete a single M record.
  
          Parameters
          ----------
          where
              M filter to select the record to be deleted, must be unique
          include
              Specifies which relations should be loaded on the returned M model
  
          Returns
          -------
          prisma.models.M
              The deleted M record
          None
              Could not find a record to delete
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          m = await M.prisma().delete(
              where={
                  'id': 1266032265,
              },
          )
          ```
          """
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='M',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      async def find_unique(
          self,
          where: types.MWhereUniqueInput,
          include: Optional[types.MInclude] = None
      ) -> Optional['models.M']:
          """Find a unique M record.
  
          Parameters
          ----------
          where
              M filter to find the record, must be unique
          include
              Specifies which relations should be loaded on the returned M model
  
          Returns
          -------
          prisma.models.M
              The found M record
          None
              No record matching the given input could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          m = await M.prisma().find_unique(
              where={
                  'id': 93253262,
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findUnique',
              model='M',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      async def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.MWhereInput] = None,
          cursor: Optional[types.MWhereUniqueInput] = None,
          include: Optional[types.MInclude] = None,
          order: Optional[Union[types.MOrderByInput, List[types.MOrderByInput]]] = None,
      ) -> List['models.M']:
          """Find multiple M records.
  
          An empty list is returned if no records could be found.
  
          Parameters
          ----------
          take
              Limit the maximum number of M records returned
          skip
              Ignore the first N results
          where
              M filter to select records
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned M model
          order
              Order the returned M records by any field
  
          Returns
          -------
          List[prisma.models.M]
              The list of all M records that could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the first 10 M records
          ms = await M.prisma().find_many(take=10)
  
          # find the first 5 M records ordered by the optional_int field
          ms = await M.prisma().find_many(
              take=5,
              order={
                  'optional_int': 'desc',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findMany',
              model='M',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [self._model.parse_obj(r) for r in resp['data']['result']]
  
      async def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.MWhereInput] = None,
          cursor: Optional[types.MWhereUniqueInput] = None,
          include: Optional[types.MInclude] = None,
          order: Optional[Union[types.MOrderByInput, List[types.MOrderByInput]]] = None,
      ) -> Optional['models.M']:
          """Find a single M record.
  
          Parameters
          ----------
          skip
              Ignore the first N records
          where
              M filter to select the record
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned M model
          order
              Order the returned M records by any field
  
          Returns
          -------
          prisma.models.M
              The first M record found, matching the given arguments
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the second M record ordered by the float field
          m = await M.prisma().find_first(
              skip=1,
              order={
                  'float': 'desc',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findFirst',
              model='M',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      async def update(
          self,
          data: types.MUpdateInput,
          where: types.MWhereUniqueInput,
          include: Optional[types.MInclude] = None
      ) -> Optional['models.M']:
          """Update a single M record.
  
          Parameters
          ----------
          data
              M record data specifying what to update
          where
              M filter to select the unique record to create / update
          include
              Specifies which relations should be loaded on the returned M model
  
          Returns
          -------
          prisma.models.M
              The updated M record
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          m = await M.prisma().update(
              where={
                  'id': 2053047983,
              },
              data={
                  # data to update the M record to
              },
          )
          ```
          """
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='M',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      async def upsert(
          self,
          where: types.MWhereUniqueInput,
          data: types.MUpsertInput,
          include: Optional[types.MInclude] = None,
      ) -> 'models.M':
          """Updates an existing record or create a new one
  
          Parameters
          ----------
          where
              M filter to select the unique record to create / update
          data
              Data specifying what fields to set on create and update
          include
              Specifies which relations should be loaded on the returned M model
  
          Returns
          -------
          prisma.models.M
              The created or updated M record
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          m = await M.prisma().upsert(
              where={
                  'id': 685333180,
              },
              data={
                  'create': {
                      'id': 685333180,
                      'int': 2054802212,
                      'float': 60335757.68446,
                      'string': 'bgcffadich',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': True,
                  },
                  'update': {
                      'int': 2054802212,
                      'float': 60335757.68446,
                      'string': 'bgcffadich',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': True,
                  },
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='M',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      async def update_many(
          self,
          data: types.MUpdateManyMutationInput,
          where: types.MWhereInput,
      ) -> int:
          """Update multiple M records
  
          Parameters
          ----------
          data
              M data to update the selected M records to
          where
              Filter to select the M records to update
  
          Returns
          -------
          int
              The total number of M records that were updated
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # update all M records
          total = await M.prisma().update_many(
              data={
                  'optional_float': 127474245.94892
              },
              where={}
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='updateMany',
              model='M',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      @overload
      async def count(
          self,
          select: None = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.MWhereInput] = None,
          cursor: Optional[types.MWhereUniqueInput] = None,
          order: Optional[Union[types.MOrderByInput, List[types.MOrderByInput]]] = None,
      ) -> int:
          """Count the number of M records present in the database
  
          Parameters
          ----------
          select
              Select the M fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              M filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.MCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = await M.prisma().count()
  
          # results: prisma.types.MCountAggregateOutput
          results = await M.prisma().count(
              select={
                  '_all': True,
                  'string': True,
              },
          )
          ```
          """
  
  
      @overload
      async def count(
          self,
          select: types.MCountAggregateInput,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.MWhereInput] = None,
          cursor: Optional[types.MWhereUniqueInput] = None,
          order: Optional[Union[types.MOrderByInput, List[types.MOrderByInput]]] = None,
      ) -> types.MCountAggregateOutput:
          ...
  
      async def count(
          self,
          select: Optional[types.MCountAggregateInput] = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.MWhereInput] = None,
          cursor: Optional[types.MWhereUniqueInput] = None,
          order: Optional[Union[types.MOrderByInput, List[types.MOrderByInput]]] = None,
      ) -> Union[int, types.MCountAggregateOutput]:
          """Count the number of M records present in the database
  
          Parameters
          ----------
          select
              Select the M fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              M filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.MCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = await M.prisma().count()
  
          # results: prisma.types.MCountAggregateOutput
          results = await M.prisma().count(
              select={
                  '_all': True,
                  'optional_string': True,
              },
          )
          ```
          """
  
          # TODO: this selection building should be moved to the QueryBuilder
          #
          # note the distinction between checking for `not select` here and `select is None`
          # later is to handle the case that the given select dictionary is empty, this
          # is a limitation of our types.
          if not select:
              root_selection = ['_count { _all }']
          else:
  
              root_selection = [
                  '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
              ]
  
          if order is not None:
              warnings.warn(
                  'The `order` argument is redundant and will be removed in the next release',
                  DeprecationWarning,
                  stacklevel=2,
              )
  
          resp = await self._client._execute(
              operation='query',
              method='aggregate',
              model='M',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=root_selection,
          )
  
          if select is None:
              return cast(int, resp['data']['result']['_count']['_all'])
          else:
              return cast(types.MCountAggregateOutput, resp['data']['result']['_count'])
  
      async def delete_many(
          self,
          where: Optional[types.MWhereInput] = None
      ) -> int:
          """Delete multiple M records.
  
          Parameters
          ----------
          where
              Optional M filter to find the records to be deleted
  
          Returns
          -------
          int
              The total number of M records that were deleted
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # delete all M records
          total = await M.prisma().delete_many()
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='M',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  class NActions:
      def __init__(self, client: 'Client', model: Type['models.N']) -> None:
          self._client = client
          self._model = model
  
      async def query_raw(
          self,
          query: str,
          *args: Any,
      ) -> List['models.N']:
          """Execute a raw SQL query
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          List[prisma.models.N]
              The records returned by the SQL query
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          users = await N.prisma().query_raw(
              'SELECT * FROM N WHERE id = $1',
              1964990155,
          )
          ```
          """
          return await self._client.query_raw(query, *args, model=self._model)
  
      async def query_first(
          self,
          query: str,
          *args: Any,
      ) -> Optional['models.N']:
          """Execute a raw SQL query, returning the first result
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          prisma.models.N
              The first record returned by the SQL query
          None
              The raw SQL query did not return any records
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          user = await N.prisma().query_first(
              'SELECT * FROM N WHERE int = $1',
              1228891816,
          )
          ```
          """
          return await self._client.query_first(query, *args, model=self._model)
  
      async def create(
          self,
          data: types.NCreateInput,
          include: Optional[types.NInclude] = None
      ) -> 'models.N':
          """Create a new N record.
  
          Parameters
          ----------
          data
              N record data
          include
              Specifies which relations should be loaded on the returned N model
  
          Returns
          -------
          prisma.models.N
              The created N record
  
          Raises
          ------
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # create a N record from just the required fields
          n = await N.prisma().create(
              data={
                  # data to create a N record
                  'int': 255202753,
                  'float': 1223573862.54126,
                  'string': 'bageiegghg',
                  'json_': Json({'faidicegb': True}),
                  'enum': enums.ABeautifulEnum.A,
                  'boolean': True,
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='createOne',
              model='N',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      async def create_many(
          self,
          data: List[types.NCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          """Create multiple N records at once.
  
          This function is *not* available when using SQLite.
  
          Parameters
          ----------
          data
              List of N record data
          skip_duplicates
              Boolean flag for ignoring unique constraint errors
  
          Returns
          -------
          int
              The total number of records created
  
          Raises
          ------
          prisma.errors.UnsupportedDatabaseError
              Attempting to query when using SQLite
          prisma.errors.UniqueViolationError
              A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          total = await N.prisma().create_many(
              data=[
                  {
                      # data to create a N record
                      'int': 872078403,
                      'float': 1874748096.91689,
                      'string': 'hgjcghfbi',
                      'json_': Json({'icadbcehj': True}),
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': True,
                  },
                  {
                      # data to create a N record
                      'int': 344858293,
                      'float': 1121741130.149589,
                      'string': 'caifcbgii',
                      'json_': Json({'igaibbfgj': True}),
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': True,
                  },
              ],
              skip_duplicates=True,
          )
          ```
          """
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = await self._client._execute(
              operation='mutation',
              method='createMany',
              model='N',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def delete(
          self,
          where: types.NWhereUniqueInput,
          include: Optional[types.NInclude] = None
      ) -> Optional['models.N']:
          """Delete a single N record.
  
          Parameters
          ----------
          where
              N filter to select the record to be deleted, must be unique
          include
              Specifies which relations should be loaded on the returned N model
  
          Returns
          -------
          prisma.models.N
              The deleted N record
          None
              Could not find a record to delete
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          n = await N.prisma().delete(
              where={
                  'id': 525761943,
              },
          )
          ```
          """
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='N',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      async def find_unique(
          self,
          where: types.NWhereUniqueInput,
          include: Optional[types.NInclude] = None
      ) -> Optional['models.N']:
          """Find a unique N record.
  
          Parameters
          ----------
          where
              N filter to find the record, must be unique
          include
              Specifies which relations should be loaded on the returned N model
  
          Returns
          -------
          prisma.models.N
              The found N record
          None
              No record matching the given input could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          n = await N.prisma().find_unique(
              where={
                  'id': 736209796,
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findUnique',
              model='N',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      async def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.NWhereInput] = None,
          cursor: Optional[types.NWhereUniqueInput] = None,
          include: Optional[types.NInclude] = None,
          order: Optional[Union[types.NOrderByInput, List[types.NOrderByInput]]] = None,
      ) -> List['models.N']:
          """Find multiple N records.
  
          An empty list is returned if no records could be found.
  
          Parameters
          ----------
          take
              Limit the maximum number of N records returned
          skip
              Ignore the first N results
          where
              N filter to select records
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned N model
          order
              Order the returned N records by any field
  
          Returns
          -------
          List[prisma.models.N]
              The list of all N records that could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the first 10 N records
          ns = await N.prisma().find_many(take=10)
  
          # find the first 5 N records ordered by the optional_int field
          ns = await N.prisma().find_many(
              take=5,
              order={
                  'optional_int': 'desc',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findMany',
              model='N',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [self._model.parse_obj(r) for r in resp['data']['result']]
  
      async def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.NWhereInput] = None,
          cursor: Optional[types.NWhereUniqueInput] = None,
          include: Optional[types.NInclude] = None,
          order: Optional[Union[types.NOrderByInput, List[types.NOrderByInput]]] = None,
      ) -> Optional['models.N']:
          """Find a single N record.
  
          Parameters
          ----------
          skip
              Ignore the first N records
          where
              N filter to select the record
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned N model
          order
              Order the returned N records by any field
  
          Returns
          -------
          prisma.models.N
              The first N record found, matching the given arguments
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the second N record ordered by the float field
          n = await N.prisma().find_first(
              skip=1,
              order={
                  'float': 'desc',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findFirst',
              model='N',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      async def update(
          self,
          data: types.NUpdateInput,
          where: types.NWhereUniqueInput,
          include: Optional[types.NInclude] = None
      ) -> Optional['models.N']:
          """Update a single N record.
  
          Parameters
          ----------
          data
              N record data specifying what to update
          where
              N filter to select the unique record to create / update
          include
              Specifies which relations should be loaded on the returned N model
  
          Returns
          -------
          prisma.models.N
              The updated N record
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          n = await N.prisma().update(
              where={
                  'id': 493907821,
              },
              data={
                  # data to update the N record to
              },
          )
          ```
          """
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='N',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      async def upsert(
          self,
          where: types.NWhereUniqueInput,
          data: types.NUpsertInput,
          include: Optional[types.NInclude] = None,
      ) -> 'models.N':
          """Updates an existing record or create a new one
  
          Parameters
          ----------
          where
              N filter to select the unique record to create / update
          data
              Data specifying what fields to set on create and update
          include
              Specifies which relations should be loaded on the returned N model
  
          Returns
          -------
          prisma.models.N
              The created or updated N record
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          n = await N.prisma().upsert(
              where={
                  'id': 639686562,
              },
              data={
                  'create': {
                      'id': 639686562,
                      'int': 344858293,
                      'float': 1121741130.149589,
                      'string': 'caifcbgii',
                      'json_': Json({'igaibbfgj': True}),
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': True,
                  },
                  'update': {
                      'int': 344858293,
                      'float': 1121741130.149589,
                      'string': 'caifcbgii',
                      'json_': Json({'igaibbfgj': True}),
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': True,
                  },
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='N',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      async def update_many(
          self,
          data: types.NUpdateManyMutationInput,
          where: types.NWhereInput,
      ) -> int:
          """Update multiple N records
  
          Parameters
          ----------
          data
              N data to update the selected N records to
          where
              Filter to select the N records to update
  
          Returns
          -------
          int
              The total number of N records that were updated
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # update all N records
          total = await N.prisma().update_many(
              data={
                  'optional_float': 654007347.190526
              },
              where={}
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='updateMany',
              model='N',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      @overload
      async def count(
          self,
          select: None = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.NWhereInput] = None,
          cursor: Optional[types.NWhereUniqueInput] = None,
          order: Optional[Union[types.NOrderByInput, List[types.NOrderByInput]]] = None,
      ) -> int:
          """Count the number of N records present in the database
  
          Parameters
          ----------
          select
              Select the N fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              N filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.NCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = await N.prisma().count()
  
          # results: prisma.types.NCountAggregateOutput
          results = await N.prisma().count(
              select={
                  '_all': True,
                  'string': True,
              },
          )
          ```
          """
  
  
      @overload
      async def count(
          self,
          select: types.NCountAggregateInput,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.NWhereInput] = None,
          cursor: Optional[types.NWhereUniqueInput] = None,
          order: Optional[Union[types.NOrderByInput, List[types.NOrderByInput]]] = None,
      ) -> types.NCountAggregateOutput:
          ...
  
      async def count(
          self,
          select: Optional[types.NCountAggregateInput] = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.NWhereInput] = None,
          cursor: Optional[types.NWhereUniqueInput] = None,
          order: Optional[Union[types.NOrderByInput, List[types.NOrderByInput]]] = None,
      ) -> Union[int, types.NCountAggregateOutput]:
          """Count the number of N records present in the database
  
          Parameters
          ----------
          select
              Select the N fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              N filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.NCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = await N.prisma().count()
  
          # results: prisma.types.NCountAggregateOutput
          results = await N.prisma().count(
              select={
                  '_all': True,
                  'optional_string': True,
              },
          )
          ```
          """
  
          # TODO: this selection building should be moved to the QueryBuilder
          #
          # note the distinction between checking for `not select` here and `select is None`
          # later is to handle the case that the given select dictionary is empty, this
          # is a limitation of our types.
          if not select:
              root_selection = ['_count { _all }']
          else:
  
              root_selection = [
                  '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
              ]
  
          if order is not None:
              warnings.warn(
                  'The `order` argument is redundant and will be removed in the next release',
                  DeprecationWarning,
                  stacklevel=2,
              )
  
          resp = await self._client._execute(
              operation='query',
              method='aggregate',
              model='N',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=root_selection,
          )
  
          if select is None:
              return cast(int, resp['data']['result']['_count']['_all'])
          else:
              return cast(types.NCountAggregateOutput, resp['data']['result']['_count'])
  
      async def delete_many(
          self,
          where: Optional[types.NWhereInput] = None
      ) -> int:
          """Delete multiple N records.
  
          Parameters
          ----------
          where
              Optional N filter to find the records to be deleted
  
          Returns
          -------
          int
              The total number of N records that were deleted
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # delete all N records
          total = await N.prisma().delete_many()
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='N',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  class OneOptionalActions:
      def __init__(self, client: 'Client', model: Type['models.OneOptional']) -> None:
          self._client = client
          self._model = model
  
      async def query_raw(
          self,
          query: str,
          *args: Any,
      ) -> List['models.OneOptional']:
          """Execute a raw SQL query
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          List[prisma.models.OneOptional]
              The records returned by the SQL query
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          users = await OneOptional.prisma().query_raw(
              'SELECT * FROM OneOptional WHERE id = $1',
              78746985,
          )
          ```
          """
          return await self._client.query_raw(query, *args, model=self._model)
  
      async def query_first(
          self,
          query: str,
          *args: Any,
      ) -> Optional['models.OneOptional']:
          """Execute a raw SQL query, returning the first result
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          prisma.models.OneOptional
              The first record returned by the SQL query
          None
              The raw SQL query did not return any records
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          user = await OneOptional.prisma().query_first(
              'SELECT * FROM OneOptional WHERE int = $1',
              1398328302,
          )
          ```
          """
          return await self._client.query_first(query, *args, model=self._model)
  
      async def create(
          self,
          data: types.OneOptionalCreateInput,
          include: Optional[types.OneOptionalInclude] = None
      ) -> 'models.OneOptional':
          """Create a new OneOptional record.
  
          Parameters
          ----------
          data
              OneOptional record data
          include
              Specifies which relations should be loaded on the returned OneOptional model
  
          Returns
          -------
          prisma.models.OneOptional
              The created OneOptional record
  
          Raises
          ------
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # create a OneOptional record from just the required fields
          oneoptional = await OneOptional.prisma().create(
              data={
                  # data to create a OneOptional record
                  'int': 856000655,
                  'float': 1452336924.157319,
                  'string': 'cabdjadaji',
                  'enum': enums.ABeautifulEnum.A,
                  'boolean': False,
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='createOne',
              model='OneOptional',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      async def create_many(
          self,
          data: List[types.OneOptionalCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          """Create multiple OneOptional records at once.
  
          This function is *not* available when using SQLite.
  
          Parameters
          ----------
          data
              List of OneOptional record data
          skip_duplicates
              Boolean flag for ignoring unique constraint errors
  
          Returns
          -------
          int
              The total number of records created
  
          Raises
          ------
          prisma.errors.UnsupportedDatabaseError
              Attempting to query when using SQLite
          prisma.errors.UniqueViolationError
              A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          total = await OneOptional.prisma().create_many(
              data=[
                  {
                      # data to create a OneOptional record
                      'int': 1800624392,
                      'float': 2077067425.167211,
                      'string': 'jcgghhgdj',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': True,
                  },
                  {
                      # data to create a OneOptional record
                      'int': 1738083805,
                      'float': 340946258.60107,
                      'string': 'cjagadcjg',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': False,
                  },
              ],
              skip_duplicates=True,
          )
          ```
          """
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = await self._client._execute(
              operation='mutation',
              method='createMany',
              model='OneOptional',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def delete(
          self,
          where: types.OneOptionalWhereUniqueInput,
          include: Optional[types.OneOptionalInclude] = None
      ) -> Optional['models.OneOptional']:
          """Delete a single OneOptional record.
  
          Parameters
          ----------
          where
              OneOptional filter to select the record to be deleted, must be unique
          include
              Specifies which relations should be loaded on the returned OneOptional model
  
          Returns
          -------
          prisma.models.OneOptional
              The deleted OneOptional record
          None
              Could not find a record to delete
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          oneoptional = await OneOptional.prisma().delete(
              where={
                  'id': 1611009182,
              },
          )
          ```
          """
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='OneOptional',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      async def find_unique(
          self,
          where: types.OneOptionalWhereUniqueInput,
          include: Optional[types.OneOptionalInclude] = None
      ) -> Optional['models.OneOptional']:
          """Find a unique OneOptional record.
  
          Parameters
          ----------
          where
              OneOptional filter to find the record, must be unique
          include
              Specifies which relations should be loaded on the returned OneOptional model
  
          Returns
          -------
          prisma.models.OneOptional
              The found OneOptional record
          None
              No record matching the given input could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          oneoptional = await OneOptional.prisma().find_unique(
              where={
                  'id': 446673791,
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findUnique',
              model='OneOptional',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      async def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.OneOptionalWhereInput] = None,
          cursor: Optional[types.OneOptionalWhereUniqueInput] = None,
          include: Optional[types.OneOptionalInclude] = None,
          order: Optional[Union[types.OneOptionalOrderByInput, List[types.OneOptionalOrderByInput]]] = None,
      ) -> List['models.OneOptional']:
          """Find multiple OneOptional records.
  
          An empty list is returned if no records could be found.
  
          Parameters
          ----------
          take
              Limit the maximum number of OneOptional records returned
          skip
              Ignore the first N results
          where
              OneOptional filter to select records
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned OneOptional model
          order
              Order the returned OneOptional records by any field
  
          Returns
          -------
          List[prisma.models.OneOptional]
              The list of all OneOptional records that could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the first 10 OneOptional records
          oneoptionals = await OneOptional.prisma().find_many(take=10)
  
          # find the first 5 OneOptional records ordered by the optional_int field
          oneoptionals = await OneOptional.prisma().find_many(
              take=5,
              order={
                  'optional_int': 'desc',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findMany',
              model='OneOptional',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [self._model.parse_obj(r) for r in resp['data']['result']]
  
      async def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.OneOptionalWhereInput] = None,
          cursor: Optional[types.OneOptionalWhereUniqueInput] = None,
          include: Optional[types.OneOptionalInclude] = None,
          order: Optional[Union[types.OneOptionalOrderByInput, List[types.OneOptionalOrderByInput]]] = None,
      ) -> Optional['models.OneOptional']:
          """Find a single OneOptional record.
  
          Parameters
          ----------
          skip
              Ignore the first N records
          where
              OneOptional filter to select the record
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned OneOptional model
          order
              Order the returned OneOptional records by any field
  
          Returns
          -------
          prisma.models.OneOptional
              The first OneOptional record found, matching the given arguments
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the second OneOptional record ordered by the float field
          oneoptional = await OneOptional.prisma().find_first(
              skip=1,
              order={
                  'float': 'desc',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findFirst',
              model='OneOptional',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      async def update(
          self,
          data: types.OneOptionalUpdateInput,
          where: types.OneOptionalWhereUniqueInput,
          include: Optional[types.OneOptionalInclude] = None
      ) -> Optional['models.OneOptional']:
          """Update a single OneOptional record.
  
          Parameters
          ----------
          data
              OneOptional record data specifying what to update
          where
              OneOptional filter to select the unique record to create / update
          include
              Specifies which relations should be loaded on the returned OneOptional model
  
          Returns
          -------
          prisma.models.OneOptional
              The updated OneOptional record
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          oneoptional = await OneOptional.prisma().update(
              where={
                  'id': 300568396,
              },
              data={
                  # data to update the OneOptional record to
              },
          )
          ```
          """
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='OneOptional',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      async def upsert(
          self,
          where: types.OneOptionalWhereUniqueInput,
          data: types.OneOptionalUpsertInput,
          include: Optional[types.OneOptionalInclude] = None,
      ) -> 'models.OneOptional':
          """Updates an existing record or create a new one
  
          Parameters
          ----------
          where
              OneOptional filter to select the unique record to create / update
          data
              Data specifying what fields to set on create and update
          include
              Specifies which relations should be loaded on the returned OneOptional model
  
          Returns
          -------
          prisma.models.OneOptional
              The created or updated OneOptional record
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          oneoptional = await OneOptional.prisma().upsert(
              where={
                  'id': 632626069,
              },
              data={
                  'create': {
                      'id': 632626069,
                      'int': 1738083805,
                      'float': 340946258.60107,
                      'string': 'cjagadcjg',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': False,
                  },
                  'update': {
                      'int': 1738083805,
                      'float': 340946258.60107,
                      'string': 'cjagadcjg',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': False,
                  },
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='OneOptional',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      async def update_many(
          self,
          data: types.OneOptionalUpdateManyMutationInput,
          where: types.OneOptionalWhereInput,
      ) -> int:
          """Update multiple OneOptional records
  
          Parameters
          ----------
          data
              OneOptional data to update the selected OneOptional records to
          where
              Filter to select the OneOptional records to update
  
          Returns
          -------
          int
              The total number of OneOptional records that were updated
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # update all OneOptional records
          total = await OneOptional.prisma().update_many(
              data={
                  'optional_float': 1724011690.47015
              },
              where={}
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='updateMany',
              model='OneOptional',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      @overload
      async def count(
          self,
          select: None = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.OneOptionalWhereInput] = None,
          cursor: Optional[types.OneOptionalWhereUniqueInput] = None,
          order: Optional[Union[types.OneOptionalOrderByInput, List[types.OneOptionalOrderByInput]]] = None,
      ) -> int:
          """Count the number of OneOptional records present in the database
  
          Parameters
          ----------
          select
              Select the OneOptional fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              OneOptional filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.OneOptionalCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = await OneOptional.prisma().count()
  
          # results: prisma.types.OneOptionalCountAggregateOutput
          results = await OneOptional.prisma().count(
              select={
                  '_all': True,
                  'string': True,
              },
          )
          ```
          """
  
  
      @overload
      async def count(
          self,
          select: types.OneOptionalCountAggregateInput,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.OneOptionalWhereInput] = None,
          cursor: Optional[types.OneOptionalWhereUniqueInput] = None,
          order: Optional[Union[types.OneOptionalOrderByInput, List[types.OneOptionalOrderByInput]]] = None,
      ) -> types.OneOptionalCountAggregateOutput:
          ...
  
      async def count(
          self,
          select: Optional[types.OneOptionalCountAggregateInput] = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.OneOptionalWhereInput] = None,
          cursor: Optional[types.OneOptionalWhereUniqueInput] = None,
          order: Optional[Union[types.OneOptionalOrderByInput, List[types.OneOptionalOrderByInput]]] = None,
      ) -> Union[int, types.OneOptionalCountAggregateOutput]:
          """Count the number of OneOptional records present in the database
  
          Parameters
          ----------
          select
              Select the OneOptional fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              OneOptional filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.OneOptionalCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = await OneOptional.prisma().count()
  
          # results: prisma.types.OneOptionalCountAggregateOutput
          results = await OneOptional.prisma().count(
              select={
                  '_all': True,
                  'optional_string': True,
              },
          )
          ```
          """
  
          # TODO: this selection building should be moved to the QueryBuilder
          #
          # note the distinction between checking for `not select` here and `select is None`
          # later is to handle the case that the given select dictionary is empty, this
          # is a limitation of our types.
          if not select:
              root_selection = ['_count { _all }']
          else:
  
              root_selection = [
                  '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
              ]
  
          if order is not None:
              warnings.warn(
                  'The `order` argument is redundant and will be removed in the next release',
                  DeprecationWarning,
                  stacklevel=2,
              )
  
          resp = await self._client._execute(
              operation='query',
              method='aggregate',
              model='OneOptional',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=root_selection,
          )
  
          if select is None:
              return cast(int, resp['data']['result']['_count']['_all'])
          else:
              return cast(types.OneOptionalCountAggregateOutput, resp['data']['result']['_count'])
  
      async def delete_many(
          self,
          where: Optional[types.OneOptionalWhereInput] = None
      ) -> int:
          """Delete multiple OneOptional records.
  
          Parameters
          ----------
          where
              Optional OneOptional filter to find the records to be deleted
  
          Returns
          -------
          int
              The total number of OneOptional records that were deleted
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # delete all OneOptional records
          total = await OneOptional.prisma().delete_many()
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='OneOptional',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  class ManyRequiredActions:
      def __init__(self, client: 'Client', model: Type['models.ManyRequired']) -> None:
          self._client = client
          self._model = model
  
      async def query_raw(
          self,
          query: str,
          *args: Any,
      ) -> List['models.ManyRequired']:
          """Execute a raw SQL query
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          List[prisma.models.ManyRequired]
              The records returned by the SQL query
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          users = await ManyRequired.prisma().query_raw(
              'SELECT * FROM ManyRequired WHERE id = $1',
              1209209912,
          )
          ```
          """
          return await self._client.query_raw(query, *args, model=self._model)
  
      async def query_first(
          self,
          query: str,
          *args: Any,
      ) -> Optional['models.ManyRequired']:
          """Execute a raw SQL query, returning the first result
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          prisma.models.ManyRequired
              The first record returned by the SQL query
          None
              The raw SQL query did not return any records
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          user = await ManyRequired.prisma().query_first(
              'SELECT * FROM ManyRequired WHERE one_optional_id = $1',
              1536744465,
          )
          ```
          """
          return await self._client.query_first(query, *args, model=self._model)
  
      async def create(
          self,
          data: types.ManyRequiredCreateInput,
          include: Optional[types.ManyRequiredInclude] = None
      ) -> 'models.ManyRequired':
          """Create a new ManyRequired record.
  
          Parameters
          ----------
          data
              ManyRequired record data
          include
              Specifies which relations should be loaded on the returned ManyRequired model
  
          Returns
          -------
          prisma.models.ManyRequired
              The created ManyRequired record
  
          Raises
          ------
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # create a ManyRequired record from just the required fields
          manyrequired = await ManyRequired.prisma().create(
              data={
                  # data to create a ManyRequired record
                  'int': 424218998,
                  'float': 2125632375.53695,
                  'string': 'jcehcdchh',
                  'enum': enums.ABeautifulEnum.A,
                  'boolean': True,
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='createOne',
              model='ManyRequired',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      async def create_many(
          self,
          data: List[types.ManyRequiredCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          """Create multiple ManyRequired records at once.
  
          This function is *not* available when using SQLite.
  
          Parameters
          ----------
          data
              List of ManyRequired record data
          skip_duplicates
              Boolean flag for ignoring unique constraint errors
  
          Returns
          -------
          int
              The total number of records created
  
          Raises
          ------
          prisma.errors.UnsupportedDatabaseError
              Attempting to query when using SQLite
          prisma.errors.UniqueViolationError
              A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          total = await ManyRequired.prisma().create_many(
              data=[
                  {
                      # data to create a ManyRequired record
                      'int': 1848832019,
                      'float': 1921528400.210042,
                      'string': 'iejbeaaeg',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': False,
                  },
                  {
                      # data to create a ManyRequired record
                      'int': 273032060,
                      'float': 982848517.51073,
                      'string': 'cbbheiicgh',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': True,
                  },
              ],
              skip_duplicates=True,
          )
          ```
          """
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = await self._client._execute(
              operation='mutation',
              method='createMany',
              model='ManyRequired',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def delete(
          self,
          where: types.ManyRequiredWhereUniqueInput,
          include: Optional[types.ManyRequiredInclude] = None
      ) -> Optional['models.ManyRequired']:
          """Delete a single ManyRequired record.
  
          Parameters
          ----------
          where
              ManyRequired filter to select the record to be deleted, must be unique
          include
              Specifies which relations should be loaded on the returned ManyRequired model
  
          Returns
          -------
          prisma.models.ManyRequired
              The deleted ManyRequired record
          None
              Could not find a record to delete
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          manyrequired = await ManyRequired.prisma().delete(
              where={
                  'id': 1297607553,
              },
          )
          ```
          """
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='ManyRequired',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      async def find_unique(
          self,
          where: types.ManyRequiredWhereUniqueInput,
          include: Optional[types.ManyRequiredInclude] = None
      ) -> Optional['models.ManyRequired']:
          """Find a unique ManyRequired record.
  
          Parameters
          ----------
          where
              ManyRequired filter to find the record, must be unique
          include
              Specifies which relations should be loaded on the returned ManyRequired model
  
          Returns
          -------
          prisma.models.ManyRequired
              The found ManyRequired record
          None
              No record matching the given input could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          manyrequired = await ManyRequired.prisma().find_unique(
              where={
                  'id': 519488550,
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findUnique',
              model='ManyRequired',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      async def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.ManyRequiredWhereInput] = None,
          cursor: Optional[types.ManyRequiredWhereUniqueInput] = None,
          include: Optional[types.ManyRequiredInclude] = None,
          order: Optional[Union[types.ManyRequiredOrderByInput, List[types.ManyRequiredOrderByInput]]] = None,
      ) -> List['models.ManyRequired']:
          """Find multiple ManyRequired records.
  
          An empty list is returned if no records could be found.
  
          Parameters
          ----------
          take
              Limit the maximum number of ManyRequired records returned
          skip
              Ignore the first N results
          where
              ManyRequired filter to select records
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned ManyRequired model
          order
              Order the returned ManyRequired records by any field
  
          Returns
          -------
          List[prisma.models.ManyRequired]
              The list of all ManyRequired records that could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the first 10 ManyRequired records
          manyrequireds = await ManyRequired.prisma().find_many(take=10)
  
          # find the first 5 ManyRequired records ordered by the int field
          manyrequireds = await ManyRequired.prisma().find_many(
              take=5,
              order={
                  'int': 'desc',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findMany',
              model='ManyRequired',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [self._model.parse_obj(r) for r in resp['data']['result']]
  
      async def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.ManyRequiredWhereInput] = None,
          cursor: Optional[types.ManyRequiredWhereUniqueInput] = None,
          include: Optional[types.ManyRequiredInclude] = None,
          order: Optional[Union[types.ManyRequiredOrderByInput, List[types.ManyRequiredOrderByInput]]] = None,
      ) -> Optional['models.ManyRequired']:
          """Find a single ManyRequired record.
  
          Parameters
          ----------
          skip
              Ignore the first N records
          where
              ManyRequired filter to select the record
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned ManyRequired model
          order
              Order the returned ManyRequired records by any field
  
          Returns
          -------
          prisma.models.ManyRequired
              The first ManyRequired record found, matching the given arguments
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the second ManyRequired record ordered by the optional_int field
          manyrequired = await ManyRequired.prisma().find_first(
              skip=1,
              order={
                  'optional_int': 'desc',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findFirst',
              model='ManyRequired',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      async def update(
          self,
          data: types.ManyRequiredUpdateInput,
          where: types.ManyRequiredWhereUniqueInput,
          include: Optional[types.ManyRequiredInclude] = None
      ) -> Optional['models.ManyRequired']:
          """Update a single ManyRequired record.
  
          Parameters
          ----------
          data
              ManyRequired record data specifying what to update
          where
              ManyRequired filter to select the unique record to create / update
          include
              Specifies which relations should be loaded on the returned ManyRequired model
  
          Returns
          -------
          prisma.models.ManyRequired
              The updated ManyRequired record
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          manyrequired = await ManyRequired.prisma().update(
              where={
                  'id': 976832615,
              },
              data={
                  # data to update the ManyRequired record to
              },
          )
          ```
          """
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='ManyRequired',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      async def upsert(
          self,
          where: types.ManyRequiredWhereUniqueInput,
          data: types.ManyRequiredUpsertInput,
          include: Optional[types.ManyRequiredInclude] = None,
      ) -> 'models.ManyRequired':
          """Updates an existing record or create a new one
  
          Parameters
          ----------
          where
              ManyRequired filter to select the unique record to create / update
          data
              Data specifying what fields to set on create and update
          include
              Specifies which relations should be loaded on the returned ManyRequired model
  
          Returns
          -------
          prisma.models.ManyRequired
              The created or updated ManyRequired record
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          manyrequired = await ManyRequired.prisma().upsert(
              where={
                  'id': 1696425492,
              },
              data={
                  'create': {
                      'id': 1696425492,
                      'int': 273032060,
                      'float': 982848517.51073,
                      'string': 'cbbheiicgh',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': True,
                  },
                  'update': {
                      'int': 273032060,
                      'float': 982848517.51073,
                      'string': 'cbbheiicgh',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': True,
                  },
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='ManyRequired',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      async def update_many(
          self,
          data: types.ManyRequiredUpdateManyMutationInput,
          where: types.ManyRequiredWhereInput,
      ) -> int:
          """Update multiple ManyRequired records
  
          Parameters
          ----------
          data
              ManyRequired data to update the selected ManyRequired records to
          where
              Filter to select the ManyRequired records to update
  
          Returns
          -------
          int
              The total number of ManyRequired records that were updated
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # update all ManyRequired records
          total = await ManyRequired.prisma().update_many(
              data={
                  'float': 169262781.102308
              },
              where={}
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='updateMany',
              model='ManyRequired',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      @overload
      async def count(
          self,
          select: None = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.ManyRequiredWhereInput] = None,
          cursor: Optional[types.ManyRequiredWhereUniqueInput] = None,
          order: Optional[Union[types.ManyRequiredOrderByInput, List[types.ManyRequiredOrderByInput]]] = None,
      ) -> int:
          """Count the number of ManyRequired records present in the database
  
          Parameters
          ----------
          select
              Select the ManyRequired fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              ManyRequired filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.ManyRequiredCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = await ManyRequired.prisma().count()
  
          # results: prisma.types.ManyRequiredCountAggregateOutput
          results = await ManyRequired.prisma().count(
              select={
                  '_all': True,
                  'optional_float': True,
              },
          )
          ```
          """
  
  
      @overload
      async def count(
          self,
          select: types.ManyRequiredCountAggregateInput,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.ManyRequiredWhereInput] = None,
          cursor: Optional[types.ManyRequiredWhereUniqueInput] = None,
          order: Optional[Union[types.ManyRequiredOrderByInput, List[types.ManyRequiredOrderByInput]]] = None,
      ) -> types.ManyRequiredCountAggregateOutput:
          ...
  
      async def count(
          self,
          select: Optional[types.ManyRequiredCountAggregateInput] = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.ManyRequiredWhereInput] = None,
          cursor: Optional[types.ManyRequiredWhereUniqueInput] = None,
          order: Optional[Union[types.ManyRequiredOrderByInput, List[types.ManyRequiredOrderByInput]]] = None,
      ) -> Union[int, types.ManyRequiredCountAggregateOutput]:
          """Count the number of ManyRequired records present in the database
  
          Parameters
          ----------
          select
              Select the ManyRequired fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              ManyRequired filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.ManyRequiredCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = await ManyRequired.prisma().count()
  
          # results: prisma.types.ManyRequiredCountAggregateOutput
          results = await ManyRequired.prisma().count(
              select={
                  '_all': True,
                  'string': True,
              },
          )
          ```
          """
  
          # TODO: this selection building should be moved to the QueryBuilder
          #
          # note the distinction between checking for `not select` here and `select is None`
          # later is to handle the case that the given select dictionary is empty, this
          # is a limitation of our types.
          if not select:
              root_selection = ['_count { _all }']
          else:
  
              root_selection = [
                  '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
              ]
  
          if order is not None:
              warnings.warn(
                  'The `order` argument is redundant and will be removed in the next release',
                  DeprecationWarning,
                  stacklevel=2,
              )
  
          resp = await self._client._execute(
              operation='query',
              method='aggregate',
              model='ManyRequired',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=root_selection,
          )
  
          if select is None:
              return cast(int, resp['data']['result']['_count']['_all'])
          else:
              return cast(types.ManyRequiredCountAggregateOutput, resp['data']['result']['_count'])
  
      async def delete_many(
          self,
          where: Optional[types.ManyRequiredWhereInput] = None
      ) -> int:
          """Delete multiple ManyRequired records.
  
          Parameters
          ----------
          where
              Optional ManyRequired filter to find the records to be deleted
  
          Returns
          -------
          int
              The total number of ManyRequired records that were deleted
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # delete all ManyRequired records
          total = await ManyRequired.prisma().delete_many()
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='ManyRequired',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  class ListsActions:
      def __init__(self, client: 'Client', model: Type['models.Lists']) -> None:
          self._client = client
          self._model = model
  
      async def query_raw(
          self,
          query: str,
          *args: Any,
      ) -> List['models.Lists']:
          """Execute a raw SQL query
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          List[prisma.models.Lists]
              The records returned by the SQL query
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          users = await Lists.prisma().query_raw(
              'SELECT * FROM Lists WHERE id = $1',
              'dchgibach',
          )
          ```
          """
          return await self._client.query_raw(query, *args, model=self._model)
  
      async def query_first(
          self,
          query: str,
          *args: Any,
      ) -> Optional['models.Lists']:
          """Execute a raw SQL query, returning the first result
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          prisma.models.Lists
              The first record returned by the SQL query
          None
              The raw SQL query did not return any records
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          user = await Lists.prisma().query_first(
              'SELECT * FROM Lists WHERE strings = $1',
              ['fchheijjc'],
          )
          ```
          """
          return await self._client.query_first(query, *args, model=self._model)
  
      async def create(
          self,
          data: types.ListsCreateInput,
          include: Optional[types.ListsInclude] = None
      ) -> 'models.Lists':
          """Create a new Lists record.
  
          Parameters
          ----------
          data
              Lists record data
          include
              Specifies which relations should be loaded on the returned Lists model
  
          Returns
          -------
          prisma.models.Lists
              The created Lists record
  
          Raises
          ------
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # create a Lists record from just the required fields
          lists = await Lists.prisma().create(
              data={
                  # data to create a Lists record
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='createOne',
              model='Lists',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      async def create_many(
          self,
          data: List[types.ListsCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          """Create multiple Lists records at once.
  
          This function is *not* available when using SQLite.
  
          Parameters
          ----------
          data
              List of Lists record data
          skip_duplicates
              Boolean flag for ignoring unique constraint errors
  
          Returns
          -------
          int
              The total number of records created
  
          Raises
          ------
          prisma.errors.UnsupportedDatabaseError
              Attempting to query when using SQLite
          prisma.errors.UniqueViolationError
              A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          total = await Lists.prisma().create_many(
              data=[
                  {
                      # data to create a Lists record
                  },
                  {
                      # data to create a Lists record
                  },
              ],
              skip_duplicates=True,
          )
          ```
          """
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = await self._client._execute(
              operation='mutation',
              method='createMany',
              model='Lists',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def delete(
          self,
          where: types.ListsWhereUniqueInput,
          include: Optional[types.ListsInclude] = None
      ) -> Optional['models.Lists']:
          """Delete a single Lists record.
  
          Parameters
          ----------
          where
              Lists filter to select the record to be deleted, must be unique
          include
              Specifies which relations should be loaded on the returned Lists model
  
          Returns
          -------
          prisma.models.Lists
              The deleted Lists record
          None
              Could not find a record to delete
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          lists = await Lists.prisma().delete(
              where={
                  'id': 'cacjdfhejh',
              },
          )
          ```
          """
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='Lists',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      async def find_unique(
          self,
          where: types.ListsWhereUniqueInput,
          include: Optional[types.ListsInclude] = None
      ) -> Optional['models.Lists']:
          """Find a unique Lists record.
  
          Parameters
          ----------
          where
              Lists filter to find the record, must be unique
          include
              Specifies which relations should be loaded on the returned Lists model
  
          Returns
          -------
          prisma.models.Lists
              The found Lists record
          None
              No record matching the given input could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          lists = await Lists.prisma().find_unique(
              where={
                  'id': 'bdbifjhbbi',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findUnique',
              model='Lists',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      async def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.ListsWhereInput] = None,
          cursor: Optional[types.ListsWhereUniqueInput] = None,
          include: Optional[types.ListsInclude] = None,
          order: Optional[Union[types.ListsOrderByInput, List[types.ListsOrderByInput]]] = None,
      ) -> List['models.Lists']:
          """Find multiple Lists records.
  
          An empty list is returned if no records could be found.
  
          Parameters
          ----------
          take
              Limit the maximum number of Lists records returned
          skip
              Ignore the first N results
          where
              Lists filter to select records
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned Lists model
          order
              Order the returned Lists records by any field
  
          Returns
          -------
          List[prisma.models.Lists]
              The list of all Lists records that could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the first 10 Lists records
          lists = await Lists.prisma().find_many(take=10)
  
          # find the first 5 Lists records ordered by the bytes field
          lists = await Lists.prisma().find_many(
              take=5,
              order={
                  'bytes': 'desc',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findMany',
              model='Lists',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [self._model.parse_obj(r) for r in resp['data']['result']]
  
      async def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.ListsWhereInput] = None,
          cursor: Optional[types.ListsWhereUniqueInput] = None,
          include: Optional[types.ListsInclude] = None,
          order: Optional[Union[types.ListsOrderByInput, List[types.ListsOrderByInput]]] = None,
      ) -> Optional['models.Lists']:
          """Find a single Lists record.
  
          Parameters
          ----------
          skip
              Ignore the first N records
          where
              Lists filter to select the record
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned Lists model
          order
              Order the returned Lists records by any field
  
          Returns
          -------
          prisma.models.Lists
              The first Lists record found, matching the given arguments
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the second Lists record ordered by the dates field
          lists = await Lists.prisma().find_first(
              skip=1,
              order={
                  'dates': 'desc',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findFirst',
              model='Lists',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      async def update(
          self,
          data: types.ListsUpdateInput,
          where: types.ListsWhereUniqueInput,
          include: Optional[types.ListsInclude] = None
      ) -> Optional['models.Lists']:
          """Update a single Lists record.
  
          Parameters
          ----------
          data
              Lists record data specifying what to update
          where
              Lists filter to select the unique record to create / update
          include
              Specifies which relations should be loaded on the returned Lists model
  
          Returns
          -------
          prisma.models.Lists
              The updated Lists record
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          lists = await Lists.prisma().update(
              where={
                  'id': 'cbccbbcdfb',
              },
              data={
                  # data to update the Lists record to
              },
          )
          ```
          """
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='Lists',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      async def upsert(
          self,
          where: types.ListsWhereUniqueInput,
          data: types.ListsUpsertInput,
          include: Optional[types.ListsInclude] = None,
      ) -> 'models.Lists':
          """Updates an existing record or create a new one
  
          Parameters
          ----------
          where
              Lists filter to select the unique record to create / update
          data
              Data specifying what fields to set on create and update
          include
              Specifies which relations should be loaded on the returned Lists model
  
          Returns
          -------
          prisma.models.Lists
              The created or updated Lists record
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          lists = await Lists.prisma().upsert(
              where={
                  'id': 'bacejedaca',
              },
              data={
                  'create': {
                      'id': 'bacejedaca',
                  },
                  'update': {
                  },
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='Lists',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      async def update_many(
          self,
          data: types.ListsUpdateManyMutationInput,
          where: types.ListsWhereInput,
      ) -> int:
          """Update multiple Lists records
  
          Parameters
          ----------
          data
              Lists data to update the selected Lists records to
          where
              Filter to select the Lists records to update
  
          Returns
          -------
          int
              The total number of Lists records that were updated
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # update all Lists records
          total = await Lists.prisma().update_many(
              data={
                  'bools': [False]
              },
              where={}
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='updateMany',
              model='Lists',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      @overload
      async def count(
          self,
          select: None = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.ListsWhereInput] = None,
          cursor: Optional[types.ListsWhereUniqueInput] = None,
          order: Optional[Union[types.ListsOrderByInput, List[types.ListsOrderByInput]]] = None,
      ) -> int:
          """Count the number of Lists records present in the database
  
          Parameters
          ----------
          select
              Select the Lists fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              Lists filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.ListsCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = await Lists.prisma().count()
  
          # results: prisma.types.ListsCountAggregateOutput
          results = await Lists.prisma().count(
              select={
                  '_all': True,
                  'ints': True,
              },
          )
          ```
          """
  
  
      @overload
      async def count(
          self,
          select: types.ListsCountAggregateInput,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.ListsWhereInput] = None,
          cursor: Optional[types.ListsWhereUniqueInput] = None,
          order: Optional[Union[types.ListsOrderByInput, List[types.ListsOrderByInput]]] = None,
      ) -> types.ListsCountAggregateOutput:
          ...
  
      async def count(
          self,
          select: Optional[types.ListsCountAggregateInput] = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.ListsWhereInput] = None,
          cursor: Optional[types.ListsWhereUniqueInput] = None,
          order: Optional[Union[types.ListsOrderByInput, List[types.ListsOrderByInput]]] = None,
      ) -> Union[int, types.ListsCountAggregateOutput]:
          """Count the number of Lists records present in the database
  
          Parameters
          ----------
          select
              Select the Lists fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              Lists filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.ListsCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = await Lists.prisma().count()
  
          # results: prisma.types.ListsCountAggregateOutput
          results = await Lists.prisma().count(
              select={
                  '_all': True,
                  'floats': True,
              },
          )
          ```
          """
  
          # TODO: this selection building should be moved to the QueryBuilder
          #
          # note the distinction between checking for `not select` here and `select is None`
          # later is to handle the case that the given select dictionary is empty, this
          # is a limitation of our types.
          if not select:
              root_selection = ['_count { _all }']
          else:
  
              root_selection = [
                  '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
              ]
  
          if order is not None:
              warnings.warn(
                  'The `order` argument is redundant and will be removed in the next release',
                  DeprecationWarning,
                  stacklevel=2,
              )
  
          resp = await self._client._execute(
              operation='query',
              method='aggregate',
              model='Lists',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=root_selection,
          )
  
          if select is None:
              return cast(int, resp['data']['result']['_count']['_all'])
          else:
              return cast(types.ListsCountAggregateOutput, resp['data']['result']['_count'])
  
      async def delete_many(
          self,
          where: Optional[types.ListsWhereInput] = None
      ) -> int:
          """Delete multiple Lists records.
  
          Parameters
          ----------
          where
              Optional Lists filter to find the records to be deleted
  
          Returns
          -------
          int
              The total number of Lists records that were deleted
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # delete all Lists records
          total = await Lists.prisma().delete_many()
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='Lists',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  class AActions:
      def __init__(self, client: 'Client', model: Type['models.A']) -> None:
          self._client = client
          self._model = model
  
      async def query_raw(
          self,
          query: str,
          *args: Any,
      ) -> List['models.A']:
          """Execute a raw SQL query
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          List[prisma.models.A]
              The records returned by the SQL query
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          users = await A.prisma().query_raw(
              'SELECT * FROM A WHERE email = $1',
              'bfjibceaec',
          )
          ```
          """
          return await self._client.query_raw(query, *args, model=self._model)
  
      async def query_first(
          self,
          query: str,
          *args: Any,
      ) -> Optional['models.A']:
          """Execute a raw SQL query, returning the first result
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          prisma.models.A
              The first record returned by the SQL query
          None
              The raw SQL query did not return any records
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          user = await A.prisma().query_first(
              'SELECT * FROM A WHERE name = $1',
              'ibhgcdbgd',
          )
          ```
          """
          return await self._client.query_first(query, *args, model=self._model)
  
      async def create(
          self,
          data: types.ACreateInput,
          include: Optional[types.AInclude] = None
      ) -> 'models.A':
          """Create a new A record.
  
          Parameters
          ----------
          data
              A record data
          include
              Specifies which relations should be loaded on the returned A model
  
          Returns
          -------
          prisma.models.A
              The created A record
  
          Raises
          ------
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # create a A record from just the required fields
          a = await A.prisma().create(
              data={
                  # data to create a A record
                  'email': 'badaffhddg',
                  'int': 1131525873,
                  'sInt': 210666198,
                  'bInt': 15312695316,
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='createOne',
              model='A',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      async def create_many(
          self,
          data: List[types.ACreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          """Create multiple A records at once.
  
          This function is *not* available when using SQLite.
  
          Parameters
          ----------
          data
              List of A record data
          skip_duplicates
              Boolean flag for ignoring unique constraint errors
  
          Returns
          -------
          int
              The total number of records created
  
          Raises
          ------
          prisma.errors.UnsupportedDatabaseError
              Attempting to query when using SQLite
          prisma.errors.UniqueViolationError
              A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          total = await A.prisma().create_many(
              data=[
                  {
                      # data to create a A record
                      'email': 'heffgjdei',
                      'int': 307876141,
                      'sInt': 1674049122,
                      'bInt': 18322255716,
                  },
                  {
                      # data to create a A record
                      'email': 'jfiahhbae',
                      'int': 1513050921,
                      'sInt': 204674734,
                      'bInt': 24811819956,
                  },
              ],
              skip_duplicates=True,
          )
          ```
          """
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = await self._client._execute(
              operation='mutation',
              method='createMany',
              model='A',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def delete(
          self,
          where: types.AWhereUniqueInput,
          include: Optional[types.AInclude] = None
      ) -> Optional['models.A']:
          """Delete a single A record.
  
          Parameters
          ----------
          where
              A filter to select the record to be deleted, must be unique
          include
              Specifies which relations should be loaded on the returned A model
  
          Returns
          -------
          prisma.models.A
              The deleted A record
          None
              Could not find a record to delete
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          a = await A.prisma().delete(
              where={
                  'email': 'bbidjbbjaa',
              },
          )
          ```
          """
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='A',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      async def find_unique(
          self,
          where: types.AWhereUniqueInput,
          include: Optional[types.AInclude] = None
      ) -> Optional['models.A']:
          """Find a unique A record.
  
          Parameters
          ----------
          where
              A filter to find the record, must be unique
          include
              Specifies which relations should be loaded on the returned A model
  
          Returns
          -------
          prisma.models.A
              The found A record
          None
              No record matching the given input could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          a = await A.prisma().find_unique(
              where={
                  'email': 'bfijhaejdd',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findUnique',
              model='A',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      async def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.AWhereInput] = None,
          cursor: Optional[types.AWhereUniqueInput] = None,
          include: Optional[types.AInclude] = None,
          order: Optional[Union[types.AOrderByInput, List[types.AOrderByInput]]] = None,
      ) -> List['models.A']:
          """Find multiple A records.
  
          An empty list is returned if no records could be found.
  
          Parameters
          ----------
          take
              Limit the maximum number of A records returned
          skip
              Ignore the first N results
          where
              A filter to select records
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned A model
          order
              Order the returned A records by any field
  
          Returns
          -------
          List[prisma.models.A]
              The list of all A records that could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the first 10 A records
          as = await A.prisma().find_many(take=10)
  
          # find the first 5 A records ordered by the int field
          as = await A.prisma().find_many(
              take=5,
              order={
                  'int': 'desc',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findMany',
              model='A',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [self._model.parse_obj(r) for r in resp['data']['result']]
  
      async def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.AWhereInput] = None,
          cursor: Optional[types.AWhereUniqueInput] = None,
          include: Optional[types.AInclude] = None,
          order: Optional[Union[types.AOrderByInput, List[types.AOrderByInput]]] = None,
      ) -> Optional['models.A']:
          """Find a single A record.
  
          Parameters
          ----------
          skip
              Ignore the first N records
          where
              A filter to select the record
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned A model
          order
              Order the returned A records by any field
  
          Returns
          -------
          prisma.models.A
              The first A record found, matching the given arguments
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the second A record ordered by the sInt field
          a = await A.prisma().find_first(
              skip=1,
              order={
                  'sInt': 'desc',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findFirst',
              model='A',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      async def update(
          self,
          data: types.AUpdateInput,
          where: types.AWhereUniqueInput,
          include: Optional[types.AInclude] = None
      ) -> Optional['models.A']:
          """Update a single A record.
  
          Parameters
          ----------
          data
              A record data specifying what to update
          where
              A filter to select the unique record to create / update
          include
              Specifies which relations should be loaded on the returned A model
  
          Returns
          -------
          prisma.models.A
              The updated A record
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          a = await A.prisma().update(
              where={
                  'email': 'bcedehfiji',
              },
              data={
                  # data to update the A record to
              },
          )
          ```
          """
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='A',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      async def upsert(
          self,
          where: types.AWhereUniqueInput,
          data: types.AUpsertInput,
          include: Optional[types.AInclude] = None,
      ) -> 'models.A':
          """Updates an existing record or create a new one
  
          Parameters
          ----------
          where
              A filter to select the unique record to create / update
          data
              Data specifying what fields to set on create and update
          include
              Specifies which relations should be loaded on the returned A model
  
          Returns
          -------
          prisma.models.A
              The created or updated A record
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          a = await A.prisma().upsert(
              where={
                  'email': 'bdgjicijhb',
              },
              data={
                  'create': {
                      'email': 'bdgjicijhb',
                      'int': 1513050921,
                      'sInt': 204674734,
                      'bInt': 24811819956,
                  },
                  'update': {
                      'int': 1513050921,
                      'sInt': 204674734,
                      'bInt': 24811819956,
                  },
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='A',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      async def update_many(
          self,
          data: types.AUpdateManyMutationInput,
          where: types.AWhereInput,
      ) -> int:
          """Update multiple A records
  
          Parameters
          ----------
          data
              A data to update the selected A records to
          where
              Filter to select the A records to update
  
          Returns
          -------
          int
              The total number of A records that were updated
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # update all A records
          total = await A.prisma().update_many(
              data={
                  'inc_int': 1678593480
              },
              where={}
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='updateMany',
              model='A',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      @overload
      async def count(
          self,
          select: None = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.AWhereInput] = None,
          cursor: Optional[types.AWhereUniqueInput] = None,
          order: Optional[Union[types.AOrderByInput, List[types.AOrderByInput]]] = None,
      ) -> int:
          """Count the number of A records present in the database
  
          Parameters
          ----------
          select
              Select the A fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              A filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.ACountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = await A.prisma().count()
  
          # results: prisma.types.ACountAggregateOutput
          results = await A.prisma().count(
              select={
                  '_all': True,
                  'inc_sInt': True,
              },
          )
          ```
          """
  
  
      @overload
      async def count(
          self,
          select: types.ACountAggregateInput,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.AWhereInput] = None,
          cursor: Optional[types.AWhereUniqueInput] = None,
          order: Optional[Union[types.AOrderByInput, List[types.AOrderByInput]]] = None,
      ) -> types.ACountAggregateOutput:
          ...
  
      async def count(
          self,
          select: Optional[types.ACountAggregateInput] = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.AWhereInput] = None,
          cursor: Optional[types.AWhereUniqueInput] = None,
          order: Optional[Union[types.AOrderByInput, List[types.AOrderByInput]]] = None,
      ) -> Union[int, types.ACountAggregateOutput]:
          """Count the number of A records present in the database
  
          Parameters
          ----------
          select
              Select the A fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              A filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.ACountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = await A.prisma().count()
  
          # results: prisma.types.ACountAggregateOutput
          results = await A.prisma().count(
              select={
                  '_all': True,
                  'bInt': True,
              },
          )
          ```
          """
  
          # TODO: this selection building should be moved to the QueryBuilder
          #
          # note the distinction between checking for `not select` here and `select is None`
          # later is to handle the case that the given select dictionary is empty, this
          # is a limitation of our types.
          if not select:
              root_selection = ['_count { _all }']
          else:
  
              root_selection = [
                  '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
              ]
  
          if order is not None:
              warnings.warn(
                  'The `order` argument is redundant and will be removed in the next release',
                  DeprecationWarning,
                  stacklevel=2,
              )
  
          resp = await self._client._execute(
              operation='query',
              method='aggregate',
              model='A',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=root_selection,
          )
  
          if select is None:
              return cast(int, resp['data']['result']['_count']['_all'])
          else:
              return cast(types.ACountAggregateOutput, resp['data']['result']['_count'])
  
      async def delete_many(
          self,
          where: Optional[types.AWhereInput] = None
      ) -> int:
          """Delete multiple A records.
  
          Parameters
          ----------
          where
              Optional A filter to find the records to be deleted
  
          Returns
          -------
          int
              The total number of A records that were deleted
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # delete all A records
          total = await A.prisma().delete_many()
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='A',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  class BActions:
      def __init__(self, client: 'Client', model: Type['models.B']) -> None:
          self._client = client
          self._model = model
  
      async def query_raw(
          self,
          query: str,
          *args: Any,
      ) -> List['models.B']:
          """Execute a raw SQL query
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          List[prisma.models.B]
              The records returned by the SQL query
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          users = await B.prisma().query_raw(
              'SELECT * FROM B WHERE id = $1',
              'eadfcbbcb',
          )
          ```
          """
          return await self._client.query_raw(query, *args, model=self._model)
  
      async def query_first(
          self,
          query: str,
          *args: Any,
      ) -> Optional['models.B']:
          """Execute a raw SQL query, returning the first result
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          prisma.models.B
              The first record returned by the SQL query
          None
              The raw SQL query did not return any records
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          user = await B.prisma().query_first(
              'SELECT * FROM B WHERE float = $1',
              648760710.60732,
          )
          ```
          """
          return await self._client.query_first(query, *args, model=self._model)
  
      async def create(
          self,
          data: types.BCreateInput,
          include: Optional[types.BInclude] = None
      ) -> 'models.B':
          """Create a new B record.
  
          Parameters
          ----------
          data
              B record data
          include
              Specifies which relations should be loaded on the returned B model
  
          Returns
          -------
          prisma.models.B
              The created B record
  
          Raises
          ------
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # create a B record from just the required fields
          b = await B.prisma().create(
              data={
                  # data to create a B record
                  'float': 1468890740.62903,
                  'd_float': 1214168082.89861,
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='createOne',
              model='B',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      async def create_many(
          self,
          data: List[types.BCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          """Create multiple B records at once.
  
          This function is *not* available when using SQLite.
  
          Parameters
          ----------
          data
              List of B record data
          skip_duplicates
              Boolean flag for ignoring unique constraint errors
  
          Returns
          -------
          int
              The total number of records created
  
          Raises
          ------
          prisma.errors.UnsupportedDatabaseError
              Attempting to query when using SQLite
          prisma.errors.UniqueViolationError
              A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          total = await B.prisma().create_many(
              data=[
                  {
                      # data to create a B record
                      'float': 658378208.95462,
                      'd_float': 1214809950.104782,
                  },
                  {
                      # data to create a B record
                      'float': 1302734860.89305,
                      'd_float': 280083306.54966,
                  },
              ],
              skip_duplicates=True,
          )
          ```
          """
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = await self._client._execute(
              operation='mutation',
              method='createMany',
              model='B',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def delete(
          self,
          where: types.BWhereUniqueInput,
          include: Optional[types.BInclude] = None
      ) -> Optional['models.B']:
          """Delete a single B record.
  
          Parameters
          ----------
          where
              B filter to select the record to be deleted, must be unique
          include
              Specifies which relations should be loaded on the returned B model
  
          Returns
          -------
          prisma.models.B
              The deleted B record
          None
              Could not find a record to delete
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          b = await B.prisma().delete(
              where={
                  'id': 'hghjaaai',
              },
          )
          ```
          """
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='B',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      async def find_unique(
          self,
          where: types.BWhereUniqueInput,
          include: Optional[types.BInclude] = None
      ) -> Optional['models.B']:
          """Find a unique B record.
  
          Parameters
          ----------
          where
              B filter to find the record, must be unique
          include
              Specifies which relations should be loaded on the returned B model
  
          Returns
          -------
          prisma.models.B
              The found B record
          None
              No record matching the given input could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          b = await B.prisma().find_unique(
              where={
                  'id': 'cajicjjdef',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findUnique',
              model='B',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      async def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.BWhereInput] = None,
          cursor: Optional[types.BWhereUniqueInput] = None,
          include: Optional[types.BInclude] = None,
          order: Optional[Union[types.BOrderByInput, List[types.BOrderByInput]]] = None,
      ) -> List['models.B']:
          """Find multiple B records.
  
          An empty list is returned if no records could be found.
  
          Parameters
          ----------
          take
              Limit the maximum number of B records returned
          skip
              Ignore the first N results
          where
              B filter to select records
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned B model
          order
              Order the returned B records by any field
  
          Returns
          -------
          List[prisma.models.B]
              The list of all B records that could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the first 10 B records
          bs = await B.prisma().find_many(take=10)
  
          # find the first 5 B records ordered by the d_float field
          bs = await B.prisma().find_many(
              take=5,
              order={
                  'd_float': 'desc',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findMany',
              model='B',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [self._model.parse_obj(r) for r in resp['data']['result']]
  
      async def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.BWhereInput] = None,
          cursor: Optional[types.BWhereUniqueInput] = None,
          include: Optional[types.BInclude] = None,
          order: Optional[Union[types.BOrderByInput, List[types.BOrderByInput]]] = None,
      ) -> Optional['models.B']:
          """Find a single B record.
  
          Parameters
          ----------
          skip
              Ignore the first N records
          where
              B filter to select the record
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned B model
          order
              Order the returned B records by any field
  
          Returns
          -------
          prisma.models.B
              The first B record found, matching the given arguments
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the second B record ordered by the id field
          b = await B.prisma().find_first(
              skip=1,
              order={
                  'id': 'desc',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findFirst',
              model='B',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      async def update(
          self,
          data: types.BUpdateInput,
          where: types.BWhereUniqueInput,
          include: Optional[types.BInclude] = None
      ) -> Optional['models.B']:
          """Update a single B record.
  
          Parameters
          ----------
          data
              B record data specifying what to update
          where
              B filter to select the unique record to create / update
          include
              Specifies which relations should be loaded on the returned B model
  
          Returns
          -------
          prisma.models.B
              The updated B record
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          b = await B.prisma().update(
              where={
                  'id': 'cefjaadec',
              },
              data={
                  # data to update the B record to
              },
          )
          ```
          """
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='B',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      async def upsert(
          self,
          where: types.BWhereUniqueInput,
          data: types.BUpsertInput,
          include: Optional[types.BInclude] = None,
      ) -> 'models.B':
          """Updates an existing record or create a new one
  
          Parameters
          ----------
          where
              B filter to select the unique record to create / update
          data
              Data specifying what fields to set on create and update
          include
              Specifies which relations should be loaded on the returned B model
  
          Returns
          -------
          prisma.models.B
              The created or updated B record
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          b = await B.prisma().upsert(
              where={
                  'id': 'ibbigdigd',
              },
              data={
                  'create': {
                      'id': 'ibbigdigd',
                      'float': 1302734860.89305,
                      'd_float': 280083306.54966,
                  },
                  'update': {
                      'float': 1302734860.89305,
                      'd_float': 280083306.54966,
                  },
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='B',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      async def update_many(
          self,
          data: types.BUpdateManyMutationInput,
          where: types.BWhereInput,
      ) -> int:
          """Update multiple B records
  
          Parameters
          ----------
          data
              B data to update the selected B records to
          where
              Filter to select the B records to update
  
          Returns
          -------
          int
              The total number of B records that were updated
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # update all B records
          total = await B.prisma().update_many(
              data={
                  'float': 1388801188.75257
              },
              where={}
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='updateMany',
              model='B',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      @overload
      async def count(
          self,
          select: None = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.BWhereInput] = None,
          cursor: Optional[types.BWhereUniqueInput] = None,
          order: Optional[Union[types.BOrderByInput, List[types.BOrderByInput]]] = None,
      ) -> int:
          """Count the number of B records present in the database
  
          Parameters
          ----------
          select
              Select the B fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              B filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.BCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = await B.prisma().count()
  
          # results: prisma.types.BCountAggregateOutput
          results = await B.prisma().count(
              select={
                  '_all': True,
                  'd_float': True,
              },
          )
          ```
          """
  
  
      @overload
      async def count(
          self,
          select: types.BCountAggregateInput,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.BWhereInput] = None,
          cursor: Optional[types.BWhereUniqueInput] = None,
          order: Optional[Union[types.BOrderByInput, List[types.BOrderByInput]]] = None,
      ) -> types.BCountAggregateOutput:
          ...
  
      async def count(
          self,
          select: Optional[types.BCountAggregateInput] = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.BWhereInput] = None,
          cursor: Optional[types.BWhereUniqueInput] = None,
          order: Optional[Union[types.BOrderByInput, List[types.BOrderByInput]]] = None,
      ) -> Union[int, types.BCountAggregateOutput]:
          """Count the number of B records present in the database
  
          Parameters
          ----------
          select
              Select the B fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              B filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.BCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = await B.prisma().count()
  
          # results: prisma.types.BCountAggregateOutput
          results = await B.prisma().count(
              select={
                  '_all': True,
                  'id': True,
              },
          )
          ```
          """
  
          # TODO: this selection building should be moved to the QueryBuilder
          #
          # note the distinction between checking for `not select` here and `select is None`
          # later is to handle the case that the given select dictionary is empty, this
          # is a limitation of our types.
          if not select:
              root_selection = ['_count { _all }']
          else:
  
              root_selection = [
                  '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
              ]
  
          if order is not None:
              warnings.warn(
                  'The `order` argument is redundant and will be removed in the next release',
                  DeprecationWarning,
                  stacklevel=2,
              )
  
          resp = await self._client._execute(
              operation='query',
              method='aggregate',
              model='B',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=root_selection,
          )
  
          if select is None:
              return cast(int, resp['data']['result']['_count']['_all'])
          else:
              return cast(types.BCountAggregateOutput, resp['data']['result']['_count'])
  
      async def delete_many(
          self,
          where: Optional[types.BWhereInput] = None
      ) -> int:
          """Delete multiple B records.
  
          Parameters
          ----------
          where
              Optional B filter to find the records to be deleted
  
          Returns
          -------
          int
              The total number of B records that were deleted
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # delete all B records
          total = await B.prisma().delete_many()
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='B',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  class CActions:
      def __init__(self, client: 'Client', model: Type['models.C']) -> None:
          self._client = client
          self._model = model
  
      async def query_raw(
          self,
          query: str,
          *args: Any,
      ) -> List['models.C']:
          """Execute a raw SQL query
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          List[prisma.models.C]
              The records returned by the SQL query
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          users = await C.prisma().query_raw(
              'SELECT * FROM C WHERE char = $1',
              'bbihggdcji',
          )
          ```
          """
          return await self._client.query_raw(query, *args, model=self._model)
  
      async def query_first(
          self,
          query: str,
          *args: Any,
      ) -> Optional['models.C']:
          """Execute a raw SQL query, returning the first result
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          prisma.models.C
              The first record returned by the SQL query
          None
              The raw SQL query did not return any records
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          user = await C.prisma().query_first(
              'SELECT * FROM C WHERE v_char = $1',
              'hgjgibdgd',
          )
          ```
          """
          return await self._client.query_first(query, *args, model=self._model)
  
      async def create(
          self,
          data: types.CCreateInput,
          include: Optional[types.CInclude] = None
      ) -> 'models.C':
          """Create a new C record.
  
          Parameters
          ----------
          data
              C record data
          include
              Specifies which relations should be loaded on the returned C model
  
          Returns
          -------
          prisma.models.C
              The created C record
  
          Raises
          ------
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # create a C record from just the required fields
          c = await C.prisma().create(
              data={
                  # data to create a C record
                  'char': 'bcbecjfice',
                  'v_char': 'bacbebhjjd',
                  'text': 'dfbfaddhe',
                  'bit': 'bdcbbieibf',
                  'v_bit': 'dgjhdcggi',
                  'uuid': 'bbjbcdfabd',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='createOne',
              model='C',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      async def create_many(
          self,
          data: List[types.CCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          """Create multiple C records at once.
  
          This function is *not* available when using SQLite.
  
          Parameters
          ----------
          data
              List of C record data
          skip_duplicates
              Boolean flag for ignoring unique constraint errors
  
          Returns
          -------
          int
              The total number of records created
  
          Raises
          ------
          prisma.errors.UnsupportedDatabaseError
              Attempting to query when using SQLite
          prisma.errors.UniqueViolationError
              A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          total = await C.prisma().create_many(
              data=[
                  {
                      # data to create a C record
                      'char': 'gchfgbcec',
                      'v_char': 'bihcjfcjah',
                      'text': 'bhjdcicaii',
                      'bit': 'bibedjhcej',
                      'v_bit': 'bjcdajabfa',
                      'uuid': 'bchhceeeff',
                  },
                  {
                      # data to create a C record
                      'char': 'bbgaifhdaa',
                      'v_char': 'dgbcdaegb',
                      'text': 'beagfbbjig',
                      'bit': 'beicihhijb',
                      'v_bit': 'fgggcdcjg',
                      'uuid': 'ccjbbjigf',
                  },
              ],
              skip_duplicates=True,
          )
          ```
          """
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = await self._client._execute(
              operation='mutation',
              method='createMany',
              model='C',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def delete(
          self,
          where: types.CWhereUniqueInput,
          include: Optional[types.CInclude] = None
      ) -> Optional['models.C']:
          """Delete a single C record.
  
          Parameters
          ----------
          where
              C filter to select the record to be deleted, must be unique
          include
              Specifies which relations should be loaded on the returned C model
  
          Returns
          -------
          prisma.models.C
              The deleted C record
          None
              Could not find a record to delete
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          c = await C.prisma().delete(
              where={
                  # C where unique filter
  
              },
          )
          ```
          """
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='C',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      async def find_unique(
          self,
          where: types.CWhereUniqueInput,
          include: Optional[types.CInclude] = None
      ) -> Optional['models.C']:
          """Find a unique C record.
  
          Parameters
          ----------
          where
              C filter to find the record, must be unique
          include
              Specifies which relations should be loaded on the returned C model
  
          Returns
          -------
          prisma.models.C
              The found C record
          None
              No record matching the given input could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          c = await C.prisma().find_unique(
              where={
                  # C where unique filter
  
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findUnique',
              model='C',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      async def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.CWhereInput] = None,
          cursor: Optional[types.CWhereUniqueInput] = None,
          include: Optional[types.CInclude] = None,
          order: Optional[Union[types.COrderByInput, List[types.COrderByInput]]] = None,
      ) -> List['models.C']:
          """Find multiple C records.
  
          An empty list is returned if no records could be found.
  
          Parameters
          ----------
          take
              Limit the maximum number of C records returned
          skip
              Ignore the first N results
          where
              C filter to select records
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned C model
          order
              Order the returned C records by any field
  
          Returns
          -------
          List[prisma.models.C]
              The list of all C records that could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the first 10 C records
          cs = await C.prisma().find_many(take=10)
  
          # find the first 5 C records ordered by the text field
          cs = await C.prisma().find_many(
              take=5,
              order={
                  'text': 'desc',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findMany',
              model='C',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [self._model.parse_obj(r) for r in resp['data']['result']]
  
      async def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.CWhereInput] = None,
          cursor: Optional[types.CWhereUniqueInput] = None,
          include: Optional[types.CInclude] = None,
          order: Optional[Union[types.COrderByInput, List[types.COrderByInput]]] = None,
      ) -> Optional['models.C']:
          """Find a single C record.
  
          Parameters
          ----------
          skip
              Ignore the first N records
          where
              C filter to select the record
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned C model
          order
              Order the returned C records by any field
  
          Returns
          -------
          prisma.models.C
              The first C record found, matching the given arguments
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the second C record ordered by the bit field
          c = await C.prisma().find_first(
              skip=1,
              order={
                  'bit': 'desc',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findFirst',
              model='C',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      async def update(
          self,
          data: types.CUpdateInput,
          where: types.CWhereUniqueInput,
          include: Optional[types.CInclude] = None
      ) -> Optional['models.C']:
          """Update a single C record.
  
          Parameters
          ----------
          data
              C record data specifying what to update
          where
              C filter to select the unique record to create / update
          include
              Specifies which relations should be loaded on the returned C model
  
          Returns
          -------
          prisma.models.C
              The updated C record
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          c = await C.prisma().update(
              where={
                  # C where unique filter
  
              },
              data={
                  # data to update the C record to
              },
          )
          ```
          """
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='C',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      async def upsert(
          self,
          where: types.CWhereUniqueInput,
          data: types.CUpsertInput,
          include: Optional[types.CInclude] = None,
      ) -> 'models.C':
          """Updates an existing record or create a new one
  
          Parameters
          ----------
          where
              C filter to select the unique record to create / update
          data
              Data specifying what fields to set on create and update
          include
              Specifies which relations should be loaded on the returned C model
  
          Returns
          -------
          prisma.models.C
              The created or updated C record
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          c = await C.prisma().upsert(
              where={
                  # C where unique filter
              },
              data={
                  'create': {
                      # C data to be set if the record does not exist
                  },
                  'update': {
                      # C data to be set if the record does exist
                  },
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='C',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      async def update_many(
          self,
          data: types.CUpdateManyMutationInput,
          where: types.CWhereInput,
      ) -> int:
          """Update multiple C records
  
          Parameters
          ----------
          data
              C data to update the selected C records to
          where
              Filter to select the C records to update
  
          Returns
          -------
          int
              The total number of C records that were updated
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # update all C records
          total = await C.prisma().update_many(
              data={
                  'v_bit': 'bhfaabbaha'
              },
              where={}
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='updateMany',
              model='C',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      @overload
      async def count(
          self,
          select: None = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.CWhereInput] = None,
          cursor: Optional[types.CWhereUniqueInput] = None,
          order: Optional[Union[types.COrderByInput, List[types.COrderByInput]]] = None,
      ) -> int:
          """Count the number of C records present in the database
  
          Parameters
          ----------
          select
              Select the C fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              C filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.CCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = await C.prisma().count()
  
          # results: prisma.types.CCountAggregateOutput
          results = await C.prisma().count(
              select={
                  '_all': True,
                  'uuid': True,
              },
          )
          ```
          """
  
  
      @overload
      async def count(
          self,
          select: types.CCountAggregateInput,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.CWhereInput] = None,
          cursor: Optional[types.CWhereUniqueInput] = None,
          order: Optional[Union[types.COrderByInput, List[types.COrderByInput]]] = None,
      ) -> types.CCountAggregateOutput:
          ...
  
      async def count(
          self,
          select: Optional[types.CCountAggregateInput] = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.CWhereInput] = None,
          cursor: Optional[types.CWhereUniqueInput] = None,
          order: Optional[Union[types.COrderByInput, List[types.COrderByInput]]] = None,
      ) -> Union[int, types.CCountAggregateOutput]:
          """Count the number of C records present in the database
  
          Parameters
          ----------
          select
              Select the C fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              C filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.CCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = await C.prisma().count()
  
          # results: prisma.types.CCountAggregateOutput
          results = await C.prisma().count(
              select={
                  '_all': True,
                  'char': True,
              },
          )
          ```
          """
  
          # TODO: this selection building should be moved to the QueryBuilder
          #
          # note the distinction between checking for `not select` here and `select is None`
          # later is to handle the case that the given select dictionary is empty, this
          # is a limitation of our types.
          if not select:
              root_selection = ['_count { _all }']
          else:
  
              root_selection = [
                  '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
              ]
  
          if order is not None:
              warnings.warn(
                  'The `order` argument is redundant and will be removed in the next release',
                  DeprecationWarning,
                  stacklevel=2,
              )
  
          resp = await self._client._execute(
              operation='query',
              method='aggregate',
              model='C',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=root_selection,
          )
  
          if select is None:
              return cast(int, resp['data']['result']['_count']['_all'])
          else:
              return cast(types.CCountAggregateOutput, resp['data']['result']['_count'])
  
      async def delete_many(
          self,
          where: Optional[types.CWhereInput] = None
      ) -> int:
          """Delete multiple C records.
  
          Parameters
          ----------
          where
              Optional C filter to find the records to be deleted
  
          Returns
          -------
          int
              The total number of C records that were deleted
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # delete all C records
          total = await C.prisma().delete_many()
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='C',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  class DActions:
      def __init__(self, client: 'Client', model: Type['models.D']) -> None:
          self._client = client
          self._model = model
  
      async def query_raw(
          self,
          query: str,
          *args: Any,
      ) -> List['models.D']:
          """Execute a raw SQL query
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          List[prisma.models.D]
              The records returned by the SQL query
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          users = await D.prisma().query_raw(
              'SELECT * FROM D WHERE id = $1',
              'ebajedhhf',
          )
          ```
          """
          return await self._client.query_raw(query, *args, model=self._model)
  
      async def query_first(
          self,
          query: str,
          *args: Any,
      ) -> Optional['models.D']:
          """Execute a raw SQL query, returning the first result
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          prisma.models.D
              The first record returned by the SQL query
          None
              The raw SQL query did not return any records
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          user = await D.prisma().query_first(
              'SELECT * FROM D WHERE bool = $1',
              True,
          )
          ```
          """
          return await self._client.query_first(query, *args, model=self._model)
  
      async def create(
          self,
          data: types.DCreateInput,
          include: Optional[types.DInclude] = None
      ) -> 'models.D':
          """Create a new D record.
  
          Parameters
          ----------
          data
              D record data
          include
              Specifies which relations should be loaded on the returned D model
  
          Returns
          -------
          prisma.models.D
              The created D record
  
          Raises
          ------
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # create a D record from just the required fields
          d = await D.prisma().create(
              data={
                  # data to create a D record
                  'bool': False,
                  'xml': 'biacbiieja',
                  'json_': Json({'cjejbgbff': True}),
                  'jsonb': Json({'fgeahddae': True}),
                  'binary': Base64.encode(b'diageigcf'),
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='createOne',
              model='D',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      async def create_many(
          self,
          data: List[types.DCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          """Create multiple D records at once.
  
          This function is *not* available when using SQLite.
  
          Parameters
          ----------
          data
              List of D record data
          skip_duplicates
              Boolean flag for ignoring unique constraint errors
  
          Returns
          -------
          int
              The total number of records created
  
          Raises
          ------
          prisma.errors.UnsupportedDatabaseError
              Attempting to query when using SQLite
          prisma.errors.UniqueViolationError
              A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          total = await D.prisma().create_many(
              data=[
                  {
                      # data to create a D record
                      'bool': True,
                      'xml': 'ibgebbjch',
                      'json_': Json({'baieajjiee': True}),
                      'jsonb': Json({'bahjhaccfd': True}),
                      'binary': Base64.encode(b'hffhfabhi'),
                  },
                  {
                      # data to create a D record
                      'bool': False,
                      'xml': 'cfjagbbae',
                      'json_': Json({'bbbfhdidef': True}),
                      'jsonb': Json({'bdadhibhec': True}),
                      'binary': Base64.encode(b'bfhdjaiejf'),
                  },
              ],
              skip_duplicates=True,
          )
          ```
          """
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = await self._client._execute(
              operation='mutation',
              method='createMany',
              model='D',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def delete(
          self,
          where: types.DWhereUniqueInput,
          include: Optional[types.DInclude] = None
      ) -> Optional['models.D']:
          """Delete a single D record.
  
          Parameters
          ----------
          where
              D filter to select the record to be deleted, must be unique
          include
              Specifies which relations should be loaded on the returned D model
  
          Returns
          -------
          prisma.models.D
              The deleted D record
          None
              Could not find a record to delete
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          d = await D.prisma().delete(
              where={
                  'id': 'bbjfijjadg',
              },
          )
          ```
          """
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='D',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      async def find_unique(
          self,
          where: types.DWhereUniqueInput,
          include: Optional[types.DInclude] = None
      ) -> Optional['models.D']:
          """Find a unique D record.
  
          Parameters
          ----------
          where
              D filter to find the record, must be unique
          include
              Specifies which relations should be loaded on the returned D model
  
          Returns
          -------
          prisma.models.D
              The found D record
          None
              No record matching the given input could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          d = await D.prisma().find_unique(
              where={
                  'id': 'hdjacbehh',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findUnique',
              model='D',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      async def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.DWhereInput] = None,
          cursor: Optional[types.DWhereUniqueInput] = None,
          include: Optional[types.DInclude] = None,
          order: Optional[Union[types.DOrderByInput, List[types.DOrderByInput]]] = None,
      ) -> List['models.D']:
          """Find multiple D records.
  
          An empty list is returned if no records could be found.
  
          Parameters
          ----------
          take
              Limit the maximum number of D records returned
          skip
              Ignore the first N results
          where
              D filter to select records
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned D model
          order
              Order the returned D records by any field
  
          Returns
          -------
          List[prisma.models.D]
              The list of all D records that could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the first 10 D records
          ds = await D.prisma().find_many(take=10)
  
          # find the first 5 D records ordered by the xml field
          ds = await D.prisma().find_many(
              take=5,
              order={
                  'xml': 'desc',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findMany',
              model='D',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [self._model.parse_obj(r) for r in resp['data']['result']]
  
      async def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.DWhereInput] = None,
          cursor: Optional[types.DWhereUniqueInput] = None,
          include: Optional[types.DInclude] = None,
          order: Optional[Union[types.DOrderByInput, List[types.DOrderByInput]]] = None,
      ) -> Optional['models.D']:
          """Find a single D record.
  
          Parameters
          ----------
          skip
              Ignore the first N records
          where
              D filter to select the record
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned D model
          order
              Order the returned D records by any field
  
          Returns
          -------
          prisma.models.D
              The first D record found, matching the given arguments
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the second D record ordered by the json_ field
          d = await D.prisma().find_first(
              skip=1,
              order={
                  'json_': 'desc',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findFirst',
              model='D',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      async def update(
          self,
          data: types.DUpdateInput,
          where: types.DWhereUniqueInput,
          include: Optional[types.DInclude] = None
      ) -> Optional['models.D']:
          """Update a single D record.
  
          Parameters
          ----------
          data
              D record data specifying what to update
          where
              D filter to select the unique record to create / update
          include
              Specifies which relations should be loaded on the returned D model
  
          Returns
          -------
          prisma.models.D
              The updated D record
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          d = await D.prisma().update(
              where={
                  'id': 'bhcccbeaba',
              },
              data={
                  # data to update the D record to
              },
          )
          ```
          """
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='D',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      async def upsert(
          self,
          where: types.DWhereUniqueInput,
          data: types.DUpsertInput,
          include: Optional[types.DInclude] = None,
      ) -> 'models.D':
          """Updates an existing record or create a new one
  
          Parameters
          ----------
          where
              D filter to select the unique record to create / update
          data
              Data specifying what fields to set on create and update
          include
              Specifies which relations should be loaded on the returned D model
  
          Returns
          -------
          prisma.models.D
              The created or updated D record
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          d = await D.prisma().upsert(
              where={
                  'id': 'bcgjbdgjdj',
              },
              data={
                  'create': {
                      'id': 'bcgjbdgjdj',
                      'bool': False,
                      'xml': 'cfjagbbae',
                      'json_': Json({'bbbfhdidef': True}),
                      'jsonb': Json({'bdadhibhec': True}),
                      'binary': Base64.encode(b'bfhdjaiejf'),
                  },
                  'update': {
                      'bool': False,
                      'xml': 'cfjagbbae',
                      'json_': Json({'bbbfhdidef': True}),
                      'jsonb': Json({'bdadhibhec': True}),
                      'binary': Base64.encode(b'bfhdjaiejf'),
                  },
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='D',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      async def update_many(
          self,
          data: types.DUpdateManyMutationInput,
          where: types.DWhereInput,
      ) -> int:
          """Update multiple D records
  
          Parameters
          ----------
          data
              D data to update the selected D records to
          where
              Filter to select the D records to update
  
          Returns
          -------
          int
              The total number of D records that were updated
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # update all D records
          total = await D.prisma().update_many(
              data={
                  'jsonb': Json({'fhdbhifae': True})
              },
              where={}
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='updateMany',
              model='D',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      @overload
      async def count(
          self,
          select: None = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.DWhereInput] = None,
          cursor: Optional[types.DWhereUniqueInput] = None,
          order: Optional[Union[types.DOrderByInput, List[types.DOrderByInput]]] = None,
      ) -> int:
          """Count the number of D records present in the database
  
          Parameters
          ----------
          select
              Select the D fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              D filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.DCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = await D.prisma().count()
  
          # results: prisma.types.DCountAggregateOutput
          results = await D.prisma().count(
              select={
                  '_all': True,
                  'binary': True,
              },
          )
          ```
          """
  
  
      @overload
      async def count(
          self,
          select: types.DCountAggregateInput,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.DWhereInput] = None,
          cursor: Optional[types.DWhereUniqueInput] = None,
          order: Optional[Union[types.DOrderByInput, List[types.DOrderByInput]]] = None,
      ) -> types.DCountAggregateOutput:
          ...
  
      async def count(
          self,
          select: Optional[types.DCountAggregateInput] = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.DWhereInput] = None,
          cursor: Optional[types.DWhereUniqueInput] = None,
          order: Optional[Union[types.DOrderByInput, List[types.DOrderByInput]]] = None,
      ) -> Union[int, types.DCountAggregateOutput]:
          """Count the number of D records present in the database
  
          Parameters
          ----------
          select
              Select the D fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              D filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.DCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = await D.prisma().count()
  
          # results: prisma.types.DCountAggregateOutput
          results = await D.prisma().count(
              select={
                  '_all': True,
                  'id': True,
              },
          )
          ```
          """
  
          # TODO: this selection building should be moved to the QueryBuilder
          #
          # note the distinction between checking for `not select` here and `select is None`
          # later is to handle the case that the given select dictionary is empty, this
          # is a limitation of our types.
          if not select:
              root_selection = ['_count { _all }']
          else:
  
              root_selection = [
                  '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
              ]
  
          if order is not None:
              warnings.warn(
                  'The `order` argument is redundant and will be removed in the next release',
                  DeprecationWarning,
                  stacklevel=2,
              )
  
          resp = await self._client._execute(
              operation='query',
              method='aggregate',
              model='D',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=root_selection,
          )
  
          if select is None:
              return cast(int, resp['data']['result']['_count']['_all'])
          else:
              return cast(types.DCountAggregateOutput, resp['data']['result']['_count'])
  
      async def delete_many(
          self,
          where: Optional[types.DWhereInput] = None
      ) -> int:
          """Delete multiple D records.
  
          Parameters
          ----------
          where
              Optional D filter to find the records to be deleted
  
          Returns
          -------
          int
              The total number of D records that were deleted
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # delete all D records
          total = await D.prisma().delete_many()
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='D',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  class EActions:
      def __init__(self, client: 'Client', model: Type['models.E']) -> None:
          self._client = client
          self._model = model
  
      async def query_raw(
          self,
          query: str,
          *args: Any,
      ) -> List['models.E']:
          """Execute a raw SQL query
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          List[prisma.models.E]
              The records returned by the SQL query
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          users = await E.prisma().query_raw(
              'SELECT * FROM E WHERE id = $1',
              'beeacgfcej',
          )
          ```
          """
          return await self._client.query_raw(query, *args, model=self._model)
  
      async def query_first(
          self,
          query: str,
          *args: Any,
      ) -> Optional['models.E']:
          """Execute a raw SQL query, returning the first result
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          prisma.models.E
              The first record returned by the SQL query
          None
              The raw SQL query did not return any records
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          user = await E.prisma().query_first(
              'SELECT * FROM E WHERE date = $1',
              datetime.datetime.utcnow(),
          )
          ```
          """
          return await self._client.query_first(query, *args, model=self._model)
  
      async def create(
          self,
          data: types.ECreateInput,
          include: Optional[types.EInclude] = None
      ) -> 'models.E':
          """Create a new E record.
  
          Parameters
          ----------
          data
              E record data
          include
              Specifies which relations should be loaded on the returned E model
  
          Returns
          -------
          prisma.models.E
              The created E record
  
          Raises
          ------
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # create a E record from just the required fields
          e = await E.prisma().create(
              data={
                  # data to create a E record
                  'date': datetime.datetime.utcnow(),
                  'time': datetime.datetime.utcnow(),
                  'ts': datetime.datetime.utcnow(),
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='createOne',
              model='E',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      async def create_many(
          self,
          data: List[types.ECreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          """Create multiple E records at once.
  
          This function is *not* available when using SQLite.
  
          Parameters
          ----------
          data
              List of E record data
          skip_duplicates
              Boolean flag for ignoring unique constraint errors
  
          Returns
          -------
          int
              The total number of records created
  
          Raises
          ------
          prisma.errors.UnsupportedDatabaseError
              Attempting to query when using SQLite
          prisma.errors.UniqueViolationError
              A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          total = await E.prisma().create_many(
              data=[
                  {
                      # data to create a E record
                      'date': datetime.datetime.utcnow(),
                      'time': datetime.datetime.utcnow(),
                      'ts': datetime.datetime.utcnow(),
                  },
                  {
                      # data to create a E record
                      'date': datetime.datetime.utcnow(),
                      'time': datetime.datetime.utcnow(),
                      'ts': datetime.datetime.utcnow(),
                  },
              ],
              skip_duplicates=True,
          )
          ```
          """
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = await self._client._execute(
              operation='mutation',
              method='createMany',
              model='E',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      async def delete(
          self,
          where: types.EWhereUniqueInput,
          include: Optional[types.EInclude] = None
      ) -> Optional['models.E']:
          """Delete a single E record.
  
          Parameters
          ----------
          where
              E filter to select the record to be deleted, must be unique
          include
              Specifies which relations should be loaded on the returned E model
  
          Returns
          -------
          prisma.models.E
              The deleted E record
          None
              Could not find a record to delete
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          e = await E.prisma().delete(
              where={
                  'id': 'bbifhdiicc',
              },
          )
          ```
          """
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='E',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      async def find_unique(
          self,
          where: types.EWhereUniqueInput,
          include: Optional[types.EInclude] = None
      ) -> Optional['models.E']:
          """Find a unique E record.
  
          Parameters
          ----------
          where
              E filter to find the record, must be unique
          include
              Specifies which relations should be loaded on the returned E model
  
          Returns
          -------
          prisma.models.E
              The found E record
          None
              No record matching the given input could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          e = await E.prisma().find_unique(
              where={
                  'id': 'bgjeccejad',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findUnique',
              model='E',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      async def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.EWhereInput] = None,
          cursor: Optional[types.EWhereUniqueInput] = None,
          include: Optional[types.EInclude] = None,
          order: Optional[Union[types.EOrderByInput, List[types.EOrderByInput]]] = None,
      ) -> List['models.E']:
          """Find multiple E records.
  
          An empty list is returned if no records could be found.
  
          Parameters
          ----------
          take
              Limit the maximum number of E records returned
          skip
              Ignore the first N results
          where
              E filter to select records
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned E model
          order
              Order the returned E records by any field
  
          Returns
          -------
          List[prisma.models.E]
              The list of all E records that could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the first 10 E records
          es = await E.prisma().find_many(take=10)
  
          # find the first 5 E records ordered by the time field
          es = await E.prisma().find_many(
              take=5,
              order={
                  'time': 'desc',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findMany',
              model='E',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [self._model.parse_obj(r) for r in resp['data']['result']]
  
      async def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.EWhereInput] = None,
          cursor: Optional[types.EWhereUniqueInput] = None,
          include: Optional[types.EInclude] = None,
          order: Optional[Union[types.EOrderByInput, List[types.EOrderByInput]]] = None,
      ) -> Optional['models.E']:
          """Find a single E record.
  
          Parameters
          ----------
          skip
              Ignore the first N records
          where
              E filter to select the record
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned E model
          order
              Order the returned E records by any field
  
          Returns
          -------
          prisma.models.E
              The first E record found, matching the given arguments
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the second E record ordered by the ts field
          e = await E.prisma().find_first(
              skip=1,
              order={
                  'ts': 'desc',
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='query',
              method='findFirst',
              model='E',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      async def update(
          self,
          data: types.EUpdateInput,
          where: types.EWhereUniqueInput,
          include: Optional[types.EInclude] = None
      ) -> Optional['models.E']:
          """Update a single E record.
  
          Parameters
          ----------
          data
              E record data specifying what to update
          where
              E filter to select the unique record to create / update
          include
              Specifies which relations should be loaded on the returned E model
  
          Returns
          -------
          prisma.models.E
              The updated E record
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          e = await E.prisma().update(
              where={
                  'id': 'bjagdgabbg',
              },
              data={
                  # data to update the E record to
              },
          )
          ```
          """
          try:
              resp = await self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='E',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      async def upsert(
          self,
          where: types.EWhereUniqueInput,
          data: types.EUpsertInput,
          include: Optional[types.EInclude] = None,
      ) -> 'models.E':
          """Updates an existing record or create a new one
  
          Parameters
          ----------
          where
              E filter to select the unique record to create / update
          data
              Data specifying what fields to set on create and update
          include
              Specifies which relations should be loaded on the returned E model
  
          Returns
          -------
          prisma.models.E
              The created or updated E record
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          e = await E.prisma().upsert(
              where={
                  'id': 'bjbbcffdij',
              },
              data={
                  'create': {
                      'id': 'bjbbcffdij',
                      'date': datetime.datetime.utcnow(),
                      'time': datetime.datetime.utcnow(),
                      'ts': datetime.datetime.utcnow(),
                  },
                  'update': {
                      'date': datetime.datetime.utcnow(),
                      'time': datetime.datetime.utcnow(),
                      'ts': datetime.datetime.utcnow(),
                  },
              },
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='E',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      async def update_many(
          self,
          data: types.EUpdateManyMutationInput,
          where: types.EWhereInput,
      ) -> int:
          """Update multiple E records
  
          Parameters
          ----------
          data
              E data to update the selected E records to
          where
              Filter to select the E records to update
  
          Returns
          -------
          int
              The total number of E records that were updated
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # update all E records
          total = await E.prisma().update_many(
              data={
                  'id': 'begcgchdi'
              },
              where={}
          )
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='updateMany',
              model='E',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      @overload
      async def count(
          self,
          select: None = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.EWhereInput] = None,
          cursor: Optional[types.EWhereUniqueInput] = None,
          order: Optional[Union[types.EOrderByInput, List[types.EOrderByInput]]] = None,
      ) -> int:
          """Count the number of E records present in the database
  
          Parameters
          ----------
          select
              Select the E fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              E filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.ECountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = await E.prisma().count()
  
          # results: prisma.types.ECountAggregateOutput
          results = await E.prisma().count(
              select={
                  '_all': True,
                  'date': True,
              },
          )
          ```
          """
  
  
      @overload
      async def count(
          self,
          select: types.ECountAggregateInput,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.EWhereInput] = None,
          cursor: Optional[types.EWhereUniqueInput] = None,
          order: Optional[Union[types.EOrderByInput, List[types.EOrderByInput]]] = None,
      ) -> types.ECountAggregateOutput:
          ...
  
      async def count(
          self,
          select: Optional[types.ECountAggregateInput] = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.EWhereInput] = None,
          cursor: Optional[types.EWhereUniqueInput] = None,
          order: Optional[Union[types.EOrderByInput, List[types.EOrderByInput]]] = None,
      ) -> Union[int, types.ECountAggregateOutput]:
          """Count the number of E records present in the database
  
          Parameters
          ----------
          select
              Select the E fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              E filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.ECountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = await E.prisma().count()
  
          # results: prisma.types.ECountAggregateOutput
          results = await E.prisma().count(
              select={
                  '_all': True,
                  'time': True,
              },
          )
          ```
          """
  
          # TODO: this selection building should be moved to the QueryBuilder
          #
          # note the distinction between checking for `not select` here and `select is None`
          # later is to handle the case that the given select dictionary is empty, this
          # is a limitation of our types.
          if not select:
              root_selection = ['_count { _all }']
          else:
  
              root_selection = [
                  '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
              ]
  
          if order is not None:
              warnings.warn(
                  'The `order` argument is redundant and will be removed in the next release',
                  DeprecationWarning,
                  stacklevel=2,
              )
  
          resp = await self._client._execute(
              operation='query',
              method='aggregate',
              model='E',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=root_selection,
          )
  
          if select is None:
              return cast(int, resp['data']['result']['_count']['_all'])
          else:
              return cast(types.ECountAggregateOutput, resp['data']['result']['_count'])
  
      async def delete_many(
          self,
          where: Optional[types.EWhereInput] = None
      ) -> int:
          """Delete multiple E records.
  
          Parameters
          ----------
          where
              Optional E filter to find the records to be deleted
  
          Returns
          -------
          int
              The total number of E records that were deleted
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # delete all E records
          total = await E.prisma().delete_many()
          ```
          """
          resp = await self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='E',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  from . import models
  
  '
---
# name: test_async[builder.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Callable,
      Generic,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  from typing_extensions import TypedDict, Literal
  
  # -- template builder.py.jinja --
  
  # TODO: the QueryBuilder should validate and add type information context.
  #       currently we just naively iterate through arguments and encode them
  #       using standard json when we don't have any special casing for it.
  #       this makes it more difficult to add support for non-standard types
  #       such as the `Json` type.
  # TODO: optimise for performance (switch to c / cython?)
  # TODO: pass context around differently, relying on the builder instance is
  #       not ideal, context should be local to each node
  
  
  import json
  import logging
  import inspect
  from textwrap import indent
  from datetime import timezone
  from abc import abstractmethod, ABC
  from functools import singledispatch
  
  from . import fields
  from .types import Serializable
  from .errors import UnknownModelError, UnknownRelationalFieldError
  from ._constants import QUERY_BUILDER_ALIASES
  
  
  log: logging.Logger = logging.getLogger(__name__)
  
  ChildType = Union['AbstractNode', str]
  
  
  DEFAULT_FIELDS_MAPPING: Dict[str, List[str]] = {
      'Post': [
          'id',
          'created_at',
          'title',
          'content',
          'published',
          'author_id',
      ],
      'User': [
          'id',
          'email',
          'int',
          'optional_int',
          'float',
          'optional_float',
          'string',
          'optional_string',
          'enum',
          'optional_enum',
          'boolean',
          'optional_boolean',
      ],
      'M': [
          'id',
          'int',
          'optional_int',
          'float',
          'optional_float',
          'string',
          'optional_string',
          'enum',
          'optional_enum',
          'boolean',
          'optional_boolean',
      ],
      'N': [
          'id',
          'int',
          'optional_int',
          'float',
          'optional_float',
          'string',
          'optional_string',
          'json_',
          'optional_json',
          'enum',
          'optional_enum',
          'boolean',
          'optional_boolean',
      ],
      'OneOptional': [
          'id',
          'int',
          'optional_int',
          'float',
          'optional_float',
          'string',
          'optional_string',
          'enum',
          'optional_enum',
          'boolean',
          'optional_boolean',
      ],
      'ManyRequired': [
          'id',
          'one_optional_id',
          'int',
          'optional_int',
          'float',
          'optional_float',
          'string',
          'optional_string',
          'enum',
          'optional_enum',
          'boolean',
          'optional_boolean',
      ],
      'Lists': [
          'id',
          'strings',
          'bytes',
          'dates',
          'bools',
          'ints',
          'floats',
          'bigints',
          'json_objects',
      ],
      'A': [
          'email',
          'name',
          'int',
          'sInt',
          'inc_int',
          'inc_sInt',
          'bInt',
          'inc_bInt',
      ],
      'B': [
          'id',
          'float',
          'd_float',
      ],
      'C': [
          'char',
          'v_char',
          'text',
          'bit',
          'v_bit',
          'uuid',
      ],
      'D': [
          'id',
          'bool',
          'xml',
          'json_',
          'jsonb',
          'binary',
      ],
      'E': [
          'id',
          'date',
          'time',
          'ts',
      ],
  }
  
  RELATIONAL_FIELD_MAPPINGS: Dict[str, Dict[str, str]] = {
      'Post': {
          'author': 'User',
      },
      'User': {
          'posts': 'Post',
      },
      'M': {
          'n': 'N',
      },
      'N': {
          'm': 'M',
      },
      'OneOptional': {
          'many': 'ManyRequired',
      },
      'ManyRequired': {
          'one': 'OneOptional',
      },
      'Lists': {
      },
      'A': {
      },
      'B': {
      },
      'C': {
      },
      'D': {
      },
      'E': {
      },
  }
  
  
  class QueryBuilder:
      # prisma method
      method: str
  
      # GraphQL operation
      operation: str
  
      # prisma model
      model: Optional[str]
  
      # mapping of relational fields to include in the result
      include: Optional[Dict[str, Any]]
  
      # arguments to pass to the query
      arguments: Dict[str, Any]
  
      # list of fields to select
      root_selection: Optional[List[str]]
  
      def __init__(
          self,
          *,
          method: str,
          operation: str,
          arguments: Dict[str, Any],
          model: Optional[str] = None,
          root_selection: Optional[List[str]] = None
      ) -> None:
          self.model = model
          self.method = method
          self.operation = operation
          self.root_selection = root_selection
          self.arguments = args = self._transform_aliases(arguments)
          self.include = args.pop('include', None)
  
      def build(self) -> str:
          """Build the payload that should be sent to the QueryEngine"""
          data = {
              'variables': {},
              'operation_name': self.operation,
              'query': self.build_query(),
          }
          return dumps(data)
  
      def build_query(self) -> str:
          """Build the GraphQL query
  
          Example query:
  
          query {
            result: findUniqueUser
            (
              where: {
                id: "ckq23ky3003510r8zll5m2hma"
              }
            )
            {
              id
              name
              profile {
                id
                user_id
                bio
              }
            }
          }
          """
          query = self._create_root_node().render()
          log.debug('Generated query: \n%s', query)
          return query
  
      def _create_root_node(self) -> 'RootNode':
          root = RootNode(builder=self)
          root.add(ResultNode.create(self))
          root.add(
              Selection.create(
                  self,
                  model=self.model,
                  include=self.include,
                  root_selection=self.root_selection,
              )
          )
          return root
  
      def get_default_fields(self, model: str) -> List[str]:
          """Returns a list of all the scalar fields of a model
  
          Raises UnknownModelError if the current model cannot be found.
          """
          try:
              return DEFAULT_FIELDS_MAPPING[model].copy()
          except KeyError as exc:
              raise UnknownModelError(model) from exc
  
      def get_relational_model(self, current_model: str, field: str) -> str:
          """Returns the model that the field is related to.
  
          Raises UnknownModelError if the current model is invalid.
          Raises UnknownRelationalFieldError if the field does not exist.
          """
          try:
              mappings = RELATIONAL_FIELD_MAPPINGS[current_model]
          except KeyError as exc:
              raise UnknownModelError(current_model) from exc
  
          try:
              return mappings[field]
          except KeyError as exc:
              raise UnknownRelationalFieldError(model=current_model, field=field) from exc
  
      def _transform_aliases(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
          """Transform dict keys to match global aliases
  
          e.g. order_by -> orderBy
          """
          transformed = dict()
          for key, value in arguments.items():
              alias = QUERY_BUILDER_ALIASES.get(key, key)
              if isinstance(value, dict):
                  transformed[alias] = self._transform_aliases(arguments=value)
              else:
                  transformed[alias] = value
          return transformed
  
  
  class AbstractNode(ABC):
      @abstractmethod
      def render(self) -> Optional[str]:
          """Render the node to a string
  
          None is returned if the node should not be rendered.
          """
          ...
  
      def should_render(self) -> bool:
          """If True, rendering of the node is skipped
  
          Useful for some nodes as they should only actually
          be rendered if they have any children.
          """
          return True
  
  
  class Node(AbstractNode):
      """Base node handling rendering of child nodes"""
      joiner: str
      indent: str
      builder: QueryBuilder
      children: List[ChildType]
  
      def __init__(
          self,
          builder: QueryBuilder,
          *,
          joiner: str = '\n',
          indent: str = '  ',
          children: Optional[List[ChildType]] = None
      ) -> None:
          self.builder = builder
          self.joiner = joiner
          self.indent = indent
          self.children = children if children is not None else []
  
      def enter(self) -> Optional[str]:
          """Get the string used to enter the node.
  
          This string will be rendered *before* the children.
          """
          return None
  
      def depart(self) -> Optional[str]:
          """Get the string used to depart the node.
  
          This string will be rendered *after* the children.
          """
          return None
  
      def render(self) -> Optional[str]:
          """Render the node and it's children and to string.
  
          Rendering a node involves 4 steps:
  
          1. Entering the node
          2. Rendering it's children
          3. Departing the node
          4. Joining the previous steps together into a single string
          """
          if not self.should_render():
              return None
  
          strings: List[str] = []
          entered = self.enter()
          if entered is not None:
              strings.append(entered)
  
          for child in self.children:
              content: Optional[str] = None
  
              if isinstance(child, str):
                  content = child
              else:
                  content = child.render()
  
              if content:
                  strings.append(indent(content, self.indent))
  
          departed = self.depart()
          if departed is not None:
              strings.append(departed)
  
          return self.joiner.join(strings)
  
      def add(self, child: ChildType) -> None:
          """Add a child"""
          self.children.append(child)
  
      def create_children(self) -> List[ChildType]:
          """Create the node's children
  
          If children are passed to the constructor, the children
          returned from this method are used to extend the already
          set children.
          """
          return []
  
      @classmethod
      def create(cls, builder: Optional[QueryBuilder] = None, **kwargs: Any) -> 'Node':
          """Create the node and its children
  
          This is useful for subclasses that add extra attributes in __init__
          """
          kwargs.setdefault('builder', builder)
          node = cls(**kwargs)
          node.children.extend(node.create_children())
          return node
  
  
  class RootNode(Node):
      """Rendered node examples:
  
      query {
          <children>
      }
  
      or
  
      mutation {
          <children>
      }
      """
  
      def enter(self) -> str:
          return f'{self.builder.operation} {{'
  
      def depart(self) -> str:
          return '}'
  
      def render(self) -> str:
          content = super().render()
          if not content:  # pragma: no cover
              # this should never happen.
              # render() is typed to return None if the node
              # should not be rendered but as this node will
              # always be rendered it should always return
              # a non-empty string.
              raise RuntimeError('Could not generate query.')
          return content
  
  
  class ResultNode(Node):
      """Rendered node examples:
  
      result: findUniqueUser
          <children>
  
      or
  
      result: executeRaw
          <children>
      """
      def __init__(self, indent: str = '', **kwargs: Any) -> None:
          super().__init__(indent=indent, **kwargs)
  
      def enter(self) -> str:
          model = self.builder.model
          if model is not None:
              return f'result: {self.builder.method}{model}'
  
          return f'result: {self.builder.method}'
  
      def depart(self) -> Optional[str]:
          return None
  
      def create_children(self) -> List[ChildType]:
          return [
              Arguments.create(
                  self.builder,
                  arguments=self.builder.arguments,
              )
          ]
  
  
  class Arguments(Node):
      """Rendered node example:
  
      (
          key1: "1"
          key2: "[\"John\",\"123\"]"
          key3: true
          key4: {
              data: true
          }
      )
      """
      arguments: Dict[str, Any]
  
      def __init__(self, arguments: Dict[str, Any], **kwargs: Any) -> None:
          super().__init__(**kwargs)
          self.arguments = arguments
  
      def should_render(self) -> bool:
          return bool(self.children)
  
      def enter(self) -> str:
          return '('
  
      def depart(self) -> str:
          return ')'
  
      def create_children(self, arguments: Optional[Dict[str, Any]] = None) -> List[ChildType]:
          children: List[ChildType] = []
  
          for arg, value in self.arguments.items():
              if value is None:
                  # ignore None values for convenience
                  continue
  
              if isinstance(value, dict):
                  children.append(
                      Key(arg, node=Data.create(self.builder, data=value))
                  )
              elif isinstance(value, (list, tuple, set)):
                  # NOTE: we have a special case for execute_raw and query_raw
                  # here as prisma expects parameters to be passed as a json string
                  # value like "[\"John\",\"123\"]", and we encode twice to ensure
                  # that only the inner quotes are escaped
                  if self.builder.method in {'queryRaw', 'executeRaw'}:
                      children.append(f'{arg}: {dumps(dumps(value))}')
                  else:
                      children.append(Key(arg, node=ListNode.create(self.builder, data=value)))
              else:
                  children.append(f'{arg}: {dumps(value)}')
  
          return children
  
  
  class Data(Node):
      """Rendered node example:
  
      {
          key1: "a"
          key2: 3
          key3: [
              "name"
          ]
      }
      """
      data: Mapping[str, Any]
  
      def __init__(
          self,
          data: Mapping[str, Any],
          **kwargs: Any
      ) -> None:
          super().__init__(**kwargs)
          self.data = data
  
      def enter(self) -> str:
          return '{'
  
      def depart(self) -> str:
          return '}'
  
      def create_children(self) -> List[ChildType]:
          children: List[ChildType] = []
  
          for key, value in self.data.items():
              if isinstance(value, dict):
                  children.append(
                      Key(key, node=Data.create(self.builder, data=value))
                  )
              elif isinstance(value, (list, tuple, set)):
                  children.append(
                      Key(key, node=ListNode.create(self.builder, data=value))
                  )
              else:
                  children.append(f'{key}: {dumps(value)}')
  
          return children
  
  
  class ListNode(Node):
      data: Iterable[Any]
  
      def __init__(self, data: Iterable[Any], joiner: str = ',\n', **kwargs: Any) -> None:
          super().__init__(joiner=joiner, **kwargs)
          self.data = data
  
      def enter(self) -> str:
          return '['
  
      def depart(self) -> str:
          return ']'
  
      def create_children(self) -> List[ChildType]:
          children: List[ChildType] = []
  
          for item in self.data:
              if isinstance(item, dict):
                  children.append(Data.create(self.builder, data=item))
              else:
                  children.append(dumps(item))
  
          return children
  
  
  class Selection(Node):
      """Represents field selections
  
      Example no include:
  
      {
          id
          name
      }
  
      Example include={'posts': True}
  
      {
          id
          name
          posts {
              id
              title
          }
      }
  
      Example include={'posts': {'where': {'title': {'contains': 'Test'}}}}
  
      {
          id
          name
          posts(
              where: {
                  title: {
                      contains: 'Test'
                  }
              }
          )
          {
              id
              title
          }
      }
      """
      model: Optional[str]
      include: Optional[Dict[str, Any]]
      root_selection: Optional[List[str]]
  
      def __init__(
          self,
          model: Optional[str] = None,
          include: Optional[Dict[str, Any]] = None,
          root_selection: Optional[List[str]] = None,
          **kwargs: Any
      ) -> None:
          super().__init__(**kwargs)
          self.model = model
          self.include = include
          self.root_selection = root_selection
  
      def should_render(self) -> bool:
          return bool(self.children)
  
      def enter(self) -> str:
          return '{'
  
      def depart(self) -> str:
          return '}'
  
      def create_children(self) -> List[ChildType]:
          model = self.model
          include = self.include
          builder = self.builder
          children: List[ChildType] = []
  
          # root_selection, if present overrides the default fields
          # for a model as it is used by methods such as count()
          # that do not support returning model fields
          root_selection = self.root_selection
          if root_selection is not None:
              children.extend(root_selection)
          elif model is not None:
              children.extend(builder.get_default_fields(model))
  
          if include is not None:
              if model is None:
                  raise ValueError('Cannot include fields when model is None.')
  
              for key, value in include.items():
                  if value is True:
                      # e.g. posts { post_fields }
                      children.append(
                          Key(
                              key,
                              sep=' ',
                              node=Selection.create(
                                  builder,
                                  include=None,
                                  model=builder.get_relational_model(
                                      current_model=model, field=key
                                  ),
                              ),
                          )
                      )
                  elif isinstance(value, dict):
                      # e.g. given {'posts': {where': {'published': True}}} return
                      # posts( where: { published: true }) { post_fields }
                      args = value.copy()
                      nested_include = args.pop('include', None)
                      children.extend(
                          [
                              Key(
                                  key,
                                  sep='',
                                  node=Arguments.create(
                                      builder, arguments=args
                                  ),
                              ),
                              Selection.create(
                                  builder,
                                  include=nested_include,
                                  model=builder.get_relational_model(
                                      current_model=model, field=key
                                  ),
                              ),
                          ]
                      )
                  elif value is False:
                      continue
                  else:
                      raise TypeError(
                          f'Expected `bool` or `dict` include value but got {type(value)} instead.'
                      )
  
          return children
  
  
  class Key(AbstractNode):
      """Node for rendering a child node with a prefixed key"""
      key: str
      sep: str
      node: Node
  
      def __init__(self, key: str, node: Node, sep: str = ': ') -> None:
          self.key = key
          self.node = node
          self.sep = sep
  
      def render(self) -> str:
          content = self.node.render()
          if content:
              return f'{self.key}{self.sep}{content}'
          return f'{self.key}{self.sep}'
  
  
  @singledispatch
  def serializer(obj: Any) -> Serializable:
      """Single dispatch generic function for serializing objects to JSON"""
      if inspect.isclass(obj):
          typ = obj
      else:
          typ = type(obj)
  
      raise TypeError(f'Type {typ} not serializable')
  
  
  @serializer.register(datetime.datetime)
  def serialize_datetime(dt: datetime.datetime) -> str:
      """Format a datetime object to an ISO8601 string with a timezone.
  
      This assumes naive datetime objects are in UTC.
      """
      if dt.tzinfo is None:
          dt = dt.replace(tzinfo=timezone.utc)
      elif dt.tzinfo != timezone.utc:
          dt = dt.astimezone(timezone.utc)
  
      return dt.isoformat()
  
  
  @serializer.register(fields.Json)
  def serialize_json(obj: fields.Json) -> str:
      """Serialize a Json wrapper to a json string.
  
      This is used as a hook to override our default behaviour when building
      queries which would treat data like {'hello': 'world'} as a Data node
      when we instead want it to be rendered as a raw json string.
  
      This should only be used for fields that are of the `Json` type.
      """
      return dumps(obj.data)
  
  
  @serializer.register(fields.Base64)
  def serialize_base64(obj: fields.Base64) -> str:
      """Serialize a Base64 wrapper object to raw binary data"""
      return str(obj)
  
  
  def dumps(obj: Any, **kwargs: Any) -> str:
      kwargs.setdefault('default', serializer)
      kwargs.setdefault('ensure_ascii', False)
      return json.dumps(obj, **kwargs)
  
  # black does not respect the fmt: off comment without this
  # fmt: on
  
  '
---
# name: test_async[client.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Callable,
      Generic,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  from typing_extensions import TypedDict, Literal
  
  # -- template client.py.jinja --
  from types import TracebackType
  
  from . import types, models, errors, actions
  from ._types import BaseModelT
  from .engine import AbstractEngine, QueryEngine
  from .builder import QueryBuilder
  
  
  __all__ = (
      'Client',
      'load_env',
      'register',
      'get_client',
  )
  
  SCHEMA = '''
  // NOTE: modified from https://github.com/prisma/prisma/blob/master/src/packages/client/src/__tests__/integration/happy/exhaustive-schema/schema.prisma
  
  datasource db {
    provider = "postgresql"
    url      = env("DB_URL")
  }
  
  generator db {
    provider             = "prisma-client-py"
    interface            = "asyncio"
    recursive_type_depth = 3
    output               = "../../../.tests_cache/generation/exhaustive/__prisma_async_output__/prisma"
  }
  
  model Post {
    id         Int      @id @default(autoincrement())
    created_at DateTime @default(now())
    title      String
    content    String?
    published  Boolean  @default(false)
    author     User     @relation(fields: [author_id], references: [id])
    author_id  Int
  }
  
  model User {
    id               Int             @id @default(autoincrement())
    email            String          @unique
    int              Int
    optional_int     Int?
    float            Float
    optional_float   Float?
    string           String
    optional_string  String?
    enum             ABeautifulEnum
    optional_enum    ABeautifulEnum?
    boolean          Boolean
    optional_boolean Boolean?
    posts            Post[]
  }
  
  model M {
    id               Int             @id @default(autoincrement())
    n                N[]
    int              Int
    optional_int     Int?
    float            Float
    optional_float   Float?
    string           String
    optional_string  String?
    enum             ABeautifulEnum
    optional_enum    ABeautifulEnum?
    boolean          Boolean
    optional_boolean Boolean?
  }
  
  model N {
    id               Int             @id @default(autoincrement())
    m                M[]
    int              Int
    optional_int     Int?
    float            Float
    optional_float   Float?
    string           String
    optional_string  String?
    json_            Json
    optional_json    Json?
    enum             ABeautifulEnum
    optional_enum    ABeautifulEnum?
    boolean          Boolean
    optional_boolean Boolean?
  }
  
  model OneOptional {
    id               Int             @id @default(autoincrement())
    many             ManyRequired[]
    int              Int
    optional_int     Int?
    float            Float
    optional_float   Float?
    string           String
    optional_string  String?
    enum             ABeautifulEnum
    optional_enum    ABeautifulEnum?
    boolean          Boolean
    optional_boolean Boolean?
  }
  
  model ManyRequired {
    id  Int          @id @default(autoincrement())
    one OneOptional? @relation(fields: [one_optional_id], references: [id])
  
    one_optional_id  Int?
    int              Int
    optional_int     Int?
    float            Float
    optional_float   Float?
    string           String
    optional_string  String?
    enum             ABeautifulEnum
    optional_enum    ABeautifulEnum?
    boolean          Boolean
    optional_boolean Boolean?
  }
  
  model Lists {
    id           String     @id @default(cuid())
    strings      String[]
    bytes        Bytes[]
    dates        DateTime[]
    bools        Boolean[]
    ints         Int[]
    floats       Float[]
    bigints      BigInt[]
    json_objects Json[]
    // TODO
    // decimals     Decimal[]
  }
  
  enum ABeautifulEnum {
    A
    B
    C
  }
  
  model A {
    email    String  @unique
    name     String?
    int      Int     @db.Integer
    sInt     Int     @db.SmallInt
    inc_int  Int     @default(autoincrement()) @db.Integer
    inc_sInt Int     @default(autoincrement()) @db.SmallInt
    bInt     BigInt  @db.BigInt
    inc_bInt BigInt  @default(autoincrement()) @db.BigInt
  
    @@unique([name, email])
  }
  
  model B {
    id      String @id @default(cuid())
    float   Float  @db.Real
    d_float Float  @db.DoublePrecision
  
    // TODO
    // decFloat Decimal @db.Decimal(2, 1)
    // numFloat Decimal @db.Decimal(10, 6)
  
    @@unique([float, d_float], name: "my_constraint")
  }
  
  model C {
    char   String @db.Char(10)
    v_char String @db.VarChar(11)
    text   String @db.Text
    bit    String @db.Bit(4)
    v_bit  String @db.VarBit(5)
    uuid   String @db.Uuid
  
    @@id([char, text], name: "my_id")
  }
  
  model D {
    id     String  @id @default(cuid())
    bool   Boolean @db.Boolean
    xml    String  @db.Xml
    json_  Json    @db.Json
    jsonb  Json    @db.JsonB
    binary Bytes   @db.ByteA
  }
  
  model E {
    id   String   @id @default(cuid())
    date DateTime @db.Date
    time DateTime @db.Time(3)
    ts   DateTime @db.Timestamp(3)
  }
  
  '''
  
  RegisteredClient = Union['Client', Callable[[], 'Client']]
  _registered_client: Optional[RegisteredClient] = None
  
  
  def load_env(*, override: bool = True, **kwargs: Any) -> None:
      """Load environemntal variables from dotenv files
  
      Loads from the following files relative to the current
      working directory:
  
      - .env
      - prisma/.env
      """
      from dotenv import load_dotenv
  
      load_dotenv('.env', override=override, **kwargs)
      load_dotenv('prisma/.env', override=override, **kwargs)
  
  
  def register(client: RegisteredClient) -> None:
      """Register a client instance to be retrieved by `get_client()`
  
      This function _must_ only be called once, preferrably as soon as possible
      to avoid any potentially confusing errors with threads or processes.
      """
      global _registered_client
  
      if _registered_client is not None:
          raise errors.ClientAlreadyRegisteredError()
  
      if not isinstance(client, Client) and not callable(client):
          raise TypeError(
              f'Expected either a {Client} instance or a function that returns a {Client} but got {client} instead.'
          )
  
      _registered_client = client
  
  
  def get_client() -> 'Client':
      """Get the registered client instance
  
      Raises errors.ClientNotRegisteredError() if no client instance has been registered.
      """
      registered = _registered_client
      if registered is None:
          raise errors.ClientNotRegisteredError() from None
  
      if isinstance(registered, Client):
          return registered
  
      client = registered()
      if not isinstance(client, Client):  # pyright: reportUnnecessaryIsInstance=false
          raise TypeError(
              f'Registered function returned {client} instead of a {Client} instance.'
          )
  
      return client
  
  
  class Client:
      post: 'actions.PostActions'
      user: 'actions.UserActions'
      m: 'actions.MActions'
      n: 'actions.NActions'
      oneoptional: 'actions.OneOptionalActions'
      manyrequired: 'actions.ManyRequiredActions'
      lists: 'actions.ListsActions'
      a: 'actions.AActions'
      b: 'actions.BActions'
      c: 'actions.CActions'
      d: 'actions.DActions'
      e: 'actions.EActions'
  
      def __init__(
          self,
          *,
          use_dotenv: bool = True,
          log_queries: bool = False,
          auto_register: bool = False,
          # no idea why this type ignore is required, pyright works correctly, mypy does not
          datasource: Optional[types.DatasourceOverride] = None,  # type: ignore[name-defined]
      ) -> None:
          self.post = actions.PostActions(self, models.Post)
          self.user = actions.UserActions(self, models.User)
          self.m = actions.MActions(self, models.M)
          self.n = actions.NActions(self, models.N)
          self.oneoptional = actions.OneOptionalActions(self, models.OneOptional)
          self.manyrequired = actions.ManyRequiredActions(self, models.ManyRequired)
          self.lists = actions.ListsActions(self, models.Lists)
          self.a = actions.AActions(self, models.A)
          self.b = actions.BActions(self, models.B)
          self.c = actions.CActions(self, models.C)
          self.d = actions.DActions(self, models.D)
          self.e = actions.EActions(self, models.E)
          self.__engine: Optional[AbstractEngine] = None
          self._active_provider = 'postgresql'
          self._log_queries = log_queries
          self._datasource = datasource
  
          if use_dotenv:
              load_env()
  
          if auto_register:
              register(self)
  
      def __del__(self) -> None:
          if self.__engine is not None:
              self.__engine.stop()
              self.__engine = None
  
      async def __aenter__(self) -> 'Client':
          await self.connect()
          return self
  
      async def __aexit__(
          self,
          exc_type: Optional[Type[BaseException]],
          exc: Optional[BaseException],
          exc_tb: Optional[TracebackType],
      ) -> None:
          if self.is_connected():
              await self.disconnect()
  
      def is_connected(self) -> bool:
          """Returns True if the client is connected to the query engine, False otherwise."""
          return self.__engine is not None
  
      async def connect(self, timeout: int = 10) -> None:
          """Connect to the Prisma query engine.
  
          It is required to call this before accessing data.
          """
          if self.__engine is None:
              self.__engine = self._engine_class(dml=SCHEMA, log_queries=self._log_queries)
  
          datasources: Optional[List[types.DatasourceOverride]] = None
          if self._datasource is not None:
              ds = self._datasource.copy()
              ds.setdefault('name', 'db')
              datasources = [ds]
  
          await self.__engine.connect(
              timeout=timeout,
              datasources=datasources,
          )
  
      async def disconnect(self) -> None:
          """Disconnect the Prisma query engine."""
          if self.__engine is not None:
              self.__engine.close()
              await self.__engine.aclose()
              self.__engine = None
  
      async def execute_raw(self, query: str, *args: Any) -> int:
          resp = await self._execute(
              operation='mutation',
              method='executeRaw',
              arguments={
                  'query': query,
                  'parameters': args,
              }
          )
          return int(resp['data']['result'])
  
      @overload
      async def query_first(self, query: str, *args: Any) -> Any:
          ...
  
      @overload
      async def query_first(self, query: str, *args: Any, model: Type[BaseModelT]) -> Optional[BaseModelT]:
          ...
  
      async def query_first(
          self, query: str, *args: Any, model: Optional[Type[BaseModelT]] = None
      ) -> Union[Optional[BaseModelT], Any]:
          if model is not None:
              results = await self.query_raw(query, *args, model=model)
          else:
              results = await self.query_raw(query, *args)
  
          if not results:
              return None
  
          return results[0]
  
      @overload
      async def query_raw(self, query: str, *args: Any) -> Any:
          ...
  
      @overload
      async def query_raw(self, query: str, *args: Any, model: Type[BaseModelT]) -> List[BaseModelT]:
          ...
  
      async def query_raw(
          self, query: str, *args: Any, model: Optional[Type[BaseModelT]] = None
      ) -> Union[List[BaseModelT], Any]:
          resp = await self._execute(
              operation='mutation',
              method='queryRaw',
              arguments={
                  'query': query,
                  'parameters': args,
              }
          )
          result = resp['data']['result']
          if model is not None:
              return [model.parse_obj(r) for r in result]
          return result
  
      def batch_(self) -> 'Batch':
          """Returns a context manager for grouping write queries into a single transaction."""
          return Batch(client=self)
  
      # TODO: don't return Any
      async def _execute(
          self,
          method: str,
          operation: str,
          arguments: Dict[str, Any],
          model: Optional[str] = None,
          root_selection: Optional[List[str]] = None
      ) -> Any:
          builder = QueryBuilder(
              operation=operation,
              method=method,
              model=model,
              arguments=arguments,
              root_selection=root_selection,
          )
          return await self._engine.query(builder.build())
  
      @property
      def _engine(self) -> AbstractEngine:
          engine = self.__engine
          if engine is None:
              raise errors.ClientNotConnectedError()
          return engine
  
      @property
      def _engine_class(self) -> Type[AbstractEngine]:
          return QueryEngine
  
  
  # TODO: this should return the results as well
  # TODO: don't require copy-pasting arguments between actions and batch actions
  class Batch:
      post: 'PostBatchActions'
      user: 'UserBatchActions'
      m: 'MBatchActions'
      n: 'NBatchActions'
      oneoptional: 'OneOptionalBatchActions'
      manyrequired: 'ManyRequiredBatchActions'
      lists: 'ListsBatchActions'
      a: 'ABatchActions'
      b: 'BBatchActions'
      c: 'CBatchActions'
      d: 'DBatchActions'
      e: 'EBatchActions'
  
      def __init__(self, client: Client) -> None:
          self.__client = client
          self.__queries: List[str] = []
          self._active_provider = client._active_provider
          self.post = PostBatchActions(self)
          self.user = UserBatchActions(self)
          self.m = MBatchActions(self)
          self.n = NBatchActions(self)
          self.oneoptional = OneOptionalBatchActions(self)
          self.manyrequired = ManyRequiredBatchActions(self)
          self.lists = ListsBatchActions(self)
          self.a = ABatchActions(self)
          self.b = BBatchActions(self)
          self.c = CBatchActions(self)
          self.d = DBatchActions(self)
          self.e = EBatchActions(self)
  
      def _add(self, **kwargs: Any) -> None:
          builder = QueryBuilder(**kwargs)
          self.__queries.append(builder.build_query())
  
      async def commit(self) -> None:
          """Execute the queries"""
          # TODO: normalise this, we should still call client._execute
          from .builder import dumps
  
          queries = self.__queries
          self.__queries = []
  
          payload = {
              'batch': [
                  {
                      'query': query,
                      'variables': {},
                  }
                  for query in queries
              ],
              'transaction': True,
          }
          await self.__client._engine.query(dumps(payload))
  
      async def __aenter__(self) -> 'Batch':
          return self
  
      async def __aexit__(
          self,
          exc_type: Optional[Type[BaseException]],
          exc: Optional[BaseException],
          exc_tb: Optional[TracebackType],
      ) -> None:
          if exc is None:
              await self.commit()
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class PostBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.PostCreateInput,
          include: Optional[types.PostInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='Post',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.PostCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='Post',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.PostWhereUniqueInput,
          include: Optional[types.PostInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='Post',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.PostUpdateInput,
          where: types.PostWhereUniqueInput,
          include: Optional[types.PostInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='Post',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.PostWhereUniqueInput,
          data: types.PostUpsertInput,
          include: Optional[types.PostInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='Post',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.PostUpdateManyMutationInput,
          where: types.PostWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='Post',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.PostWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='Post',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class UserBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.UserCreateInput,
          include: Optional[types.UserInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='User',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.UserCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='User',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.UserWhereUniqueInput,
          include: Optional[types.UserInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='User',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.UserUpdateInput,
          where: types.UserWhereUniqueInput,
          include: Optional[types.UserInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='User',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.UserWhereUniqueInput,
          data: types.UserUpsertInput,
          include: Optional[types.UserInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='User',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.UserUpdateManyMutationInput,
          where: types.UserWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='User',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.UserWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='User',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class MBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.MCreateInput,
          include: Optional[types.MInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='M',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.MCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='M',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.MWhereUniqueInput,
          include: Optional[types.MInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='M',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.MUpdateInput,
          where: types.MWhereUniqueInput,
          include: Optional[types.MInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='M',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.MWhereUniqueInput,
          data: types.MUpsertInput,
          include: Optional[types.MInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='M',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.MUpdateManyMutationInput,
          where: types.MWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='M',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.MWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='M',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class NBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.NCreateInput,
          include: Optional[types.NInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='N',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.NCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='N',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.NWhereUniqueInput,
          include: Optional[types.NInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='N',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.NUpdateInput,
          where: types.NWhereUniqueInput,
          include: Optional[types.NInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='N',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.NWhereUniqueInput,
          data: types.NUpsertInput,
          include: Optional[types.NInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='N',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.NUpdateManyMutationInput,
          where: types.NWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='N',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.NWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='N',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class OneOptionalBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.OneOptionalCreateInput,
          include: Optional[types.OneOptionalInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='OneOptional',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.OneOptionalCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='OneOptional',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.OneOptionalWhereUniqueInput,
          include: Optional[types.OneOptionalInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='OneOptional',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.OneOptionalUpdateInput,
          where: types.OneOptionalWhereUniqueInput,
          include: Optional[types.OneOptionalInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='OneOptional',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.OneOptionalWhereUniqueInput,
          data: types.OneOptionalUpsertInput,
          include: Optional[types.OneOptionalInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='OneOptional',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.OneOptionalUpdateManyMutationInput,
          where: types.OneOptionalWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='OneOptional',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.OneOptionalWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='OneOptional',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class ManyRequiredBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.ManyRequiredCreateInput,
          include: Optional[types.ManyRequiredInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='ManyRequired',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.ManyRequiredCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='ManyRequired',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.ManyRequiredWhereUniqueInput,
          include: Optional[types.ManyRequiredInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='ManyRequired',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.ManyRequiredUpdateInput,
          where: types.ManyRequiredWhereUniqueInput,
          include: Optional[types.ManyRequiredInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='ManyRequired',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.ManyRequiredWhereUniqueInput,
          data: types.ManyRequiredUpsertInput,
          include: Optional[types.ManyRequiredInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='ManyRequired',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.ManyRequiredUpdateManyMutationInput,
          where: types.ManyRequiredWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='ManyRequired',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.ManyRequiredWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='ManyRequired',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class ListsBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.ListsCreateInput,
          include: Optional[types.ListsInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='Lists',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.ListsCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='Lists',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.ListsWhereUniqueInput,
          include: Optional[types.ListsInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='Lists',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.ListsUpdateInput,
          where: types.ListsWhereUniqueInput,
          include: Optional[types.ListsInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='Lists',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.ListsWhereUniqueInput,
          data: types.ListsUpsertInput,
          include: Optional[types.ListsInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='Lists',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.ListsUpdateManyMutationInput,
          where: types.ListsWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='Lists',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.ListsWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='Lists',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class ABatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.ACreateInput,
          include: Optional[types.AInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='A',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.ACreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='A',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.AWhereUniqueInput,
          include: Optional[types.AInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='A',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.AUpdateInput,
          where: types.AWhereUniqueInput,
          include: Optional[types.AInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='A',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.AWhereUniqueInput,
          data: types.AUpsertInput,
          include: Optional[types.AInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='A',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.AUpdateManyMutationInput,
          where: types.AWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='A',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.AWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='A',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class BBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.BCreateInput,
          include: Optional[types.BInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='B',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.BCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='B',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.BWhereUniqueInput,
          include: Optional[types.BInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='B',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.BUpdateInput,
          where: types.BWhereUniqueInput,
          include: Optional[types.BInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='B',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.BWhereUniqueInput,
          data: types.BUpsertInput,
          include: Optional[types.BInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='B',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.BUpdateManyMutationInput,
          where: types.BWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='B',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.BWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='B',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class CBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.CCreateInput,
          include: Optional[types.CInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='C',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.CCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='C',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.CWhereUniqueInput,
          include: Optional[types.CInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='C',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.CUpdateInput,
          where: types.CWhereUniqueInput,
          include: Optional[types.CInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='C',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.CWhereUniqueInput,
          data: types.CUpsertInput,
          include: Optional[types.CInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='C',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.CUpdateManyMutationInput,
          where: types.CWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='C',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.CWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='C',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class DBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.DCreateInput,
          include: Optional[types.DInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='D',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.DCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='D',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.DWhereUniqueInput,
          include: Optional[types.DInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='D',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.DUpdateInput,
          where: types.DWhereUniqueInput,
          include: Optional[types.DInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='D',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.DWhereUniqueInput,
          data: types.DUpsertInput,
          include: Optional[types.DInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='D',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.DUpdateManyMutationInput,
          where: types.DWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='D',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.DWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='D',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class EBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.ECreateInput,
          include: Optional[types.EInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='E',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.ECreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='E',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.EWhereUniqueInput,
          include: Optional[types.EInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='E',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.EUpdateInput,
          where: types.EWhereUniqueInput,
          include: Optional[types.EInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='E',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.EWhereUniqueInput,
          data: types.EUpsertInput,
          include: Optional[types.EInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='E',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.EUpdateManyMutationInput,
          where: types.EWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='E',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.EWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='E',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  '
---
# name: test_async[engine/abstract.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Callable,
      Generic,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  from typing_extensions import TypedDict, Literal
  
  # -- template engine/abstract.py.jinja --
  from abc import ABC, abstractmethod
  from ..types import DatasourceOverride
  from .._compat import get_running_loop
  
  __all__ = (
      'AbstractEngine',
  )
  
  class AbstractEngine(ABC):
      dml: str
  
      @abstractmethod
      def __init__(self, *, dml: str, log_queries: bool = False) -> None:
          ...
  
      def stop(self) -> None:
          """Wrapper for synchronously calling close() and aclose()"""
          self.close()
          try:
              loop = get_running_loop()
          except RuntimeError:
              # no event loop in the current thread, we cannot cleanup asynchronously
              return
          else:
              if not loop.is_closed():
                  loop.create_task(self.aclose())
  
      @abstractmethod
      def close(self) -> None:
          """Synchronous method for closing the engine, useful if the underlying engine uses a subprocess"""
          ...
  
      @abstractmethod
      async def aclose(self) -> None:
          """Asynchronous method for closing the engine, only used if an
          asynchronous client is generated.
          """
          ...
  
      @abstractmethod
      async def connect(
          self,
          timeout: int = 10,
          datasources: Optional[List[DatasourceOverride]] = None,
      ) -> None:
          """Connect to the engine"""
          ...
  
      @abstractmethod
      async def query(self, content: str) -> Any:
          """Execute a GraphQL query.
  
          This method expects a JSON object matching this structure:
  
          {
              'variables': {},
              'operation_name': str,
              'query': str,
          }
          """
          ...
  '
---
# name: test_async[engine/query.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Callable,
      Generic,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  from typing_extensions import TypedDict, Literal
  
  # -- template engine/query.py.jinja --
  
  import os
  import time
  import atexit
  import signal
  import asyncio
  import logging
  import subprocess
  from pathlib import Path
  
  from . import utils, errors
  from .abstract import AbstractEngine
  from ..http import HTTP
  from ..utils import DEBUG
  from .._types import Method
  from ..binaries import platform
  from ..utils import time_since, _env_bool
  from ..types import DatasourceOverride
  from ..builder import dumps
  
  
  __all__ = ('QueryEngine',)
  
  log: logging.Logger = logging.getLogger(__name__)
  
  
  class QueryEngine(AbstractEngine):
      dml: str
      session: HTTP
  
      def __init__(self, *, dml: str, log_queries: bool = False):
          self.dml = dml
          self.session = HTTP()
          self._log_queries = log_queries
          self.url = None  # type: Optional[str]
          self.process = None  # type: Optional[subprocess.Popen[bytes]]
          self.file = None  # type: Optional[Path]
  
          # ensure the query engine process is terminated when we are
          atexit.register(self.stop)
  
      def __del__(self) -> None:
          self.stop()
  
      def close(self) -> None:
          log.debug('Disconnecting query engine...')
  
          if self.process is not None:
              if platform.name() == 'windows':
                  self.process.kill()
              else:
                  self.process.send_signal(signal.SIGINT)
  
              self.process.wait()
              self.process = None
  
          log.debug('Disconnected query engine')
  
      async def aclose(self) -> None:
          self.close()
          await self._close_session()
  
      async def _close_session(self) -> None:
          if self.session and not self.session.closed:
              await self.session.close()
  
      async def connect(
          self,
          timeout: int = 10,
          datasources: Optional[List[DatasourceOverride]] = None,
      ) -> None:
          log.debug('Connecting to query engine')
          if self.process is not None:
              raise errors.AlreadyConnectedError('Already connected to the query engine')
  
          start = time.monotonic()
          self.file = file = utils.ensure()
  
          try:
              await self.spawn(file, timeout=timeout, datasources=datasources)
          except Exception:
              self.close()
              raise
  
          log.debug('Connecting to query engine took %s', time_since(start))
  
      async def spawn(
          self,
          file: Path,
          timeout: int = 10,
          datasources: Optional[List[DatasourceOverride]] = None,
      ) -> None:
          port = utils.get_open_port()
          log.debug('Running query engine on port %i', port)
  
          self.url = f'http://localhost:{port}'
  
          env = os.environ.copy()
          env.update(
              PRISMA_DML=self.dml,
              RUST_LOG='error',
              RUST_LOG_FORMAT='json',
              PRISMA_CLIENT_ENGINE_TYPE='binary',
          )
  
          if DEBUG:
              env.update(RUST_LOG='info')
  
          if datasources is not None:
              env.update(OVERWRITE_DATASOURCES=dumps(datasources))
  
          # TODO: remove the noise from these query logs
          if self._log_queries:
              env.update(LOG_QUERIES='y')
  
          args: List[str] = [str(file.absolute()), '-p', str(port), '--enable-raw-queries']
          if _env_bool('__PRISMA_PY_PLAYGROUND'):
              env.update(RUST_LOG='info')
              args.append('--enable-playground')
  
          log.debug('Starting query engine...')
          self.process = subprocess.Popen(
              args,
              env=env,
              stdout=sys.stdout,
              stderr=sys.stderr,
          )
  
          last_exc = None
          for _ in range(int(timeout / 0.1)):
              try:
                  data = await self.request('GET', '/status')
              except Exception as exc:  # pylint: disable=broad-except
                  last_exc = exc
                  log.debug(
                      'Could not connect to query engine due to %s; retrying...',
                      type(exc).__name__,
                  )
                  await asyncio.sleep(0.1)
  
                  continue
  
              if data.get('Errors') is not None:
                  log.debug('Could not connect due to gql errors; retrying...')
                  await asyncio.sleep(0.1)
  
                  continue
  
              break
          else:
              raise errors.EngineConnectionError(
                  'Could not connect to the query engine'
              ) from last_exc
  
      async def query(self, content: str) -> Any:
          return await self.request('POST', '/', content=content)
  
      async def request(self, method: Method, path: str, *, content: Any = None) -> Any:
          if self.url is None:
              raise errors.NotConnectedError('Not connected to the query engine')
  
          kwargs = {
              'headers': {
                  'Content-Type': 'application/json',
                  'Accept': 'application/json',
              }
          }
  
          if content is not None:
              kwargs['content'] = content
  
          url = self.url + path
          log.debug('Sending %s request to %s with content: %s', method, url, content)
  
          resp = await self.session.request(method, url, **kwargs)
  
          if 300 > resp.status >= 200:
              response = await resp.json()
              log.debug('%s %s returned %s', method, url, response)
  
              errors_data = response.get('errors')
              if errors_data:
                  return utils.handle_response_errors(resp, errors_data)
  
              return response
  
          if resp.status == 422:
              raise errors.UnprocessableEntityError(resp)
  
          # TODO: handle errors better
          raise errors.EngineRequestError(resp, await resp.text())
  
  
  # black does not respect the fmt: off comment without this
  # fmt: on
  
  '
---
# name: test_async[enums.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Callable,
      Generic,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  from typing_extensions import TypedDict, Literal
  
  # -- template enums.py.jinja --
  from enum import Enum
  
  
  class ABeautifulEnum(str, Enum):
      A = 'A'
      B = 'B'
      C = 'C'
  
  
  '
---
# name: test_async[fields.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Callable,
      Generic,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  from typing_extensions import TypedDict, Literal
  
  # -- template fields.py.jinja --
  import base64
  from pydantic import Json as _PydanticJson
  
  
  __all__ = (
      'Json',
      'Base64',
  )
  
  
  _JsonKeys = Union[
      None,
      bool,
      float,
      int,
      str,
  ]
  
  # Base64 data should only be valid ascii, we limit our encoding to ascii so that
  # any erroneous data is caught as early on as possible.
  BASE64_ENCODING = 'ascii'
  
  
  # inherit from _PydanticJson so that pydantic will automatically
  # transform the json string into python objects.
  class Json(_PydanticJson):
      data: 'Serializable'
  
      def __init__(self, data: 'Serializable') -> None:
          self.data = data
          super().__init__()
  
      @classmethod
      def keys(cls, **data: 'Serializable') -> 'Json':
          return cls(data)
  
      if TYPE_CHECKING:
          # Fields that are of the `Json` type are automatically
          # de-serialized from json to the corresponding python type
          # when the model is created, e.g.
          #
          # User(json_obj='{"foo": null}') -> User(json_obj={'foo': None})
          #
          # As we don't know what the type will actually be at runtime
          # we add methods here for convenience so that naive access
          # to the field is still allowed, e.g.
          #
          # user.json_obj['foo']
          # user.json_obj[1]
          # user.json_obj[1:5]
          #
          # It should be noted that users will still have
          # to validate / cast fields to the type they are expecting
          # for any strict type binding or nested index calls to work, e.g.
          #
          # isinstance(user.json_obj, dict)
          # cast(Dict[str, Any], user.json_obj)
          # prisma.validate(ExpectedType, user.json_obj)  # NOTE: not implemented yet
          @overload  # type: ignore
          def __getitem__(self, i: slice) -> List['Serializable']:
              ...
  
          @overload
          def __getitem__(self, i: '_JsonKeys') -> 'Serializable':  # pyright: reportIncompatibleMethodOverride=false
              ...
  
          def __getitem__(self, i: Union['_JsonKeys', slice]) -> 'Serializable':
              ...
  
  
  class Base64:
      def __init__(self, raw: bytes) -> None:
          self._raw = raw
  
      @classmethod
      def encode(cls, value: bytes) -> 'Base64':
          """Encode bytes into valid Base64"""
          return cls(base64.b64encode(value))
  
      def decode(self, encoding: str = BASE64_ENCODING) -> bytes:
          """Decode from Base64 to the original bytes object"""
          return base64.b64decode(self._raw)
  
      # NOTE: we explicitly use a different encoding here as we are decoding
      # to the original data provided by the user, this data does not have
      # the limitation of being ascii only that the raw Base64 data does
      def decode_str(self, encoding: str = 'utf-8') -> str:
          """Decode from Base64 to the original string
  
          This decodes using the `utf-8` encoding by default,
          you can customise the encoding like so:
  
          ```py
          value = b64.decode_str('ascii')
          ```
          """
          return self.decode().decode(encoding)
  
      def __str__(self) -> str:
          return self._raw.decode(BASE64_ENCODING)
  
      def __repr__(self) -> str:
          return f'{self.__class__.__name__}({self._raw})'  # type: ignore[str-bytes-safe]
  
      def __eq__(self, other: Any) -> bool:
          if isinstance(other, Base64):
              return self._raw == other._raw
  
          return False
  
      @classmethod
      def _internal_from_prisma(
          cls,
          value: Union[str, 'Base64', List[Union[str, 'Base64']]]
      ) -> Union['Base64', List['Base64']]:
          if isinstance(value, Base64):
              return value
  
          if isinstance(value, list):
              return [
                  item
                  if isinstance(item, Base64)
                  else
                  cls(bytes(item, BASE64_ENCODING))
                  for item in value
              ]
  
          return cls(bytes(value, BASE64_ENCODING))
  
  
  from .types import Serializable
  '
---
# name: test_async[http.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Callable,
      Generic,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  from typing_extensions import TypedDict, Literal
  
  # -- template http.py.jinja --
  from ._async_http import (
      HTTP as HTTP,
      Response as Response,
      client as client,
  )
  
  '
---
# name: test_async[models.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Callable,
      Generic,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  from typing_extensions import TypedDict, Literal
  
  # -- template models.py.jinja --
  import os
  from pydantic import BaseConfig, BaseModel, Field, validator
  
  from . import types, enums, errors, fields
  from ._types import BaseModelT
  from .builder import serialize_base64
  from .generator import partial_models_ctx, PartialModelField
  
  
  class Config(BaseConfig):
      use_enum_values: bool = True
      arbitrary_types_allowed: bool = True
      allow_population_by_field_name: bool = True
      json_encoders: Dict[Type[Any], Any] = {
          fields.Base64: serialize_base64,
      }
  
  
  _created_partial_types: Set[str] = set()
  
  
  class Post(BaseModel):
      id: int
      created_at: datetime.datetime
      title: str
      content: Optional[str]
      published: bool
      author: Optional['models.User']
      author_id: int
  
      Config = Config
  
      @classmethod
      def prisma(cls) -> 'actions.PostActions':
          from .client import get_client
  
          return actions.PostActions(get_client(), cls)
  
      def __init_subclass__(cls, *args: Any, **kwargs: Any) -> None:
          raise RuntimeError(
              'Prisma models cannot be subclassed with pseudo-recursive types;\n'
              'This is because mypy does not work well with this pattern;\n'
              'See the documentation for how to generate fully recursive types: \n'
              'https://prisma-client-py.readthedocs.io/en/stable/reference/config/#recursive'
          )
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.PostKeys']] = None,
          exclude: Optional[Iterable['types.PostKeys']] = None,
          required: Optional[Iterable['types.PostKeys']] = None,
          optional: Optional[Iterable['types.PostKeys']] = None,
          relations: Optional[Mapping['types.PostRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.PostKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _Post_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _Post_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _Post_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _Post_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  for field, type_ in relations.items():
                      if field not in _Post_relational_fields:
                          raise errors.UnknownRelationalFieldError('Post', field)
  
                      # TODO: this method of validating types is not ideal
                      # as it means we cannot two create partial types that
                      # reference each other
                      if type_ not in _created_partial_types:
                          raise ValueError(
                              f'Unknown partial type: "{type_}". '
                              f'Did you remember to generate the {type_} type before this one?'
                          )
  
                      # TODO: support non prisma.partials models
                      info = fields[field]
                      if info['is_list']:
                          info['type'] = f'List[\'partials.{type_}\']'
                      else:
                          info['type'] = f'\'partials.{type_}\''
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid Post / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class User(BaseModel):
      id: int
      email: str
      int: int
      optional_int: Optional[int]
      float: float
      optional_float: Optional[float]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
      posts: Optional[List['models.Post']]
  
      Config = Config
  
      @classmethod
      def prisma(cls) -> 'actions.UserActions':
          from .client import get_client
  
          return actions.UserActions(get_client(), cls)
  
      def __init_subclass__(cls, *args: Any, **kwargs: Any) -> None:
          raise RuntimeError(
              'Prisma models cannot be subclassed with pseudo-recursive types;\n'
              'This is because mypy does not work well with this pattern;\n'
              'See the documentation for how to generate fully recursive types: \n'
              'https://prisma-client-py.readthedocs.io/en/stable/reference/config/#recursive'
          )
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.UserKeys']] = None,
          exclude: Optional[Iterable['types.UserKeys']] = None,
          required: Optional[Iterable['types.UserKeys']] = None,
          optional: Optional[Iterable['types.UserKeys']] = None,
          relations: Optional[Mapping['types.UserRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.UserKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _User_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _User_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _User_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _User_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  for field, type_ in relations.items():
                      if field not in _User_relational_fields:
                          raise errors.UnknownRelationalFieldError('User', field)
  
                      # TODO: this method of validating types is not ideal
                      # as it means we cannot two create partial types that
                      # reference each other
                      if type_ not in _created_partial_types:
                          raise ValueError(
                              f'Unknown partial type: "{type_}". '
                              f'Did you remember to generate the {type_} type before this one?'
                          )
  
                      # TODO: support non prisma.partials models
                      info = fields[field]
                      if info['is_list']:
                          info['type'] = f'List[\'partials.{type_}\']'
                      else:
                          info['type'] = f'\'partials.{type_}\''
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid User / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class M(BaseModel):
      id: int
      n: Optional[List['models.N']]
      int: int
      optional_int: Optional[int]
      float: float
      optional_float: Optional[float]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
      Config = Config
  
      @classmethod
      def prisma(cls) -> 'actions.MActions':
          from .client import get_client
  
          return actions.MActions(get_client(), cls)
  
      def __init_subclass__(cls, *args: Any, **kwargs: Any) -> None:
          raise RuntimeError(
              'Prisma models cannot be subclassed with pseudo-recursive types;\n'
              'This is because mypy does not work well with this pattern;\n'
              'See the documentation for how to generate fully recursive types: \n'
              'https://prisma-client-py.readthedocs.io/en/stable/reference/config/#recursive'
          )
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.MKeys']] = None,
          exclude: Optional[Iterable['types.MKeys']] = None,
          required: Optional[Iterable['types.MKeys']] = None,
          optional: Optional[Iterable['types.MKeys']] = None,
          relations: Optional[Mapping['types.MRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.MKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _M_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _M_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _M_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _M_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  for field, type_ in relations.items():
                      if field not in _M_relational_fields:
                          raise errors.UnknownRelationalFieldError('M', field)
  
                      # TODO: this method of validating types is not ideal
                      # as it means we cannot two create partial types that
                      # reference each other
                      if type_ not in _created_partial_types:
                          raise ValueError(
                              f'Unknown partial type: "{type_}". '
                              f'Did you remember to generate the {type_} type before this one?'
                          )
  
                      # TODO: support non prisma.partials models
                      info = fields[field]
                      if info['is_list']:
                          info['type'] = f'List[\'partials.{type_}\']'
                      else:
                          info['type'] = f'\'partials.{type_}\''
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid M / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class N(BaseModel):
      id: int
      m: Optional[List['models.M']]
      int: int
      optional_int: Optional[int]
      float: float
      optional_float: Optional[float]
      string: str
      optional_string: Optional[str]
      json_: 'fields.Json'
      optional_json: Optional['fields.Json']
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
      Config = Config
  
      @classmethod
      def prisma(cls) -> 'actions.NActions':
          from .client import get_client
  
          return actions.NActions(get_client(), cls)
  
      def __init_subclass__(cls, *args: Any, **kwargs: Any) -> None:
          raise RuntimeError(
              'Prisma models cannot be subclassed with pseudo-recursive types;\n'
              'This is because mypy does not work well with this pattern;\n'
              'See the documentation for how to generate fully recursive types: \n'
              'https://prisma-client-py.readthedocs.io/en/stable/reference/config/#recursive'
          )
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.NKeys']] = None,
          exclude: Optional[Iterable['types.NKeys']] = None,
          required: Optional[Iterable['types.NKeys']] = None,
          optional: Optional[Iterable['types.NKeys']] = None,
          relations: Optional[Mapping['types.NRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.NKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _N_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _N_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _N_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _N_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  for field, type_ in relations.items():
                      if field not in _N_relational_fields:
                          raise errors.UnknownRelationalFieldError('N', field)
  
                      # TODO: this method of validating types is not ideal
                      # as it means we cannot two create partial types that
                      # reference each other
                      if type_ not in _created_partial_types:
                          raise ValueError(
                              f'Unknown partial type: "{type_}". '
                              f'Did you remember to generate the {type_} type before this one?'
                          )
  
                      # TODO: support non prisma.partials models
                      info = fields[field]
                      if info['is_list']:
                          info['type'] = f'List[\'partials.{type_}\']'
                      else:
                          info['type'] = f'\'partials.{type_}\''
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid N / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class OneOptional(BaseModel):
      id: int
      many: Optional[List['models.ManyRequired']]
      int: int
      optional_int: Optional[int]
      float: float
      optional_float: Optional[float]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
      Config = Config
  
      @classmethod
      def prisma(cls) -> 'actions.OneOptionalActions':
          from .client import get_client
  
          return actions.OneOptionalActions(get_client(), cls)
  
      def __init_subclass__(cls, *args: Any, **kwargs: Any) -> None:
          raise RuntimeError(
              'Prisma models cannot be subclassed with pseudo-recursive types;\n'
              'This is because mypy does not work well with this pattern;\n'
              'See the documentation for how to generate fully recursive types: \n'
              'https://prisma-client-py.readthedocs.io/en/stable/reference/config/#recursive'
          )
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.OneOptionalKeys']] = None,
          exclude: Optional[Iterable['types.OneOptionalKeys']] = None,
          required: Optional[Iterable['types.OneOptionalKeys']] = None,
          optional: Optional[Iterable['types.OneOptionalKeys']] = None,
          relations: Optional[Mapping['types.OneOptionalRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.OneOptionalKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _OneOptional_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _OneOptional_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _OneOptional_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _OneOptional_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  for field, type_ in relations.items():
                      if field not in _OneOptional_relational_fields:
                          raise errors.UnknownRelationalFieldError('OneOptional', field)
  
                      # TODO: this method of validating types is not ideal
                      # as it means we cannot two create partial types that
                      # reference each other
                      if type_ not in _created_partial_types:
                          raise ValueError(
                              f'Unknown partial type: "{type_}". '
                              f'Did you remember to generate the {type_} type before this one?'
                          )
  
                      # TODO: support non prisma.partials models
                      info = fields[field]
                      if info['is_list']:
                          info['type'] = f'List[\'partials.{type_}\']'
                      else:
                          info['type'] = f'\'partials.{type_}\''
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid OneOptional / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class ManyRequired(BaseModel):
      id: int
      one: Optional['models.OneOptional']
      one_optional_id: Optional[int]
      int: int
      optional_int: Optional[int]
      float: float
      optional_float: Optional[float]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
      Config = Config
  
      @classmethod
      def prisma(cls) -> 'actions.ManyRequiredActions':
          from .client import get_client
  
          return actions.ManyRequiredActions(get_client(), cls)
  
      def __init_subclass__(cls, *args: Any, **kwargs: Any) -> None:
          raise RuntimeError(
              'Prisma models cannot be subclassed with pseudo-recursive types;\n'
              'This is because mypy does not work well with this pattern;\n'
              'See the documentation for how to generate fully recursive types: \n'
              'https://prisma-client-py.readthedocs.io/en/stable/reference/config/#recursive'
          )
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.ManyRequiredKeys']] = None,
          exclude: Optional[Iterable['types.ManyRequiredKeys']] = None,
          required: Optional[Iterable['types.ManyRequiredKeys']] = None,
          optional: Optional[Iterable['types.ManyRequiredKeys']] = None,
          relations: Optional[Mapping['types.ManyRequiredRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.ManyRequiredKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _ManyRequired_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _ManyRequired_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _ManyRequired_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _ManyRequired_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  for field, type_ in relations.items():
                      if field not in _ManyRequired_relational_fields:
                          raise errors.UnknownRelationalFieldError('ManyRequired', field)
  
                      # TODO: this method of validating types is not ideal
                      # as it means we cannot two create partial types that
                      # reference each other
                      if type_ not in _created_partial_types:
                          raise ValueError(
                              f'Unknown partial type: "{type_}". '
                              f'Did you remember to generate the {type_} type before this one?'
                          )
  
                      # TODO: support non prisma.partials models
                      info = fields[field]
                      if info['is_list']:
                          info['type'] = f'List[\'partials.{type_}\']'
                      else:
                          info['type'] = f'\'partials.{type_}\''
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid ManyRequired / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class Lists(BaseModel):
      id: str
      strings: List[str]
      bytes: List['fields.Base64']
      dates: List[datetime.datetime]
      bools: List[bool]
      ints: List[int]
      floats: List[float]
      bigints: List[int]
      json_objects: List['fields.Json']
  
      Config = Config
  
      @classmethod
      def prisma(cls) -> 'actions.ListsActions':
          from .client import get_client
  
          return actions.ListsActions(get_client(), cls)
  
      def __init_subclass__(cls, *args: Any, **kwargs: Any) -> None:
          raise RuntimeError(
              'Prisma models cannot be subclassed with pseudo-recursive types;\n'
              'This is because mypy does not work well with this pattern;\n'
              'See the documentation for how to generate fully recursive types: \n'
              'https://prisma-client-py.readthedocs.io/en/stable/reference/config/#recursive'
          )
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.ListsKeys']] = None,
          exclude: Optional[Iterable['types.ListsKeys']] = None,
          required: Optional[Iterable['types.ListsKeys']] = None,
          optional: Optional[Iterable['types.ListsKeys']] = None,
          relations: Optional[Mapping['types.ListsRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.ListsKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _Lists_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _Lists_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _Lists_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _Lists_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  raise ValueError('Model: "Lists" has no relational fields.')
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid Lists / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
      @validator('bytes', pre=True, allow_reuse=True)
      @classmethod
      def _prisma_bytes_bytes_validator(cls, value: Any) -> Union[fields.Base64, List[fields.Base64]]:
          return fields.Base64._internal_from_prisma(value)
  
  class A(BaseModel):
      email: str
      name: Optional[str]
      int: int
      sInt: int
      inc_int: int
      inc_sInt: int
      bInt: int
      inc_bInt: int
  
      Config = Config
  
      @classmethod
      def prisma(cls) -> 'actions.AActions':
          from .client import get_client
  
          return actions.AActions(get_client(), cls)
  
      def __init_subclass__(cls, *args: Any, **kwargs: Any) -> None:
          raise RuntimeError(
              'Prisma models cannot be subclassed with pseudo-recursive types;\n'
              'This is because mypy does not work well with this pattern;\n'
              'See the documentation for how to generate fully recursive types: \n'
              'https://prisma-client-py.readthedocs.io/en/stable/reference/config/#recursive'
          )
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.AKeys']] = None,
          exclude: Optional[Iterable['types.AKeys']] = None,
          required: Optional[Iterable['types.AKeys']] = None,
          optional: Optional[Iterable['types.AKeys']] = None,
          relations: Optional[Mapping['types.ARelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.AKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _A_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _A_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _A_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _A_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  raise ValueError('Model: "A" has no relational fields.')
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid A / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class B(BaseModel):
      id: str
      float: float
      d_float: float
  
      Config = Config
  
      @classmethod
      def prisma(cls) -> 'actions.BActions':
          from .client import get_client
  
          return actions.BActions(get_client(), cls)
  
      def __init_subclass__(cls, *args: Any, **kwargs: Any) -> None:
          raise RuntimeError(
              'Prisma models cannot be subclassed with pseudo-recursive types;\n'
              'This is because mypy does not work well with this pattern;\n'
              'See the documentation for how to generate fully recursive types: \n'
              'https://prisma-client-py.readthedocs.io/en/stable/reference/config/#recursive'
          )
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.BKeys']] = None,
          exclude: Optional[Iterable['types.BKeys']] = None,
          required: Optional[Iterable['types.BKeys']] = None,
          optional: Optional[Iterable['types.BKeys']] = None,
          relations: Optional[Mapping['types.BRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.BKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _B_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _B_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _B_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _B_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  raise ValueError('Model: "B" has no relational fields.')
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid B / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class C(BaseModel):
      char: str
      v_char: str
      text: str
      bit: str
      v_bit: str
      uuid: str
  
      Config = Config
  
      @classmethod
      def prisma(cls) -> 'actions.CActions':
          from .client import get_client
  
          return actions.CActions(get_client(), cls)
  
      def __init_subclass__(cls, *args: Any, **kwargs: Any) -> None:
          raise RuntimeError(
              'Prisma models cannot be subclassed with pseudo-recursive types;\n'
              'This is because mypy does not work well with this pattern;\n'
              'See the documentation for how to generate fully recursive types: \n'
              'https://prisma-client-py.readthedocs.io/en/stable/reference/config/#recursive'
          )
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.CKeys']] = None,
          exclude: Optional[Iterable['types.CKeys']] = None,
          required: Optional[Iterable['types.CKeys']] = None,
          optional: Optional[Iterable['types.CKeys']] = None,
          relations: Optional[Mapping['types.CRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.CKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _C_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _C_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _C_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _C_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  raise ValueError('Model: "C" has no relational fields.')
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid C / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class D(BaseModel):
      id: str
      bool: bool
      xml: str
      json_: 'fields.Json'
      jsonb: 'fields.Json'
      binary: 'fields.Base64'
  
      Config = Config
  
      @classmethod
      def prisma(cls) -> 'actions.DActions':
          from .client import get_client
  
          return actions.DActions(get_client(), cls)
  
      def __init_subclass__(cls, *args: Any, **kwargs: Any) -> None:
          raise RuntimeError(
              'Prisma models cannot be subclassed with pseudo-recursive types;\n'
              'This is because mypy does not work well with this pattern;\n'
              'See the documentation for how to generate fully recursive types: \n'
              'https://prisma-client-py.readthedocs.io/en/stable/reference/config/#recursive'
          )
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.DKeys']] = None,
          exclude: Optional[Iterable['types.DKeys']] = None,
          required: Optional[Iterable['types.DKeys']] = None,
          optional: Optional[Iterable['types.DKeys']] = None,
          relations: Optional[Mapping['types.DRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.DKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _D_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _D_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _D_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _D_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  raise ValueError('Model: "D" has no relational fields.')
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid D / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
      @validator('binary', pre=True, allow_reuse=True)
      @classmethod
      def _prisma_binary_bytes_validator(cls, value: Any) -> Union[fields.Base64, List[fields.Base64]]:
          return fields.Base64._internal_from_prisma(value)
  
  class E(BaseModel):
      id: str
      date: datetime.datetime
      time: datetime.datetime
      ts: datetime.datetime
  
      Config = Config
  
      @classmethod
      def prisma(cls) -> 'actions.EActions':
          from .client import get_client
  
          return actions.EActions(get_client(), cls)
  
      def __init_subclass__(cls, *args: Any, **kwargs: Any) -> None:
          raise RuntimeError(
              'Prisma models cannot be subclassed with pseudo-recursive types;\n'
              'This is because mypy does not work well with this pattern;\n'
              'See the documentation for how to generate fully recursive types: \n'
              'https://prisma-client-py.readthedocs.io/en/stable/reference/config/#recursive'
          )
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.EKeys']] = None,
          exclude: Optional[Iterable['types.EKeys']] = None,
          required: Optional[Iterable['types.EKeys']] = None,
          optional: Optional[Iterable['types.EKeys']] = None,
          relations: Optional[Mapping['types.ERelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.EKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _E_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _E_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _E_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _E_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  raise ValueError('Model: "E" has no relational fields.')
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid E / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  
  _Post_relational_fields: Set[str] = {
          'author',
      }
  _Post_fields: Dict['types.PostKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'created_at': {
          'name': 'created_at',
          'is_list': False,
          'optional': False,
          'type': 'datetime.datetime',
      },
      'title': {
          'name': 'title',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'content': {
          'name': 'content',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'published': {
          'name': 'published',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'author': {
          'name': 'author',
          'is_list': False,
          'optional': True,
          'type': 'models.User',
      },
      'author_id': {
          'name': 'author_id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
  }
  
  _User_relational_fields: Set[str] = {
          'posts',
      }
  _User_fields: Dict['types.UserKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'email': {
          'name': 'email',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'int': {
          'name': 'int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'optional_int': {
          'name': 'optional_int',
          'is_list': False,
          'optional': True,
          'type': 'int',
      },
      'float': {
          'name': 'float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
      'optional_float': {
          'name': 'optional_float',
          'is_list': False,
          'optional': True,
          'type': 'float',
      },
      'string': {
          'name': 'string',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'optional_string': {
          'name': 'optional_string',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'enum': {
          'name': 'enum',
          'is_list': False,
          'optional': False,
          'type': 'enums.ABeautifulEnum',
      },
      'optional_enum': {
          'name': 'optional_enum',
          'is_list': False,
          'optional': True,
          'type': 'enums.ABeautifulEnum',
      },
      'boolean': {
          'name': 'boolean',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'optional_boolean': {
          'name': 'optional_boolean',
          'is_list': False,
          'optional': True,
          'type': 'bool',
      },
      'posts': {
          'name': 'posts',
          'is_list': True,
          'optional': True,
          'type': 'List[\'models.Post\']',
      },
  }
  
  _M_relational_fields: Set[str] = {
          'n',
      }
  _M_fields: Dict['types.MKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'n': {
          'name': 'n',
          'is_list': True,
          'optional': True,
          'type': 'List[\'models.N\']',
      },
      'int': {
          'name': 'int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'optional_int': {
          'name': 'optional_int',
          'is_list': False,
          'optional': True,
          'type': 'int',
      },
      'float': {
          'name': 'float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
      'optional_float': {
          'name': 'optional_float',
          'is_list': False,
          'optional': True,
          'type': 'float',
      },
      'string': {
          'name': 'string',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'optional_string': {
          'name': 'optional_string',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'enum': {
          'name': 'enum',
          'is_list': False,
          'optional': False,
          'type': 'enums.ABeautifulEnum',
      },
      'optional_enum': {
          'name': 'optional_enum',
          'is_list': False,
          'optional': True,
          'type': 'enums.ABeautifulEnum',
      },
      'boolean': {
          'name': 'boolean',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'optional_boolean': {
          'name': 'optional_boolean',
          'is_list': False,
          'optional': True,
          'type': 'bool',
      },
  }
  
  _N_relational_fields: Set[str] = {
          'm',
      }
  _N_fields: Dict['types.NKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'm': {
          'name': 'm',
          'is_list': True,
          'optional': True,
          'type': 'List[\'models.M\']',
      },
      'int': {
          'name': 'int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'optional_int': {
          'name': 'optional_int',
          'is_list': False,
          'optional': True,
          'type': 'int',
      },
      'float': {
          'name': 'float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
      'optional_float': {
          'name': 'optional_float',
          'is_list': False,
          'optional': True,
          'type': 'float',
      },
      'string': {
          'name': 'string',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'optional_string': {
          'name': 'optional_string',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'json_': {
          'name': 'json_',
          'is_list': False,
          'optional': False,
          'type': 'fields.Json',
      },
      'optional_json': {
          'name': 'optional_json',
          'is_list': False,
          'optional': True,
          'type': 'fields.Json',
      },
      'enum': {
          'name': 'enum',
          'is_list': False,
          'optional': False,
          'type': 'enums.ABeautifulEnum',
      },
      'optional_enum': {
          'name': 'optional_enum',
          'is_list': False,
          'optional': True,
          'type': 'enums.ABeautifulEnum',
      },
      'boolean': {
          'name': 'boolean',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'optional_boolean': {
          'name': 'optional_boolean',
          'is_list': False,
          'optional': True,
          'type': 'bool',
      },
  }
  
  _OneOptional_relational_fields: Set[str] = {
          'many',
      }
  _OneOptional_fields: Dict['types.OneOptionalKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'many': {
          'name': 'many',
          'is_list': True,
          'optional': True,
          'type': 'List[\'models.ManyRequired\']',
      },
      'int': {
          'name': 'int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'optional_int': {
          'name': 'optional_int',
          'is_list': False,
          'optional': True,
          'type': 'int',
      },
      'float': {
          'name': 'float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
      'optional_float': {
          'name': 'optional_float',
          'is_list': False,
          'optional': True,
          'type': 'float',
      },
      'string': {
          'name': 'string',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'optional_string': {
          'name': 'optional_string',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'enum': {
          'name': 'enum',
          'is_list': False,
          'optional': False,
          'type': 'enums.ABeautifulEnum',
      },
      'optional_enum': {
          'name': 'optional_enum',
          'is_list': False,
          'optional': True,
          'type': 'enums.ABeautifulEnum',
      },
      'boolean': {
          'name': 'boolean',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'optional_boolean': {
          'name': 'optional_boolean',
          'is_list': False,
          'optional': True,
          'type': 'bool',
      },
  }
  
  _ManyRequired_relational_fields: Set[str] = {
          'one',
      }
  _ManyRequired_fields: Dict['types.ManyRequiredKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'one': {
          'name': 'one',
          'is_list': False,
          'optional': True,
          'type': 'models.OneOptional',
      },
      'one_optional_id': {
          'name': 'one_optional_id',
          'is_list': False,
          'optional': True,
          'type': 'int',
      },
      'int': {
          'name': 'int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'optional_int': {
          'name': 'optional_int',
          'is_list': False,
          'optional': True,
          'type': 'int',
      },
      'float': {
          'name': 'float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
      'optional_float': {
          'name': 'optional_float',
          'is_list': False,
          'optional': True,
          'type': 'float',
      },
      'string': {
          'name': 'string',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'optional_string': {
          'name': 'optional_string',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'enum': {
          'name': 'enum',
          'is_list': False,
          'optional': False,
          'type': 'enums.ABeautifulEnum',
      },
      'optional_enum': {
          'name': 'optional_enum',
          'is_list': False,
          'optional': True,
          'type': 'enums.ABeautifulEnum',
      },
      'boolean': {
          'name': 'boolean',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'optional_boolean': {
          'name': 'optional_boolean',
          'is_list': False,
          'optional': True,
          'type': 'bool',
      },
  }
  
  _Lists_relational_fields: Set[str] = set()  # pyright: reportUnusedVariable=false
  _Lists_fields: Dict['types.ListsKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'strings': {
          'name': 'strings',
          'is_list': True,
          'optional': False,
          'type': 'List[str]',
      },
      'bytes': {
          'name': 'bytes',
          'is_list': True,
          'optional': False,
          'type': 'List[\'fields.Base64\']',
      },
      'dates': {
          'name': 'dates',
          'is_list': True,
          'optional': False,
          'type': 'List[datetime.datetime]',
      },
      'bools': {
          'name': 'bools',
          'is_list': True,
          'optional': False,
          'type': 'List[bool]',
      },
      'ints': {
          'name': 'ints',
          'is_list': True,
          'optional': False,
          'type': 'List[int]',
      },
      'floats': {
          'name': 'floats',
          'is_list': True,
          'optional': False,
          'type': 'List[float]',
      },
      'bigints': {
          'name': 'bigints',
          'is_list': True,
          'optional': False,
          'type': 'List[int]',
      },
      'json_objects': {
          'name': 'json_objects',
          'is_list': True,
          'optional': False,
          'type': 'List[\'fields.Json\']',
      },
  }
  
  _A_relational_fields: Set[str] = set()  # pyright: reportUnusedVariable=false
  _A_fields: Dict['types.AKeys', PartialModelField] = {
      'email': {
          'name': 'email',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'name': {
          'name': 'name',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'int': {
          'name': 'int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'sInt': {
          'name': 'sInt',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'inc_int': {
          'name': 'inc_int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'inc_sInt': {
          'name': 'inc_sInt',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'bInt': {
          'name': 'bInt',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'inc_bInt': {
          'name': 'inc_bInt',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
  }
  
  _B_relational_fields: Set[str] = set()  # pyright: reportUnusedVariable=false
  _B_fields: Dict['types.BKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'float': {
          'name': 'float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
      'd_float': {
          'name': 'd_float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
  }
  
  _C_relational_fields: Set[str] = set()  # pyright: reportUnusedVariable=false
  _C_fields: Dict['types.CKeys', PartialModelField] = {
      'char': {
          'name': 'char',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'v_char': {
          'name': 'v_char',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'text': {
          'name': 'text',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'bit': {
          'name': 'bit',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'v_bit': {
          'name': 'v_bit',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'uuid': {
          'name': 'uuid',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
  }
  
  _D_relational_fields: Set[str] = set()  # pyright: reportUnusedVariable=false
  _D_fields: Dict['types.DKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'bool': {
          'name': 'bool',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'xml': {
          'name': 'xml',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'json_': {
          'name': 'json_',
          'is_list': False,
          'optional': False,
          'type': 'fields.Json',
      },
      'jsonb': {
          'name': 'jsonb',
          'is_list': False,
          'optional': False,
          'type': 'fields.Json',
      },
      'binary': {
          'name': 'binary',
          'is_list': False,
          'optional': False,
          'type': 'fields.Base64',
      },
  }
  
  _E_relational_fields: Set[str] = set()  # pyright: reportUnusedVariable=false
  _E_fields: Dict['types.EKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'date': {
          'name': 'date',
          'is_list': False,
          'optional': False,
          'type': 'datetime.datetime',
      },
      'time': {
          'name': 'time',
          'is_list': False,
          'optional': False,
          'type': 'datetime.datetime',
      },
      'ts': {
          'name': 'ts',
          'is_list': False,
          'optional': False,
          'type': 'datetime.datetime',
      },
  }
  
  
  
  # we have to import ourselves as relation types are namespaced to models
  # e.g. models.Post
  from . import models, actions
  
  # required to support relationships between models
  Post.update_forward_refs()
  User.update_forward_refs()
  M.update_forward_refs()
  N.update_forward_refs()
  OneOptional.update_forward_refs()
  ManyRequired.update_forward_refs()
  Lists.update_forward_refs()
  A.update_forward_refs()
  B.update_forward_refs()
  C.update_forward_refs()
  D.update_forward_refs()
  E.update_forward_refs()
  
  '
---
# name: test_async[partials.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Callable,
      Generic,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  from typing_extensions import TypedDict, Literal
  
  # -- template partials.py.jinja --
  from pydantic import BaseModel, Field, validator
  from . import types, models, fields, enums
  
  
  
  # users can modify relational types which are then namespaced to partials.
  # so we have to import ourselves in order to resolve forward references
  from . import partials
  
  
  # fmt: on
  
  '
---
# name: test_async[types.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Callable,
      Generic,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  from typing_extensions import TypedDict, Literal
  
  # -- template types.py.jinja --
  from .utils import _NoneType
  
  
  
  # TODO: cleanup whitespace control
  # TODO: add an argument to signify that the last iteration should be skipped
  
  
  SortMode = Literal['default', 'insensitive']
  SortOrder = Literal['asc', 'desc']
  
  
  class _DatasourceOverrideOptional(TypedDict, total=False):
      env: str
      name: str
  
  
  class DatasourceOverride(_DatasourceOverrideOptional):
      url: str
  
  
  # types that can be serialized to json by our query builder
  Serializable = Union[
      None,
      bool,
      float,
      int,
      str,
      datetime.datetime,
      List[Any],
      Dict[None, Any],
      Dict[bool, Any],
      Dict[float, Any],
      Dict[int, Any],
      Dict[str, Any],
  ]
  
  
      
  
  StringFilter = TypedDict(
      'StringFilter',
      {
          'equals': str,
          'not_in': List[str],
          'lt': str,
          'lte': str,
          'gt': str,
          'gte': str,
          'contains': str,
          'startswith': str,
          'endswith': str,
          'in': List[str],
          'not': Union[str, 'StringFilterRecursive1'],
          'mode': SortMode,
      },
      total=False,
  )
  
  
  StringFilterRecursive1 = TypedDict(
      'StringFilterRecursive1',
      {
          'equals': str,
          'not_in': List[str],
          'lt': str,
          'lte': str,
          'gt': str,
          'gte': str,
          'contains': str,
          'startswith': str,
          'endswith': str,
          'in': List[str],
          'not': Union[str, 'StringFilterRecursive2'],
          'mode': SortMode,
      },
      total=False,
  )
  
  
  StringFilterRecursive2 = TypedDict(
      'StringFilterRecursive2',
      {
          'equals': str,
          'not_in': List[str],
          'lt': str,
          'lte': str,
          'gt': str,
          'gte': str,
          'contains': str,
          'startswith': str,
          'endswith': str,
          'in': List[str],
                  'mode': SortMode,
      },
      total=False,
  )
  
      
  
  DateTimeFilter = TypedDict(
      'DateTimeFilter',
      {
          'equals': datetime.datetime,
          'not_in': List[datetime.datetime],
          'lt': datetime.datetime,
          'lte': datetime.datetime,
          'gt': datetime.datetime,
          'gte': datetime.datetime,
          'in': List[datetime.datetime],
          'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
      },
      total=False,
  )
  
  
  DateTimeFilterRecursive1 = TypedDict(
      'DateTimeFilterRecursive1',
      {
          'equals': datetime.datetime,
          'not_in': List[datetime.datetime],
          'lt': datetime.datetime,
          'lte': datetime.datetime,
          'gt': datetime.datetime,
          'gte': datetime.datetime,
          'in': List[datetime.datetime],
          'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
      },
      total=False,
  )
  
  
  DateTimeFilterRecursive2 = TypedDict(
      'DateTimeFilterRecursive2',
      {
          'equals': datetime.datetime,
          'not_in': List[datetime.datetime],
          'lt': datetime.datetime,
          'lte': datetime.datetime,
          'gt': datetime.datetime,
          'gte': datetime.datetime,
          'in': List[datetime.datetime],
              },
      total=False,
  )
  
  
      
  
  BooleanFilter = TypedDict(
      'BooleanFilter',
      {
          'equals': bool,
          'not': Union[bool, 'BooleanFilterRecursive1'],
      },
      total=False,
  )
  
  
  BooleanFilterRecursive1 = TypedDict(
      'BooleanFilterRecursive1',
      {
          'equals': bool,
          'not': Union[bool, 'BooleanFilterRecursive2'],
      },
      total=False,
  )
  
  
  BooleanFilterRecursive2 = TypedDict(
      'BooleanFilterRecursive2',
      {
          'equals': bool,
              },
      total=False,
  )
  
  
      
  
  IntFilter = TypedDict(
      'IntFilter',
      {
          'equals': int,
          'not_in': List[int],
          'lt': int,
          'lte': int,
          'gt': int,
          'gte': int,
          'in': List[int],
          'not': Union[int, 'IntFilterRecursive1'],
      },
      total=False,
  )
  
  
  IntFilterRecursive1 = TypedDict(
      'IntFilterRecursive1',
      {
          'equals': int,
          'not_in': List[int],
          'lt': int,
          'lte': int,
          'gt': int,
          'gte': int,
          'in': List[int],
          'not': Union[int, 'IntFilterRecursive2'],
      },
      total=False,
  )
  
  
  IntFilterRecursive2 = TypedDict(
      'IntFilterRecursive2',
      {
          'equals': int,
          'not_in': List[int],
          'lt': int,
          'lte': int,
          'gt': int,
          'gte': int,
          'in': List[int],
              },
      total=False,
  )
  
  
  BigIntFilter = IntFilter
      
  
  FloatFilter = TypedDict(
      'FloatFilter',
      {
          'equals': float,
          'not_in': List[float],
          'lt': float,
          'lte': float,
          'gt': float,
          'gte': float,
          'in': List[float],
          'not': Union[float, 'FloatFilterRecursive1'],
      },
      total=False,
  )
  
  
  FloatFilterRecursive1 = TypedDict(
      'FloatFilterRecursive1',
      {
          'equals': float,
          'not_in': List[float],
          'lt': float,
          'lte': float,
          'gt': float,
          'gte': float,
          'in': List[float],
          'not': Union[float, 'FloatFilterRecursive2'],
      },
      total=False,
  )
  
  
  FloatFilterRecursive2 = TypedDict(
      'FloatFilterRecursive2',
      {
          'equals': float,
          'not_in': List[float],
          'lt': float,
          'lte': float,
          'gt': float,
          'gte': float,
          'in': List[float],
              },
      total=False,
  )
  
      
  
  BytesFilter = TypedDict(
      'BytesFilter',
      {
          'equals': 'fields.Base64',
          'not': Union['fields.Base64', 'BytesFilterRecursive1'],
      },
      total=False,
  )
  
  
  BytesFilterRecursive1 = TypedDict(
      'BytesFilterRecursive1',
      {
          'equals': 'fields.Base64',
          'not': Union['fields.Base64', 'BytesFilterRecursive2'],
      },
      total=False,
  )
  
  
  BytesFilterRecursive2 = TypedDict(
      'BytesFilterRecursive2',
      {
          'equals': 'fields.Base64',
              },
      total=False,
  )
  
  # TODO: preview feature for improving JSON filtering
  JsonFilter = TypedDict(
      'JsonFilter',
      {
          'equals': 'fields.Json',
          'not': 'fields.Json',
      },
      total=False,
  )
  
  
  class _FloatSetInput(TypedDict):
      set: float
  
  
  class _FloatDivideInput(TypedDict):
      divide: float
  
  
  class _FloatMultiplyInput(TypedDict):
      multiply: float
  
  
  class _FloatIncrementInput(TypedDict):
      increment: float
  
  
  class _FloatDecrementInput(TypedDict):
      decrement: float
  
  
  class _IntSetInput(TypedDict):
      set: int
  
  
  class _IntDivideInput(TypedDict):
      divide: int
  
  
  class _IntMultiplyInput(TypedDict):
      multiply: int
  
  
  class _IntIncrementInput(TypedDict):
      increment: int
  
  
  class _IntDecrementInput(TypedDict):
      decrement: int
  
  
  AtomicFloatInput = Union[
      _FloatSetInput,
      _FloatDivideInput,
      _FloatMultiplyInput,
      _FloatIncrementInput,
      _FloatDecrementInput,
  ]
  AtomicIntInput = Union[
      _IntSetInput,
      _IntDivideInput,
      _IntMultiplyInput,
      _IntIncrementInput,
      _IntDecrementInput,
  ]
  AtomicBigIntInput = AtomicIntInput
  
  class _StringListFilterEqualsInput(TypedDict):
      equals: Optional[List[str]]
  
  
  class _StringListFilterHasInput(TypedDict):
      has: str
  
  
  class _StringListFilterHasEveryInput(TypedDict):
      has_every: List[str]
  
  
  class _StringListFilterHasSomeInput(TypedDict):
      has_some: List[str]
  
  
  class _StringListFilterIsEmptyInput(TypedDict):
      is_empty: bool
  
  
  StringListFilter = Union[
      _StringListFilterHasInput,
      _StringListFilterEqualsInput,
      _StringListFilterHasSomeInput,
      _StringListFilterIsEmptyInput,
      _StringListFilterHasEveryInput,
  ]
  
  
  class _StringListUpdateSet(TypedDict):
      set: List[str]
  
  
  class _StringListUpdatePush(TypedDict):
      push: List[str]
  
  
  StringListUpdate = Union[
      List[str],
      _StringListUpdateSet,
      _StringListUpdatePush,
  ]
  
  class _BytesListFilterEqualsInput(TypedDict):
      equals: Optional[List['fields.Base64']]
  
  
  class _BytesListFilterHasInput(TypedDict):
      has: 'fields.Base64'
  
  
  class _BytesListFilterHasEveryInput(TypedDict):
      has_every: List['fields.Base64']
  
  
  class _BytesListFilterHasSomeInput(TypedDict):
      has_some: List['fields.Base64']
  
  
  class _BytesListFilterIsEmptyInput(TypedDict):
      is_empty: bool
  
  
  BytesListFilter = Union[
      _BytesListFilterHasInput,
      _BytesListFilterEqualsInput,
      _BytesListFilterHasSomeInput,
      _BytesListFilterIsEmptyInput,
      _BytesListFilterHasEveryInput,
  ]
  
  
  class _BytesListUpdateSet(TypedDict):
      set: List['fields.Base64']
  
  
  class _BytesListUpdatePush(TypedDict):
      push: List['fields.Base64']
  
  
  BytesListUpdate = Union[
      List['fields.Base64'],
      _BytesListUpdateSet,
      _BytesListUpdatePush,
  ]
  
  class _DateTimeListFilterEqualsInput(TypedDict):
      equals: Optional[List[datetime.datetime]]
  
  
  class _DateTimeListFilterHasInput(TypedDict):
      has: datetime.datetime
  
  
  class _DateTimeListFilterHasEveryInput(TypedDict):
      has_every: List[datetime.datetime]
  
  
  class _DateTimeListFilterHasSomeInput(TypedDict):
      has_some: List[datetime.datetime]
  
  
  class _DateTimeListFilterIsEmptyInput(TypedDict):
      is_empty: bool
  
  
  DateTimeListFilter = Union[
      _DateTimeListFilterHasInput,
      _DateTimeListFilterEqualsInput,
      _DateTimeListFilterHasSomeInput,
      _DateTimeListFilterIsEmptyInput,
      _DateTimeListFilterHasEveryInput,
  ]
  
  
  class _DateTimeListUpdateSet(TypedDict):
      set: List[datetime.datetime]
  
  
  class _DateTimeListUpdatePush(TypedDict):
      push: List[datetime.datetime]
  
  
  DateTimeListUpdate = Union[
      List[datetime.datetime],
      _DateTimeListUpdateSet,
      _DateTimeListUpdatePush,
  ]
  
  class _BooleanListFilterEqualsInput(TypedDict):
      equals: Optional[List[bool]]
  
  
  class _BooleanListFilterHasInput(TypedDict):
      has: bool
  
  
  class _BooleanListFilterHasEveryInput(TypedDict):
      has_every: List[bool]
  
  
  class _BooleanListFilterHasSomeInput(TypedDict):
      has_some: List[bool]
  
  
  class _BooleanListFilterIsEmptyInput(TypedDict):
      is_empty: bool
  
  
  BooleanListFilter = Union[
      _BooleanListFilterHasInput,
      _BooleanListFilterEqualsInput,
      _BooleanListFilterHasSomeInput,
      _BooleanListFilterIsEmptyInput,
      _BooleanListFilterHasEveryInput,
  ]
  
  
  class _BooleanListUpdateSet(TypedDict):
      set: List[bool]
  
  
  class _BooleanListUpdatePush(TypedDict):
      push: List[bool]
  
  
  BooleanListUpdate = Union[
      List[bool],
      _BooleanListUpdateSet,
      _BooleanListUpdatePush,
  ]
  
  class _IntListFilterEqualsInput(TypedDict):
      equals: Optional[List[int]]
  
  
  class _IntListFilterHasInput(TypedDict):
      has: int
  
  
  class _IntListFilterHasEveryInput(TypedDict):
      has_every: List[int]
  
  
  class _IntListFilterHasSomeInput(TypedDict):
      has_some: List[int]
  
  
  class _IntListFilterIsEmptyInput(TypedDict):
      is_empty: bool
  
  
  IntListFilter = Union[
      _IntListFilterHasInput,
      _IntListFilterEqualsInput,
      _IntListFilterHasSomeInput,
      _IntListFilterIsEmptyInput,
      _IntListFilterHasEveryInput,
  ]
  
  
  class _IntListUpdateSet(TypedDict):
      set: List[int]
  
  
  class _IntListUpdatePush(TypedDict):
      push: List[int]
  
  
  IntListUpdate = Union[
      List[int],
      _IntListUpdateSet,
      _IntListUpdatePush,
  ]
  
  class _BigIntListFilterEqualsInput(TypedDict):
      equals: Optional[List[int]]
  
  
  class _BigIntListFilterHasInput(TypedDict):
      has: int
  
  
  class _BigIntListFilterHasEveryInput(TypedDict):
      has_every: List[int]
  
  
  class _BigIntListFilterHasSomeInput(TypedDict):
      has_some: List[int]
  
  
  class _BigIntListFilterIsEmptyInput(TypedDict):
      is_empty: bool
  
  
  BigIntListFilter = Union[
      _BigIntListFilterHasInput,
      _BigIntListFilterEqualsInput,
      _BigIntListFilterHasSomeInput,
      _BigIntListFilterIsEmptyInput,
      _BigIntListFilterHasEveryInput,
  ]
  
  
  class _BigIntListUpdateSet(TypedDict):
      set: List[int]
  
  
  class _BigIntListUpdatePush(TypedDict):
      push: List[int]
  
  
  BigIntListUpdate = Union[
      List[int],
      _BigIntListUpdateSet,
      _BigIntListUpdatePush,
  ]
  
  class _FloatListFilterEqualsInput(TypedDict):
      equals: Optional[List[float]]
  
  
  class _FloatListFilterHasInput(TypedDict):
      has: float
  
  
  class _FloatListFilterHasEveryInput(TypedDict):
      has_every: List[float]
  
  
  class _FloatListFilterHasSomeInput(TypedDict):
      has_some: List[float]
  
  
  class _FloatListFilterIsEmptyInput(TypedDict):
      is_empty: bool
  
  
  FloatListFilter = Union[
      _FloatListFilterHasInput,
      _FloatListFilterEqualsInput,
      _FloatListFilterHasSomeInput,
      _FloatListFilterIsEmptyInput,
      _FloatListFilterHasEveryInput,
  ]
  
  
  class _FloatListUpdateSet(TypedDict):
      set: List[float]
  
  
  class _FloatListUpdatePush(TypedDict):
      push: List[float]
  
  
  FloatListUpdate = Union[
      List[float],
      _FloatListUpdateSet,
      _FloatListUpdatePush,
  ]
  
  class _JsonListFilterEqualsInput(TypedDict):
      equals: Optional[List['fields.Json']]
  
  
  class _JsonListFilterHasInput(TypedDict):
      has: 'fields.Json'
  
  
  class _JsonListFilterHasEveryInput(TypedDict):
      has_every: List['fields.Json']
  
  
  class _JsonListFilterHasSomeInput(TypedDict):
      has_some: List['fields.Json']
  
  
  class _JsonListFilterIsEmptyInput(TypedDict):
      is_empty: bool
  
  
  JsonListFilter = Union[
      _JsonListFilterHasInput,
      _JsonListFilterEqualsInput,
      _JsonListFilterHasSomeInput,
      _JsonListFilterIsEmptyInput,
      _JsonListFilterHasEveryInput,
  ]
  
  
  class _JsonListUpdateSet(TypedDict):
      set: List['fields.Json']
  
  
  class _JsonListUpdatePush(TypedDict):
      push: List['fields.Json']
  
  
  JsonListUpdate = Union[
      List['fields.Json'],
      _JsonListUpdateSet,
      _JsonListUpdatePush,
  ]
  
  class _ABeautifulEnumListFilterEqualsInput(TypedDict):
      equals: Optional[List['enums.ABeautifulEnum']]
  
  
  class _ABeautifulEnumListFilterHasInput(TypedDict):
      has: 'enums.ABeautifulEnum'
  
  
  class _ABeautifulEnumListFilterHasEveryInput(TypedDict):
      has_every: List['enums.ABeautifulEnum']
  
  
  class _ABeautifulEnumListFilterHasSomeInput(TypedDict):
      has_some: List['enums.ABeautifulEnum']
  
  
  class _ABeautifulEnumListFilterIsEmptyInput(TypedDict):
      is_empty: bool
  
  
  ABeautifulEnumListFilter = Union[
      _ABeautifulEnumListFilterHasInput,
      _ABeautifulEnumListFilterEqualsInput,
      _ABeautifulEnumListFilterHasSomeInput,
      _ABeautifulEnumListFilterIsEmptyInput,
      _ABeautifulEnumListFilterHasEveryInput,
  ]
  
  
  class _ABeautifulEnumListUpdateSet(TypedDict):
      set: List['enums.ABeautifulEnum']
  
  
  class _ABeautifulEnumListUpdatePush(TypedDict):
      push: List['enums.ABeautifulEnum']
  
  
  ABeautifulEnumListUpdate = Union[
      List['enums.ABeautifulEnum'],
      _ABeautifulEnumListUpdateSet,
      _ABeautifulEnumListUpdatePush,
  ]
  
  
  # Post types
  
  class PostOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the Post create method"""
      id: int
      created_at: datetime.datetime
      content: Optional[str]
      published: bool
      author: 'UserCreateNestedWithoutRelationsInput'
  
  
  class PostCreateInput(PostOptionalCreateInput):
      """Required arguments to the Post create method"""
      title: str
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class PostOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the Post create method, without relations"""
      id: int
      created_at: datetime.datetime
      content: Optional[str]
      published: bool
  
  
  class PostCreateWithoutRelationsInput(PostOptionalCreateWithoutRelationsInput):
      """Required arguments to the Post create method, without relations"""
      title: str
  
  
  class PostCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'PostCreateWithoutRelationsInput'
      connect: 'PostWhereUniqueInput'
  
  
  class PostCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['PostCreateWithoutRelationsInput', List['PostCreateWithoutRelationsInput']]
      connect: Union['PostWhereUniqueInput', List['PostWhereUniqueInput']]
  
  
  
  _PostWhereUnique_id_Input = TypedDict(
      '_PostWhereUnique_id_Input',
      {
          'id': 'int',
      },
      total=True
  )
  
  PostWhereUniqueInput = _PostWhereUnique_id_Input
  
  
  class PostUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      created_at: datetime.datetime
      title: str
      content: Optional[str]
      published: bool
      author: 'UserUpdateOneWithoutRelationsInput'
  
  
  class PostUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: Union[AtomicIntInput, int]
      created_at: datetime.datetime
      title: str
      content: Optional[str]
      published: bool
      author: 'UserUpdateOneWithoutRelationsInput'
  
  
  class PostUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['PostCreateWithoutRelationsInput']
      connect: List['PostWhereUniqueInput']
      set: List['PostWhereUniqueInput']
      disconnect: List['PostWhereUniqueInput']
      delete: List['PostWhereUniqueInput']
  
      # TODO
      # update: List['PostUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['PostUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['PostScalarWhereInput']
      # upsert: List['PostUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['PostCreateOrConnectWithoutRelationsInput']
  
  
  class PostUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'PostCreateWithoutRelationsInput'
      connect: 'PostWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'PostUpdateInput'
      # upsert: 'PostUpsertWithoutRelationsInput'
      # connectOrCreate: 'PostCreateOrConnectWithoutRelationsInput'
  
  
  class PostUpsertInput(TypedDict):
      create: 'PostCreateInput'
      update: 'PostUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class PostOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      created_at: 'SortOrder'
      title: 'SortOrder'
      content: 'SortOrder'
      published: 'SortOrder'
      author_id: 'SortOrder'
  
  
  # recursive Post types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/
  
  PostRelationFilter = TypedDict(
      'PostRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class PostListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class PostInclude(TypedDict, total=False):
      """Post relational arguments"""
      author: Union[bool, 'UserArgsFromPost']
  
  
      
  
  class PostIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
      author: Union[bool, 'UserArgsFromPostRecursive1']
  
  
  class PostIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
      author: Union[bool, 'UserArgsFromPostRecursive2']
  
  
  class PostIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class PostArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyPostArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
      posts: Union[bool, 'FindManyPostArgsFromPostRecursive1']
  
  
  class UserIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
      posts: Union[bool, 'FindManyPostArgsFromPostRecursive2']
  
  
  class UserIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class UserArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyUserArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
      n: Union[bool, 'FindManyNArgsFromPostRecursive1']
  
  
  class MIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
      n: Union[bool, 'FindManyNArgsFromPostRecursive2']
  
  
  class MIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class MArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyMArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
      m: Union[bool, 'FindManyMArgsFromPostRecursive1']
  
  
  class NIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
      m: Union[bool, 'FindManyMArgsFromPostRecursive2']
  
  
  class NIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class NArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyNArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
      many: Union[bool, 'FindManyManyRequiredArgsFromPostRecursive1']
  
  
  class OneOptionalIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
      many: Union[bool, 'FindManyManyRequiredArgsFromPostRecursive2']
  
  
  class OneOptionalIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class OneOptionalArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyOneOptionalArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
      one: Union[bool, 'OneOptionalArgsFromPostRecursive1']
  
  
  class ManyRequiredIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
      one: Union[bool, 'OneOptionalArgsFromPostRecursive2']
  
  
  class ManyRequiredIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class ManyRequiredArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyManyRequiredArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class ListsIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class ListsIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class ListsIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class ListsArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class ListsArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class ListsArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyListsArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class FindManyListsArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class FindManyListsArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      
      
  
  class AIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class AIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class AIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class AArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyAArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class BIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class BIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class BArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyBArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class CIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class CIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class CArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyCArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class DIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class DIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class DArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyDArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class EIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class EIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class EArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyEArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyPostArgs = FindManyPostArgsFromPost
  FindFirstPostArgs = FindManyPostArgsFromPost
  
  
      
  
  class PostWhereInput(TypedDict, total=False):
      """Post arguments for searching"""
      id: Union[int, 'types.IntFilter']
      created_at: Union[datetime.datetime, 'types.DateTimeFilter']
      title: Union[str, 'types.StringFilter']
      content: Union[str, 'types.StringFilter']
      published: Union[bool, 'types.BooleanFilter']
      author: 'UserRelationFilter'
      author_id: Union[int, 'types.IntFilter']
  
      # should be noted that AND and NOT should be Union['PostWhereInputRecursive1', List['PostWhereInputRecursive1']]
      # but this causes mypy to hang :/
      AND: List['PostWhereInputRecursive1']
      OR: List['PostWhereInputRecursive1']
      NOT: List['PostWhereInputRecursive1']
  
  
  class PostWhereInputRecursive1(TypedDict, total=False):
      """Post arguments for searching"""
      id: Union[int, 'types.IntFilter']
      created_at: Union[datetime.datetime, 'types.DateTimeFilter']
      title: Union[str, 'types.StringFilter']
      content: Union[str, 'types.StringFilter']
      published: Union[bool, 'types.BooleanFilter']
      author: 'UserRelationFilter'
      author_id: Union[int, 'types.IntFilter']
  
      # should be noted that AND and NOT should be Union['PostWhereInputRecursive2', List['PostWhereInputRecursive2']]
      # but this causes mypy to hang :/
      AND: List['PostWhereInputRecursive2']
      OR: List['PostWhereInputRecursive2']
      NOT: List['PostWhereInputRecursive2']
  
  
  class PostWhereInputRecursive2(TypedDict, total=False):
      """Post arguments for searching"""
      id: Union[int, 'types.IntFilter']
      created_at: Union[datetime.datetime, 'types.DateTimeFilter']
      title: Union[str, 'types.StringFilter']
      content: Union[str, 'types.StringFilter']
      published: Union[bool, 'types.BooleanFilter']
      author: 'UserRelationFilter'
      author_id: Union[int, 'types.IntFilter']
  
  
  
  PostCountAggregateInput = TypedDict(
      'PostCountAggregateInput',
      {
          'id': bool,
          'created_at': bool,
          'title': bool,
          'content': bool,
          'published': bool,
          'author_id': bool,
          '_all': bool,
      },
      total=False,
  )
  
  PostCountAggregateOutput = TypedDict(
      'PostCountAggregateOutput',
      {
          'id': int,
          'created_at': int,
          'title': int,
          'content': int,
          'published': int,
          'author_id': int,
          '_all': int,
      },
      total=False,
  )
  
  
  PostKeys = Literal[
      'id',
      'created_at',
      'title',
      'content',
      'published',
      'author',
      'author_id',
  ]
  
  PostRelationalFieldKeys = Literal[
          'author',
      ]
  
  # User types
  
  class UserOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the User create method"""
      id: int
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
      posts: 'PostCreateManyNestedWithoutRelationsInput'
  
  
  class UserCreateInput(UserOptionalCreateInput):
      """Required arguments to the User create method"""
      email: str
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class UserOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the User create method, without relations"""
      id: int
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class UserCreateWithoutRelationsInput(UserOptionalCreateWithoutRelationsInput):
      """Required arguments to the User create method, without relations"""
      email: str
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  class UserCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'UserCreateWithoutRelationsInput'
      connect: 'UserWhereUniqueInput'
  
  
  class UserCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['UserCreateWithoutRelationsInput', List['UserCreateWithoutRelationsInput']]
      connect: Union['UserWhereUniqueInput', List['UserWhereUniqueInput']]
  
  
  
  _UserWhereUnique_id_Input = TypedDict(
      '_UserWhereUnique_id_Input',
      {
          'id': 'int',
      },
      total=True
  )
  
  _UserWhereUnique_email_Input = TypedDict(
      '_UserWhereUnique_email_Input',
      {
          'email': 'str',
      },
      total=True
  )
  
  UserWhereUniqueInput = Union[
      '_UserWhereUnique_id_Input',
      '_UserWhereUnique_email_Input',
  ]
  
  
  class UserUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
      posts: 'PostUpdateManyWithoutRelationsInput'
  
  
  class UserUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: Union[AtomicIntInput, int]
      email: str
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
      posts: 'PostUpdateManyWithoutRelationsInput'
  
  
  class UserUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['UserCreateWithoutRelationsInput']
      connect: List['UserWhereUniqueInput']
      set: List['UserWhereUniqueInput']
      disconnect: List['UserWhereUniqueInput']
      delete: List['UserWhereUniqueInput']
  
      # TODO
      # update: List['UserUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['UserUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['UserScalarWhereInput']
      # upsert: List['UserUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['UserCreateOrConnectWithoutRelationsInput']
  
  
  class UserUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'UserCreateWithoutRelationsInput'
      connect: 'UserWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'UserUpdateInput'
      # upsert: 'UserUpsertWithoutRelationsInput'
      # connectOrCreate: 'UserCreateOrConnectWithoutRelationsInput'
  
  
  class UserUpsertInput(TypedDict):
      create: 'UserCreateInput'
      update: 'UserUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class UserOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      email: 'SortOrder'
      int: 'SortOrder'
      optional_int: 'SortOrder'
      float: 'SortOrder'
      optional_float: 'SortOrder'
      string: 'SortOrder'
      optional_string: 'SortOrder'
      enum: 'SortOrder'
      optional_enum: 'SortOrder'
      boolean: 'SortOrder'
      optional_boolean: 'SortOrder'
  
  
  # recursive User types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/
  
  UserRelationFilter = TypedDict(
      'UserRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class UserListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class UserInclude(TypedDict, total=False):
      """User relational arguments"""
      posts: Union[bool, 'FindManyPostArgsFromUser']
  
  
      
  
  class PostIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
      author: Union[bool, 'UserArgsFromUserRecursive1']
  
  
  class PostIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
      author: Union[bool, 'UserArgsFromUserRecursive2']
  
  
  class PostIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class PostArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyPostArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
      posts: Union[bool, 'FindManyPostArgsFromUserRecursive1']
  
  
  class UserIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
      posts: Union[bool, 'FindManyPostArgsFromUserRecursive2']
  
  
  class UserIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class UserArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyUserArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
      n: Union[bool, 'FindManyNArgsFromUserRecursive1']
  
  
  class MIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
      n: Union[bool, 'FindManyNArgsFromUserRecursive2']
  
  
  class MIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class MArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyMArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
      m: Union[bool, 'FindManyMArgsFromUserRecursive1']
  
  
  class NIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
      m: Union[bool, 'FindManyMArgsFromUserRecursive2']
  
  
  class NIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class NArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyNArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
      many: Union[bool, 'FindManyManyRequiredArgsFromUserRecursive1']
  
  
  class OneOptionalIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
      many: Union[bool, 'FindManyManyRequiredArgsFromUserRecursive2']
  
  
  class OneOptionalIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class OneOptionalArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyOneOptionalArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
      one: Union[bool, 'OneOptionalArgsFromUserRecursive1']
  
  
  class ManyRequiredIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
      one: Union[bool, 'OneOptionalArgsFromUserRecursive2']
  
  
  class ManyRequiredIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class ManyRequiredArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyManyRequiredArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class ListsIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class ListsIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class ListsIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class ListsArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class ListsArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class ListsArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyListsArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class FindManyListsArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class FindManyListsArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      
      
  
  class AIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class AIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class AIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class AArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyAArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class BIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class BIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class BArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyBArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class CIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class CIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class CArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyCArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class DIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class DIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class DArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyDArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class EIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class EIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class EArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyEArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyUserArgs = FindManyUserArgsFromUser
  FindFirstUserArgs = FindManyUserArgsFromUser
  
  
      
  
  class UserWhereInput(TypedDict, total=False):
      """User arguments for searching"""
      id: Union[int, 'types.IntFilter']
      email: Union[str, 'types.StringFilter']
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
      posts: 'PostListRelationFilter'
  
      # should be noted that AND and NOT should be Union['UserWhereInputRecursive1', List['UserWhereInputRecursive1']]
      # but this causes mypy to hang :/
      AND: List['UserWhereInputRecursive1']
      OR: List['UserWhereInputRecursive1']
      NOT: List['UserWhereInputRecursive1']
  
  
  class UserWhereInputRecursive1(TypedDict, total=False):
      """User arguments for searching"""
      id: Union[int, 'types.IntFilter']
      email: Union[str, 'types.StringFilter']
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
      posts: 'PostListRelationFilter'
  
      # should be noted that AND and NOT should be Union['UserWhereInputRecursive2', List['UserWhereInputRecursive2']]
      # but this causes mypy to hang :/
      AND: List['UserWhereInputRecursive2']
      OR: List['UserWhereInputRecursive2']
      NOT: List['UserWhereInputRecursive2']
  
  
  class UserWhereInputRecursive2(TypedDict, total=False):
      """User arguments for searching"""
      id: Union[int, 'types.IntFilter']
      email: Union[str, 'types.StringFilter']
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
      posts: 'PostListRelationFilter'
  
  
  
  UserCountAggregateInput = TypedDict(
      'UserCountAggregateInput',
      {
          'id': bool,
          'email': bool,
          'int': bool,
          'optional_int': bool,
          'float': bool,
          'optional_float': bool,
          'string': bool,
          'optional_string': bool,
          'enum': bool,
          'optional_enum': bool,
          'boolean': bool,
          'optional_boolean': bool,
          '_all': bool,
      },
      total=False,
  )
  
  UserCountAggregateOutput = TypedDict(
      'UserCountAggregateOutput',
      {
          'id': int,
          'email': int,
          'int': int,
          'optional_int': int,
          'float': int,
          'optional_float': int,
          'string': int,
          'optional_string': int,
          'enum': int,
          'optional_enum': int,
          'boolean': int,
          'optional_boolean': int,
          '_all': int,
      },
      total=False,
  )
  
  
  UserKeys = Literal[
      'id',
      'email',
      'int',
      'optional_int',
      'float',
      'optional_float',
      'string',
      'optional_string',
      'enum',
      'optional_enum',
      'boolean',
      'optional_boolean',
      'posts',
  ]
  
  UserRelationalFieldKeys = Literal[
          'posts',
      ]
  
  # M types
  
  class MOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the M create method"""
      id: int
      n: 'NCreateManyNestedWithoutRelationsInput'
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class MCreateInput(MOptionalCreateInput):
      """Required arguments to the M create method"""
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class MOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the M create method, without relations"""
      id: int
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class MCreateWithoutRelationsInput(MOptionalCreateWithoutRelationsInput):
      """Required arguments to the M create method, without relations"""
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  class MCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'MCreateWithoutRelationsInput'
      connect: 'MWhereUniqueInput'
  
  
  class MCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['MCreateWithoutRelationsInput', List['MCreateWithoutRelationsInput']]
      connect: Union['MWhereUniqueInput', List['MWhereUniqueInput']]
  
  
  
  _MWhereUnique_id_Input = TypedDict(
      '_MWhereUnique_id_Input',
      {
          'id': 'int',
      },
      total=True
  )
  
  MWhereUniqueInput = _MWhereUnique_id_Input
  
  
  class MUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      n: 'NUpdateManyWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class MUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: Union[AtomicIntInput, int]
      n: 'NUpdateManyWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class MUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['MCreateWithoutRelationsInput']
      connect: List['MWhereUniqueInput']
      set: List['MWhereUniqueInput']
      disconnect: List['MWhereUniqueInput']
      delete: List['MWhereUniqueInput']
  
      # TODO
      # update: List['MUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['MUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['MScalarWhereInput']
      # upsert: List['MUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['MCreateOrConnectWithoutRelationsInput']
  
  
  class MUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'MCreateWithoutRelationsInput'
      connect: 'MWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'MUpdateInput'
      # upsert: 'MUpsertWithoutRelationsInput'
      # connectOrCreate: 'MCreateOrConnectWithoutRelationsInput'
  
  
  class MUpsertInput(TypedDict):
      create: 'MCreateInput'
      update: 'MUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class MOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      int: 'SortOrder'
      optional_int: 'SortOrder'
      float: 'SortOrder'
      optional_float: 'SortOrder'
      string: 'SortOrder'
      optional_string: 'SortOrder'
      enum: 'SortOrder'
      optional_enum: 'SortOrder'
      boolean: 'SortOrder'
      optional_boolean: 'SortOrder'
  
  
  # recursive M types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/
  
  MRelationFilter = TypedDict(
      'MRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class MListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class MInclude(TypedDict, total=False):
      """M relational arguments"""
      n: Union[bool, 'FindManyNArgsFromM']
  
  
      
  
  class PostIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
      author: Union[bool, 'UserArgsFromMRecursive1']
  
  
  class PostIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
      author: Union[bool, 'UserArgsFromMRecursive2']
  
  
  class PostIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class PostArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyPostArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
      posts: Union[bool, 'FindManyPostArgsFromMRecursive1']
  
  
  class UserIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
      posts: Union[bool, 'FindManyPostArgsFromMRecursive2']
  
  
  class UserIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class UserArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyUserArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
      n: Union[bool, 'FindManyNArgsFromMRecursive1']
  
  
  class MIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
      n: Union[bool, 'FindManyNArgsFromMRecursive2']
  
  
  class MIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class MArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyMArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
      m: Union[bool, 'FindManyMArgsFromMRecursive1']
  
  
  class NIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
      m: Union[bool, 'FindManyMArgsFromMRecursive2']
  
  
  class NIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class NArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyNArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
      many: Union[bool, 'FindManyManyRequiredArgsFromMRecursive1']
  
  
  class OneOptionalIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
      many: Union[bool, 'FindManyManyRequiredArgsFromMRecursive2']
  
  
  class OneOptionalIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class OneOptionalArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyOneOptionalArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
      one: Union[bool, 'OneOptionalArgsFromMRecursive1']
  
  
  class ManyRequiredIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
      one: Union[bool, 'OneOptionalArgsFromMRecursive2']
  
  
  class ManyRequiredIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class ManyRequiredArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyManyRequiredArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class ListsIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class ListsIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class ListsIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class ListsArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class ListsArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class ListsArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyListsArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class FindManyListsArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class FindManyListsArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      
      
  
  class AIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class AIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class AIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class AArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyAArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class BIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class BIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class BArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyBArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class CIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class CIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class CArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyCArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class DIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class DIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class DArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyDArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class EIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class EIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class EArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyEArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyMArgs = FindManyMArgsFromM
  FindFirstMArgs = FindManyMArgsFromM
  
  
      
  
  class MWhereInput(TypedDict, total=False):
      """M arguments for searching"""
      id: Union[int, 'types.IntFilter']
      n: 'NListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['MWhereInputRecursive1', List['MWhereInputRecursive1']]
      # but this causes mypy to hang :/
      AND: List['MWhereInputRecursive1']
      OR: List['MWhereInputRecursive1']
      NOT: List['MWhereInputRecursive1']
  
  
  class MWhereInputRecursive1(TypedDict, total=False):
      """M arguments for searching"""
      id: Union[int, 'types.IntFilter']
      n: 'NListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['MWhereInputRecursive2', List['MWhereInputRecursive2']]
      # but this causes mypy to hang :/
      AND: List['MWhereInputRecursive2']
      OR: List['MWhereInputRecursive2']
      NOT: List['MWhereInputRecursive2']
  
  
  class MWhereInputRecursive2(TypedDict, total=False):
      """M arguments for searching"""
      id: Union[int, 'types.IntFilter']
      n: 'NListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
  
  
  MCountAggregateInput = TypedDict(
      'MCountAggregateInput',
      {
          'id': bool,
          'int': bool,
          'optional_int': bool,
          'float': bool,
          'optional_float': bool,
          'string': bool,
          'optional_string': bool,
          'enum': bool,
          'optional_enum': bool,
          'boolean': bool,
          'optional_boolean': bool,
          '_all': bool,
      },
      total=False,
  )
  
  MCountAggregateOutput = TypedDict(
      'MCountAggregateOutput',
      {
          'id': int,
          'int': int,
          'optional_int': int,
          'float': int,
          'optional_float': int,
          'string': int,
          'optional_string': int,
          'enum': int,
          'optional_enum': int,
          'boolean': int,
          'optional_boolean': int,
          '_all': int,
      },
      total=False,
  )
  
  
  MKeys = Literal[
      'id',
      'n',
      'int',
      'optional_int',
      'float',
      'optional_float',
      'string',
      'optional_string',
      'enum',
      'optional_enum',
      'boolean',
      'optional_boolean',
  ]
  
  MRelationalFieldKeys = Literal[
          'n',
      ]
  
  # N types
  
  class NOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the N create method"""
      id: int
      m: 'MCreateManyNestedWithoutRelationsInput'
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_json: Optional['fields.Json']
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class NCreateInput(NOptionalCreateInput):
      """Required arguments to the N create method"""
      int: int
      float: float
      string: str
      json_: 'fields.Json'
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class NOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the N create method, without relations"""
      id: int
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_json: Optional['fields.Json']
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class NCreateWithoutRelationsInput(NOptionalCreateWithoutRelationsInput):
      """Required arguments to the N create method, without relations"""
      int: int
      float: float
      string: str
      json_: 'fields.Json'
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  class NCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'NCreateWithoutRelationsInput'
      connect: 'NWhereUniqueInput'
  
  
  class NCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['NCreateWithoutRelationsInput', List['NCreateWithoutRelationsInput']]
      connect: Union['NWhereUniqueInput', List['NWhereUniqueInput']]
  
  
  
  _NWhereUnique_id_Input = TypedDict(
      '_NWhereUnique_id_Input',
      {
          'id': 'int',
      },
      total=True
  )
  
  NWhereUniqueInput = _NWhereUnique_id_Input
  
  
  class NUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      m: 'MUpdateManyWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      json_: 'fields.Json'
      optional_json: Optional['fields.Json']
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class NUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: Union[AtomicIntInput, int]
      m: 'MUpdateManyWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      json_: 'fields.Json'
      optional_json: Optional['fields.Json']
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class NUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['NCreateWithoutRelationsInput']
      connect: List['NWhereUniqueInput']
      set: List['NWhereUniqueInput']
      disconnect: List['NWhereUniqueInput']
      delete: List['NWhereUniqueInput']
  
      # TODO
      # update: List['NUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['NUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['NScalarWhereInput']
      # upsert: List['NUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['NCreateOrConnectWithoutRelationsInput']
  
  
  class NUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'NCreateWithoutRelationsInput'
      connect: 'NWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'NUpdateInput'
      # upsert: 'NUpsertWithoutRelationsInput'
      # connectOrCreate: 'NCreateOrConnectWithoutRelationsInput'
  
  
  class NUpsertInput(TypedDict):
      create: 'NCreateInput'
      update: 'NUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class NOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      int: 'SortOrder'
      optional_int: 'SortOrder'
      float: 'SortOrder'
      optional_float: 'SortOrder'
      string: 'SortOrder'
      optional_string: 'SortOrder'
      json_: 'SortOrder'
      optional_json: 'SortOrder'
      enum: 'SortOrder'
      optional_enum: 'SortOrder'
      boolean: 'SortOrder'
      optional_boolean: 'SortOrder'
  
  
  # recursive N types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/
  
  NRelationFilter = TypedDict(
      'NRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class NListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class NInclude(TypedDict, total=False):
      """N relational arguments"""
      m: Union[bool, 'FindManyMArgsFromN']
  
  
      
  
  class PostIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
      author: Union[bool, 'UserArgsFromNRecursive1']
  
  
  class PostIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
      author: Union[bool, 'UserArgsFromNRecursive2']
  
  
  class PostIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class PostArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyPostArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
      posts: Union[bool, 'FindManyPostArgsFromNRecursive1']
  
  
  class UserIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
      posts: Union[bool, 'FindManyPostArgsFromNRecursive2']
  
  
  class UserIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class UserArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyUserArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
      n: Union[bool, 'FindManyNArgsFromNRecursive1']
  
  
  class MIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
      n: Union[bool, 'FindManyNArgsFromNRecursive2']
  
  
  class MIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class MArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyMArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
      m: Union[bool, 'FindManyMArgsFromNRecursive1']
  
  
  class NIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
      m: Union[bool, 'FindManyMArgsFromNRecursive2']
  
  
  class NIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class NArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyNArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
      many: Union[bool, 'FindManyManyRequiredArgsFromNRecursive1']
  
  
  class OneOptionalIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
      many: Union[bool, 'FindManyManyRequiredArgsFromNRecursive2']
  
  
  class OneOptionalIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class OneOptionalArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyOneOptionalArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
      one: Union[bool, 'OneOptionalArgsFromNRecursive1']
  
  
  class ManyRequiredIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
      one: Union[bool, 'OneOptionalArgsFromNRecursive2']
  
  
  class ManyRequiredIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class ManyRequiredArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyManyRequiredArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class ListsIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class ListsIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class ListsIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class ListsArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class ListsArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class ListsArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyListsArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class FindManyListsArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class FindManyListsArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      
      
  
  class AIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class AIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class AIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class AArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyAArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class BIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class BIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class BArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyBArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class CIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class CIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class CArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyCArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class DIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class DIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class DArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyDArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class EIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class EIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class EArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyEArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyNArgs = FindManyNArgsFromN
  FindFirstNArgs = FindManyNArgsFromN
  
  
      
  
  class NWhereInput(TypedDict, total=False):
      """N arguments for searching"""
      id: Union[int, 'types.IntFilter']
      m: 'MListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      json_: Union['fields.Json', 'types.JsonFilter']
      optional_json: Union['fields.Json', 'types.JsonFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['NWhereInputRecursive1', List['NWhereInputRecursive1']]
      # but this causes mypy to hang :/
      AND: List['NWhereInputRecursive1']
      OR: List['NWhereInputRecursive1']
      NOT: List['NWhereInputRecursive1']
  
  
  class NWhereInputRecursive1(TypedDict, total=False):
      """N arguments for searching"""
      id: Union[int, 'types.IntFilter']
      m: 'MListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      json_: Union['fields.Json', 'types.JsonFilter']
      optional_json: Union['fields.Json', 'types.JsonFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['NWhereInputRecursive2', List['NWhereInputRecursive2']]
      # but this causes mypy to hang :/
      AND: List['NWhereInputRecursive2']
      OR: List['NWhereInputRecursive2']
      NOT: List['NWhereInputRecursive2']
  
  
  class NWhereInputRecursive2(TypedDict, total=False):
      """N arguments for searching"""
      id: Union[int, 'types.IntFilter']
      m: 'MListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      json_: Union['fields.Json', 'types.JsonFilter']
      optional_json: Union['fields.Json', 'types.JsonFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
  
  
  NCountAggregateInput = TypedDict(
      'NCountAggregateInput',
      {
          'id': bool,
          'int': bool,
          'optional_int': bool,
          'float': bool,
          'optional_float': bool,
          'string': bool,
          'optional_string': bool,
          'json_': bool,
          'optional_json': bool,
          'enum': bool,
          'optional_enum': bool,
          'boolean': bool,
          'optional_boolean': bool,
          '_all': bool,
      },
      total=False,
  )
  
  NCountAggregateOutput = TypedDict(
      'NCountAggregateOutput',
      {
          'id': int,
          'int': int,
          'optional_int': int,
          'float': int,
          'optional_float': int,
          'string': int,
          'optional_string': int,
          'json_': int,
          'optional_json': int,
          'enum': int,
          'optional_enum': int,
          'boolean': int,
          'optional_boolean': int,
          '_all': int,
      },
      total=False,
  )
  
  
  NKeys = Literal[
      'id',
      'm',
      'int',
      'optional_int',
      'float',
      'optional_float',
      'string',
      'optional_string',
      'json_',
      'optional_json',
      'enum',
      'optional_enum',
      'boolean',
      'optional_boolean',
  ]
  
  NRelationalFieldKeys = Literal[
          'm',
      ]
  
  # OneOptional types
  
  class OneOptionalOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the OneOptional create method"""
      id: int
      many: 'ManyRequiredCreateManyNestedWithoutRelationsInput'
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class OneOptionalCreateInput(OneOptionalOptionalCreateInput):
      """Required arguments to the OneOptional create method"""
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class OneOptionalOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the OneOptional create method, without relations"""
      id: int
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class OneOptionalCreateWithoutRelationsInput(OneOptionalOptionalCreateWithoutRelationsInput):
      """Required arguments to the OneOptional create method, without relations"""
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  class OneOptionalCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'OneOptionalCreateWithoutRelationsInput'
      connect: 'OneOptionalWhereUniqueInput'
  
  
  class OneOptionalCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['OneOptionalCreateWithoutRelationsInput', List['OneOptionalCreateWithoutRelationsInput']]
      connect: Union['OneOptionalWhereUniqueInput', List['OneOptionalWhereUniqueInput']]
  
  
  
  _OneOptionalWhereUnique_id_Input = TypedDict(
      '_OneOptionalWhereUnique_id_Input',
      {
          'id': 'int',
      },
      total=True
  )
  
  OneOptionalWhereUniqueInput = _OneOptionalWhereUnique_id_Input
  
  
  class OneOptionalUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      many: 'ManyRequiredUpdateManyWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class OneOptionalUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: Union[AtomicIntInput, int]
      many: 'ManyRequiredUpdateManyWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class OneOptionalUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['OneOptionalCreateWithoutRelationsInput']
      connect: List['OneOptionalWhereUniqueInput']
      set: List['OneOptionalWhereUniqueInput']
      disconnect: List['OneOptionalWhereUniqueInput']
      delete: List['OneOptionalWhereUniqueInput']
  
      # TODO
      # update: List['OneOptionalUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['OneOptionalUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['OneOptionalScalarWhereInput']
      # upsert: List['OneOptionalUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['OneOptionalCreateOrConnectWithoutRelationsInput']
  
  
  class OneOptionalUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'OneOptionalCreateWithoutRelationsInput'
      connect: 'OneOptionalWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'OneOptionalUpdateInput'
      # upsert: 'OneOptionalUpsertWithoutRelationsInput'
      # connectOrCreate: 'OneOptionalCreateOrConnectWithoutRelationsInput'
  
  
  class OneOptionalUpsertInput(TypedDict):
      create: 'OneOptionalCreateInput'
      update: 'OneOptionalUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class OneOptionalOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      int: 'SortOrder'
      optional_int: 'SortOrder'
      float: 'SortOrder'
      optional_float: 'SortOrder'
      string: 'SortOrder'
      optional_string: 'SortOrder'
      enum: 'SortOrder'
      optional_enum: 'SortOrder'
      boolean: 'SortOrder'
      optional_boolean: 'SortOrder'
  
  
  # recursive OneOptional types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/
  
  OneOptionalRelationFilter = TypedDict(
      'OneOptionalRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class OneOptionalListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class OneOptionalInclude(TypedDict, total=False):
      """OneOptional relational arguments"""
      many: Union[bool, 'FindManyManyRequiredArgsFromOneOptional']
  
  
      
  
  class PostIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      author: Union[bool, 'UserArgsFromOneOptionalRecursive1']
  
  
  class PostIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      author: Union[bool, 'UserArgsFromOneOptionalRecursive2']
  
  
  class PostIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class PostArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyPostArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      posts: Union[bool, 'FindManyPostArgsFromOneOptionalRecursive1']
  
  
  class UserIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      posts: Union[bool, 'FindManyPostArgsFromOneOptionalRecursive2']
  
  
  class UserIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class UserArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyUserArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      n: Union[bool, 'FindManyNArgsFromOneOptionalRecursive1']
  
  
  class MIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      n: Union[bool, 'FindManyNArgsFromOneOptionalRecursive2']
  
  
  class MIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class MArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyMArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      m: Union[bool, 'FindManyMArgsFromOneOptionalRecursive1']
  
  
  class NIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      m: Union[bool, 'FindManyMArgsFromOneOptionalRecursive2']
  
  
  class NIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class NArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyNArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      many: Union[bool, 'FindManyManyRequiredArgsFromOneOptionalRecursive1']
  
  
  class OneOptionalIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      many: Union[bool, 'FindManyManyRequiredArgsFromOneOptionalRecursive2']
  
  
  class OneOptionalIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class OneOptionalArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyOneOptionalArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      one: Union[bool, 'OneOptionalArgsFromOneOptionalRecursive1']
  
  
  class ManyRequiredIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      one: Union[bool, 'OneOptionalArgsFromOneOptionalRecursive2']
  
  
  class ManyRequiredIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class ManyRequiredArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyManyRequiredArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class ListsIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class ListsIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class ListsIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class ListsArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class ListsArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class ListsArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyListsArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class FindManyListsArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class FindManyListsArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      
      
  
  class AIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class AIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class AIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class AArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyAArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class BIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class BIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class BArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyBArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class CIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class CIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class CArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyCArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class DIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class DIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class DArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyDArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class EIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class EIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class EArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyEArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyOneOptionalArgs = FindManyOneOptionalArgsFromOneOptional
  FindFirstOneOptionalArgs = FindManyOneOptionalArgsFromOneOptional
  
  
      
  
  class OneOptionalWhereInput(TypedDict, total=False):
      """OneOptional arguments for searching"""
      id: Union[int, 'types.IntFilter']
      many: 'ManyRequiredListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['OneOptionalWhereInputRecursive1', List['OneOptionalWhereInputRecursive1']]
      # but this causes mypy to hang :/
      AND: List['OneOptionalWhereInputRecursive1']
      OR: List['OneOptionalWhereInputRecursive1']
      NOT: List['OneOptionalWhereInputRecursive1']
  
  
  class OneOptionalWhereInputRecursive1(TypedDict, total=False):
      """OneOptional arguments for searching"""
      id: Union[int, 'types.IntFilter']
      many: 'ManyRequiredListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['OneOptionalWhereInputRecursive2', List['OneOptionalWhereInputRecursive2']]
      # but this causes mypy to hang :/
      AND: List['OneOptionalWhereInputRecursive2']
      OR: List['OneOptionalWhereInputRecursive2']
      NOT: List['OneOptionalWhereInputRecursive2']
  
  
  class OneOptionalWhereInputRecursive2(TypedDict, total=False):
      """OneOptional arguments for searching"""
      id: Union[int, 'types.IntFilter']
      many: 'ManyRequiredListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
  
  
  OneOptionalCountAggregateInput = TypedDict(
      'OneOptionalCountAggregateInput',
      {
          'id': bool,
          'int': bool,
          'optional_int': bool,
          'float': bool,
          'optional_float': bool,
          'string': bool,
          'optional_string': bool,
          'enum': bool,
          'optional_enum': bool,
          'boolean': bool,
          'optional_boolean': bool,
          '_all': bool,
      },
      total=False,
  )
  
  OneOptionalCountAggregateOutput = TypedDict(
      'OneOptionalCountAggregateOutput',
      {
          'id': int,
          'int': int,
          'optional_int': int,
          'float': int,
          'optional_float': int,
          'string': int,
          'optional_string': int,
          'enum': int,
          'optional_enum': int,
          'boolean': int,
          'optional_boolean': int,
          '_all': int,
      },
      total=False,
  )
  
  
  OneOptionalKeys = Literal[
      'id',
      'many',
      'int',
      'optional_int',
      'float',
      'optional_float',
      'string',
      'optional_string',
      'enum',
      'optional_enum',
      'boolean',
      'optional_boolean',
  ]
  
  OneOptionalRelationalFieldKeys = Literal[
          'many',
      ]
  
  # ManyRequired types
  
  class ManyRequiredOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the ManyRequired create method"""
      id: int
      one: 'OneOptionalCreateNestedWithoutRelationsInput'
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class ManyRequiredCreateInput(ManyRequiredOptionalCreateInput):
      """Required arguments to the ManyRequired create method"""
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class ManyRequiredOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the ManyRequired create method, without relations"""
      id: int
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class ManyRequiredCreateWithoutRelationsInput(ManyRequiredOptionalCreateWithoutRelationsInput):
      """Required arguments to the ManyRequired create method, without relations"""
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  class ManyRequiredCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'ManyRequiredCreateWithoutRelationsInput'
      connect: 'ManyRequiredWhereUniqueInput'
  
  
  class ManyRequiredCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['ManyRequiredCreateWithoutRelationsInput', List['ManyRequiredCreateWithoutRelationsInput']]
      connect: Union['ManyRequiredWhereUniqueInput', List['ManyRequiredWhereUniqueInput']]
  
  
  
  _ManyRequiredWhereUnique_id_Input = TypedDict(
      '_ManyRequiredWhereUnique_id_Input',
      {
          'id': 'int',
      },
      total=True
  )
  
  ManyRequiredWhereUniqueInput = _ManyRequiredWhereUnique_id_Input
  
  
  class ManyRequiredUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      one: 'OneOptionalUpdateOneWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class ManyRequiredUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: Union[AtomicIntInput, int]
      one: 'OneOptionalUpdateOneWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class ManyRequiredUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['ManyRequiredCreateWithoutRelationsInput']
      connect: List['ManyRequiredWhereUniqueInput']
      set: List['ManyRequiredWhereUniqueInput']
      disconnect: List['ManyRequiredWhereUniqueInput']
      delete: List['ManyRequiredWhereUniqueInput']
  
      # TODO
      # update: List['ManyRequiredUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['ManyRequiredUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['ManyRequiredScalarWhereInput']
      # upsert: List['ManyRequiredUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['ManyRequiredCreateOrConnectWithoutRelationsInput']
  
  
  class ManyRequiredUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'ManyRequiredCreateWithoutRelationsInput'
      connect: 'ManyRequiredWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'ManyRequiredUpdateInput'
      # upsert: 'ManyRequiredUpsertWithoutRelationsInput'
      # connectOrCreate: 'ManyRequiredCreateOrConnectWithoutRelationsInput'
  
  
  class ManyRequiredUpsertInput(TypedDict):
      create: 'ManyRequiredCreateInput'
      update: 'ManyRequiredUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class ManyRequiredOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      one_optional_id: 'SortOrder'
      int: 'SortOrder'
      optional_int: 'SortOrder'
      float: 'SortOrder'
      optional_float: 'SortOrder'
      string: 'SortOrder'
      optional_string: 'SortOrder'
      enum: 'SortOrder'
      optional_enum: 'SortOrder'
      boolean: 'SortOrder'
      optional_boolean: 'SortOrder'
  
  
  # recursive ManyRequired types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/
  
  ManyRequiredRelationFilter = TypedDict(
      'ManyRequiredRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class ManyRequiredListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class ManyRequiredInclude(TypedDict, total=False):
      """ManyRequired relational arguments"""
      one: Union[bool, 'OneOptionalArgsFromManyRequired']
  
  
      
  
  class PostIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      author: Union[bool, 'UserArgsFromManyRequiredRecursive1']
  
  
  class PostIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      author: Union[bool, 'UserArgsFromManyRequiredRecursive2']
  
  
  class PostIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class PostArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyPostArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      posts: Union[bool, 'FindManyPostArgsFromManyRequiredRecursive1']
  
  
  class UserIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      posts: Union[bool, 'FindManyPostArgsFromManyRequiredRecursive2']
  
  
  class UserIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class UserArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyUserArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      n: Union[bool, 'FindManyNArgsFromManyRequiredRecursive1']
  
  
  class MIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      n: Union[bool, 'FindManyNArgsFromManyRequiredRecursive2']
  
  
  class MIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class MArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyMArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      m: Union[bool, 'FindManyMArgsFromManyRequiredRecursive1']
  
  
  class NIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      m: Union[bool, 'FindManyMArgsFromManyRequiredRecursive2']
  
  
  class NIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class NArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyNArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      many: Union[bool, 'FindManyManyRequiredArgsFromManyRequiredRecursive1']
  
  
  class OneOptionalIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      many: Union[bool, 'FindManyManyRequiredArgsFromManyRequiredRecursive2']
  
  
  class OneOptionalIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class OneOptionalArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyOneOptionalArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      one: Union[bool, 'OneOptionalArgsFromManyRequiredRecursive1']
  
  
  class ManyRequiredIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      one: Union[bool, 'OneOptionalArgsFromManyRequiredRecursive2']
  
  
  class ManyRequiredIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class ManyRequiredArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyManyRequiredArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class ListsIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class ListsIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class ListsIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class ListsArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class ListsArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class ListsArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyListsArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class FindManyListsArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class FindManyListsArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      
      
  
  class AIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class AIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class AIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class AArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyAArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class BIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class BIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class BArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyBArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class CIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class CIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class CArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyCArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class DIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class DIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class DArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyDArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class EIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class EIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class EArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyEArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyManyRequiredArgs = FindManyManyRequiredArgsFromManyRequired
  FindFirstManyRequiredArgs = FindManyManyRequiredArgsFromManyRequired
  
  
      
  
  class ManyRequiredWhereInput(TypedDict, total=False):
      """ManyRequired arguments for searching"""
      id: Union[int, 'types.IntFilter']
      one: 'OneOptionalRelationFilter'
      one_optional_id: Union[int, 'types.IntFilter']
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['ManyRequiredWhereInputRecursive1', List['ManyRequiredWhereInputRecursive1']]
      # but this causes mypy to hang :/
      AND: List['ManyRequiredWhereInputRecursive1']
      OR: List['ManyRequiredWhereInputRecursive1']
      NOT: List['ManyRequiredWhereInputRecursive1']
  
  
  class ManyRequiredWhereInputRecursive1(TypedDict, total=False):
      """ManyRequired arguments for searching"""
      id: Union[int, 'types.IntFilter']
      one: 'OneOptionalRelationFilter'
      one_optional_id: Union[int, 'types.IntFilter']
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['ManyRequiredWhereInputRecursive2', List['ManyRequiredWhereInputRecursive2']]
      # but this causes mypy to hang :/
      AND: List['ManyRequiredWhereInputRecursive2']
      OR: List['ManyRequiredWhereInputRecursive2']
      NOT: List['ManyRequiredWhereInputRecursive2']
  
  
  class ManyRequiredWhereInputRecursive2(TypedDict, total=False):
      """ManyRequired arguments for searching"""
      id: Union[int, 'types.IntFilter']
      one: 'OneOptionalRelationFilter'
      one_optional_id: Union[int, 'types.IntFilter']
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
  
  
  ManyRequiredCountAggregateInput = TypedDict(
      'ManyRequiredCountAggregateInput',
      {
          'id': bool,
          'one_optional_id': bool,
          'int': bool,
          'optional_int': bool,
          'float': bool,
          'optional_float': bool,
          'string': bool,
          'optional_string': bool,
          'enum': bool,
          'optional_enum': bool,
          'boolean': bool,
          'optional_boolean': bool,
          '_all': bool,
      },
      total=False,
  )
  
  ManyRequiredCountAggregateOutput = TypedDict(
      'ManyRequiredCountAggregateOutput',
      {
          'id': int,
          'one_optional_id': int,
          'int': int,
          'optional_int': int,
          'float': int,
          'optional_float': int,
          'string': int,
          'optional_string': int,
          'enum': int,
          'optional_enum': int,
          'boolean': int,
          'optional_boolean': int,
          '_all': int,
      },
      total=False,
  )
  
  
  ManyRequiredKeys = Literal[
      'id',
      'one',
      'one_optional_id',
      'int',
      'optional_int',
      'float',
      'optional_float',
      'string',
      'optional_string',
      'enum',
      'optional_enum',
      'boolean',
      'optional_boolean',
  ]
  
  ManyRequiredRelationalFieldKeys = Literal[
          'one',
      ]
  
  # Lists types
  
  class ListsOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the Lists create method"""
      id: str
      strings: List[str]
      bytes: List['fields.Base64']
      dates: List[datetime.datetime]
      bools: List[bool]
      ints: List[int]
      floats: List[float]
      bigints: List[int]
      json_objects: List['fields.Json']
  
  
  class ListsCreateInput(ListsOptionalCreateInput):
      """Required arguments to the Lists create method"""
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class ListsOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the Lists create method, without relations"""
      id: str
      strings: List[str]
      bytes: List['fields.Base64']
      dates: List[datetime.datetime]
      bools: List[bool]
      ints: List[int]
      floats: List[float]
      bigints: List[int]
      json_objects: List['fields.Json']
  
  
  class ListsCreateWithoutRelationsInput(ListsOptionalCreateWithoutRelationsInput):
      """Required arguments to the Lists create method, without relations"""
  
  
  class ListsCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'ListsCreateWithoutRelationsInput'
      connect: 'ListsWhereUniqueInput'
  
  
  class ListsCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['ListsCreateWithoutRelationsInput', List['ListsCreateWithoutRelationsInput']]
      connect: Union['ListsWhereUniqueInput', List['ListsWhereUniqueInput']]
  
  
  
  _ListsWhereUnique_id_Input = TypedDict(
      '_ListsWhereUnique_id_Input',
      {
          'id': 'str',
      },
      total=True
  )
  
  ListsWhereUniqueInput = _ListsWhereUnique_id_Input
  
  
  class ListsUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      strings: 'types.StringListUpdate'
      bytes: 'types.BytesListUpdate'
      dates: 'types.DateTimeListUpdate'
      bools: 'types.BooleanListUpdate'
      ints: 'types.IntListUpdate'
      floats: 'types.FloatListUpdate'
      bigints: 'types.BigIntListUpdate'
      json_objects: 'types.JsonListUpdate'
  
  
  class ListsUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: str
      strings: 'types.StringListUpdate'
      bytes: 'types.BytesListUpdate'
      dates: 'types.DateTimeListUpdate'
      bools: 'types.BooleanListUpdate'
      ints: 'types.IntListUpdate'
      floats: 'types.FloatListUpdate'
      bigints: 'types.BigIntListUpdate'
      json_objects: 'types.JsonListUpdate'
  
  
  class ListsUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['ListsCreateWithoutRelationsInput']
      connect: List['ListsWhereUniqueInput']
      set: List['ListsWhereUniqueInput']
      disconnect: List['ListsWhereUniqueInput']
      delete: List['ListsWhereUniqueInput']
  
      # TODO
      # update: List['ListsUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['ListsUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['ListsScalarWhereInput']
      # upsert: List['ListsUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['ListsCreateOrConnectWithoutRelationsInput']
  
  
  class ListsUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'ListsCreateWithoutRelationsInput'
      connect: 'ListsWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'ListsUpdateInput'
      # upsert: 'ListsUpsertWithoutRelationsInput'
      # connectOrCreate: 'ListsCreateOrConnectWithoutRelationsInput'
  
  
  class ListsUpsertInput(TypedDict):
      create: 'ListsCreateInput'
      update: 'ListsUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class ListsOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      strings: 'SortOrder'
      bytes: 'SortOrder'
      dates: 'SortOrder'
      bools: 'SortOrder'
      ints: 'SortOrder'
      floats: 'SortOrder'
      bigints: 'SortOrder'
      json_objects: 'SortOrder'
  
  
  # recursive Lists types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/
  
  ListsRelationFilter = TypedDict(
      'ListsRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class ListsListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class ListsInclude(TypedDict, total=False):
      """Lists relational arguments"""
  
  
      
  
  class PostIncludeFromLists(TypedDict, total=False):
      """Relational arguments for Lists"""
      author: Union[bool, 'UserArgsFromListsRecursive1']
  
  
  class PostIncludeFromListsRecursive1(TypedDict, total=False):
      """Relational arguments for Lists"""
      author: Union[bool, 'UserArgsFromListsRecursive2']
  
  
  class PostIncludeFromListsRecursive2(TypedDict, total=False):
      """Relational arguments for Lists"""
  
      
  
  class PostArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      
      
  
  class FindManyPostArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromLists(TypedDict, total=False):
      """Relational arguments for Lists"""
      posts: Union[bool, 'FindManyPostArgsFromListsRecursive1']
  
  
  class UserIncludeFromListsRecursive1(TypedDict, total=False):
      """Relational arguments for Lists"""
      posts: Union[bool, 'FindManyPostArgsFromListsRecursive2']
  
  
  class UserIncludeFromListsRecursive2(TypedDict, total=False):
      """Relational arguments for Lists"""
  
      
  
  class UserArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      
      
  
  class FindManyUserArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromLists(TypedDict, total=False):
      """Relational arguments for Lists"""
      n: Union[bool, 'FindManyNArgsFromListsRecursive1']
  
  
  class MIncludeFromListsRecursive1(TypedDict, total=False):
      """Relational arguments for Lists"""
      n: Union[bool, 'FindManyNArgsFromListsRecursive2']
  
  
  class MIncludeFromListsRecursive2(TypedDict, total=False):
      """Relational arguments for Lists"""
  
      
  
  class MArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      
      
  
  class FindManyMArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromLists(TypedDict, total=False):
      """Relational arguments for Lists"""
      m: Union[bool, 'FindManyMArgsFromListsRecursive1']
  
  
  class NIncludeFromListsRecursive1(TypedDict, total=False):
      """Relational arguments for Lists"""
      m: Union[bool, 'FindManyMArgsFromListsRecursive2']
  
  
  class NIncludeFromListsRecursive2(TypedDict, total=False):
      """Relational arguments for Lists"""
  
      
  
  class NArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      
      
  
  class FindManyNArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromLists(TypedDict, total=False):
      """Relational arguments for Lists"""
      many: Union[bool, 'FindManyManyRequiredArgsFromListsRecursive1']
  
  
  class OneOptionalIncludeFromListsRecursive1(TypedDict, total=False):
      """Relational arguments for Lists"""
      many: Union[bool, 'FindManyManyRequiredArgsFromListsRecursive2']
  
  
  class OneOptionalIncludeFromListsRecursive2(TypedDict, total=False):
      """Relational arguments for Lists"""
  
      
  
  class OneOptionalArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      
      
  
  class FindManyOneOptionalArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromLists(TypedDict, total=False):
      """Relational arguments for Lists"""
      one: Union[bool, 'OneOptionalArgsFromListsRecursive1']
  
  
  class ManyRequiredIncludeFromListsRecursive1(TypedDict, total=False):
      """Relational arguments for Lists"""
      one: Union[bool, 'OneOptionalArgsFromListsRecursive2']
  
  
  class ManyRequiredIncludeFromListsRecursive2(TypedDict, total=False):
      """Relational arguments for Lists"""
  
      
  
  class ManyRequiredArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      
      
  
  class FindManyManyRequiredArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class ListsIncludeFromLists(TypedDict, total=False):
      """Relational arguments for Lists"""
  
  
  class ListsIncludeFromListsRecursive1(TypedDict, total=False):
      """Relational arguments for Lists"""
  
  
  class ListsIncludeFromListsRecursive2(TypedDict, total=False):
      """Relational arguments for Lists"""
  
      
  
  class ListsArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class ListsArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class ListsArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      
      
  
  class FindManyListsArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class FindManyListsArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class FindManyListsArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      
      
  
  class AIncludeFromLists(TypedDict, total=False):
      """Relational arguments for Lists"""
  
  
  class AIncludeFromListsRecursive1(TypedDict, total=False):
      """Relational arguments for Lists"""
  
  
  class AIncludeFromListsRecursive2(TypedDict, total=False):
      """Relational arguments for Lists"""
  
      
  
  class AArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      
      
  
  class FindManyAArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromLists(TypedDict, total=False):
      """Relational arguments for Lists"""
  
  
  class BIncludeFromListsRecursive1(TypedDict, total=False):
      """Relational arguments for Lists"""
  
  
  class BIncludeFromListsRecursive2(TypedDict, total=False):
      """Relational arguments for Lists"""
  
      
  
  class BArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      
      
  
  class FindManyBArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromLists(TypedDict, total=False):
      """Relational arguments for Lists"""
  
  
  class CIncludeFromListsRecursive1(TypedDict, total=False):
      """Relational arguments for Lists"""
  
  
  class CIncludeFromListsRecursive2(TypedDict, total=False):
      """Relational arguments for Lists"""
  
      
  
  class CArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      
      
  
  class FindManyCArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromLists(TypedDict, total=False):
      """Relational arguments for Lists"""
  
  
  class DIncludeFromListsRecursive1(TypedDict, total=False):
      """Relational arguments for Lists"""
  
  
  class DIncludeFromListsRecursive2(TypedDict, total=False):
      """Relational arguments for Lists"""
  
      
  
  class DArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      
      
  
  class FindManyDArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromLists(TypedDict, total=False):
      """Relational arguments for Lists"""
  
  
  class EIncludeFromListsRecursive1(TypedDict, total=False):
      """Relational arguments for Lists"""
  
  
  class EIncludeFromListsRecursive2(TypedDict, total=False):
      """Relational arguments for Lists"""
  
      
  
  class EArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      
      
  
  class FindManyEArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyListsArgs = FindManyListsArgsFromLists
  FindFirstListsArgs = FindManyListsArgsFromLists
  
  
      
  
  class ListsWhereInput(TypedDict, total=False):
      """Lists arguments for searching"""
      id: Union[str, 'types.StringFilter']
      strings: 'types.StringListFilter'
      bytes: 'types.BytesListFilter'
      dates: 'types.DateTimeListFilter'
      bools: 'types.BooleanListFilter'
      ints: 'types.IntListFilter'
      floats: 'types.FloatListFilter'
      bigints: 'types.BigIntListFilter'
      json_objects: 'types.JsonListFilter'
  
      # should be noted that AND and NOT should be Union['ListsWhereInputRecursive1', List['ListsWhereInputRecursive1']]
      # but this causes mypy to hang :/
      AND: List['ListsWhereInputRecursive1']
      OR: List['ListsWhereInputRecursive1']
      NOT: List['ListsWhereInputRecursive1']
  
  
  class ListsWhereInputRecursive1(TypedDict, total=False):
      """Lists arguments for searching"""
      id: Union[str, 'types.StringFilter']
      strings: 'types.StringListFilter'
      bytes: 'types.BytesListFilter'
      dates: 'types.DateTimeListFilter'
      bools: 'types.BooleanListFilter'
      ints: 'types.IntListFilter'
      floats: 'types.FloatListFilter'
      bigints: 'types.BigIntListFilter'
      json_objects: 'types.JsonListFilter'
  
      # should be noted that AND and NOT should be Union['ListsWhereInputRecursive2', List['ListsWhereInputRecursive2']]
      # but this causes mypy to hang :/
      AND: List['ListsWhereInputRecursive2']
      OR: List['ListsWhereInputRecursive2']
      NOT: List['ListsWhereInputRecursive2']
  
  
  class ListsWhereInputRecursive2(TypedDict, total=False):
      """Lists arguments for searching"""
      id: Union[str, 'types.StringFilter']
      strings: 'types.StringListFilter'
      bytes: 'types.BytesListFilter'
      dates: 'types.DateTimeListFilter'
      bools: 'types.BooleanListFilter'
      ints: 'types.IntListFilter'
      floats: 'types.FloatListFilter'
      bigints: 'types.BigIntListFilter'
      json_objects: 'types.JsonListFilter'
  
  
  
  ListsCountAggregateInput = TypedDict(
      'ListsCountAggregateInput',
      {
          'id': bool,
          'strings': bool,
          'bytes': bool,
          'dates': bool,
          'bools': bool,
          'ints': bool,
          'floats': bool,
          'bigints': bool,
          'json_objects': bool,
          '_all': bool,
      },
      total=False,
  )
  
  ListsCountAggregateOutput = TypedDict(
      'ListsCountAggregateOutput',
      {
          'id': int,
          'strings': int,
          'bytes': int,
          'dates': int,
          'bools': int,
          'ints': int,
          'floats': int,
          'bigints': int,
          'json_objects': int,
          '_all': int,
      },
      total=False,
  )
  
  
  ListsKeys = Literal[
      'id',
      'strings',
      'bytes',
      'dates',
      'bools',
      'ints',
      'floats',
      'bigints',
      'json_objects',
  ]
  
  ListsRelationalFieldKeys = _NoneType
  
  # A types
  
  class AOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the A create method"""
      name: Optional[str]
      inc_int: int
      inc_sInt: int
      inc_bInt: int
  
  
  class ACreateInput(AOptionalCreateInput):
      """Required arguments to the A create method"""
      email: str
      int: int
      sInt: int
      bInt: int
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class AOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the A create method, without relations"""
      name: Optional[str]
      inc_int: int
      inc_sInt: int
      inc_bInt: int
  
  
  class ACreateWithoutRelationsInput(AOptionalCreateWithoutRelationsInput):
      """Required arguments to the A create method, without relations"""
      email: str
      int: int
      sInt: int
      bInt: int
  
  
  class ACreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'ACreateWithoutRelationsInput'
      connect: 'AWhereUniqueInput'
  
  
  class ACreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['ACreateWithoutRelationsInput', List['ACreateWithoutRelationsInput']]
      connect: Union['AWhereUniqueInput', List['AWhereUniqueInput']]
  
  
  
  _AWhereUnique_email_Input = TypedDict(
      '_AWhereUnique_email_Input',
      {
          'email': 'str',
      },
      total=True
  )
  
  _ACompoundname_emailKeyInner = TypedDict(
      '_ACompoundname_emailKeyInner',
      {
          'name': 'str',
          'email': 'str',
      },
      total=True
  )
  
  _ACompoundname_emailKey = TypedDict(
      '_ACompoundname_emailKey',
      {
          'name_email': '_ACompoundname_emailKeyInner',
      },
      total=True
  )
  
  AWhereUniqueInput = Union[
      '_AWhereUnique_email_Input',
      '_ACompoundname_emailKey',
  ]
  
  
  class AUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      name: Optional[str]
      int: Union[AtomicIntInput, int]
      sInt: Union[AtomicIntInput, int]
      inc_int: Union[AtomicIntInput, int]
      inc_sInt: Union[AtomicIntInput, int]
      bInt: Union[AtomicBigIntInput, int]
      inc_bInt: Union[AtomicBigIntInput, int]
  
  
  class AUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      email: str
      name: Optional[str]
      int: Union[AtomicIntInput, int]
      sInt: Union[AtomicIntInput, int]
      inc_int: Union[AtomicIntInput, int]
      inc_sInt: Union[AtomicIntInput, int]
      bInt: Union[AtomicBigIntInput, int]
      inc_bInt: Union[AtomicBigIntInput, int]
  
  
  class AUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['ACreateWithoutRelationsInput']
      connect: List['AWhereUniqueInput']
      set: List['AWhereUniqueInput']
      disconnect: List['AWhereUniqueInput']
      delete: List['AWhereUniqueInput']
  
      # TODO
      # update: List['AUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['AUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['AScalarWhereInput']
      # upsert: List['AUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['ACreateOrConnectWithoutRelationsInput']
  
  
  class AUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'ACreateWithoutRelationsInput'
      connect: 'AWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'AUpdateInput'
      # upsert: 'AUpsertWithoutRelationsInput'
      # connectOrCreate: 'ACreateOrConnectWithoutRelationsInput'
  
  
  class AUpsertInput(TypedDict):
      create: 'ACreateInput'
      update: 'AUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class AOrderByInput(TypedDict, total=False):
      email: 'SortOrder'
      name: 'SortOrder'
      int: 'SortOrder'
      sInt: 'SortOrder'
      inc_int: 'SortOrder'
      inc_sInt: 'SortOrder'
      bInt: 'SortOrder'
      inc_bInt: 'SortOrder'
  
  
  # recursive A types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/
  
  ARelationFilter = TypedDict(
      'ARelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class AListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class AInclude(TypedDict, total=False):
      """A relational arguments"""
  
  
      
  
  class PostIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
      author: Union[bool, 'UserArgsFromARecursive1']
  
  
  class PostIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
      author: Union[bool, 'UserArgsFromARecursive2']
  
  
  class PostIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class PostArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyPostArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
      posts: Union[bool, 'FindManyPostArgsFromARecursive1']
  
  
  class UserIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
      posts: Union[bool, 'FindManyPostArgsFromARecursive2']
  
  
  class UserIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class UserArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyUserArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
      n: Union[bool, 'FindManyNArgsFromARecursive1']
  
  
  class MIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
      n: Union[bool, 'FindManyNArgsFromARecursive2']
  
  
  class MIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class MArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyMArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
      m: Union[bool, 'FindManyMArgsFromARecursive1']
  
  
  class NIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
      m: Union[bool, 'FindManyMArgsFromARecursive2']
  
  
  class NIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class NArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyNArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
      many: Union[bool, 'FindManyManyRequiredArgsFromARecursive1']
  
  
  class OneOptionalIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
      many: Union[bool, 'FindManyManyRequiredArgsFromARecursive2']
  
  
  class OneOptionalIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class OneOptionalArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyOneOptionalArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
      one: Union[bool, 'OneOptionalArgsFromARecursive1']
  
  
  class ManyRequiredIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
      one: Union[bool, 'OneOptionalArgsFromARecursive2']
  
  
  class ManyRequiredIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class ManyRequiredArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyManyRequiredArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class ListsIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class ListsIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class ListsIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class ListsArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class ListsArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class ListsArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyListsArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class FindManyListsArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class FindManyListsArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      
      
  
  class AIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class AIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class AIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class AArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyAArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class BIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class BIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class BArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyBArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class CIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class CIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class CArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyCArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class DIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class DIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class DArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyDArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class EIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class EIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class EArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyEArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyAArgs = FindManyAArgsFromA
  FindFirstAArgs = FindManyAArgsFromA
  
  
      
  
  class AWhereInput(TypedDict, total=False):
      """A arguments for searching"""
      email: Union[str, 'types.StringFilter']
      name: Union[str, 'types.StringFilter']
      int: Union[int, 'types.IntFilter']
      sInt: Union[int, 'types.IntFilter']
      inc_int: Union[int, 'types.IntFilter']
      inc_sInt: Union[int, 'types.IntFilter']
      bInt: Union[int, 'types.BigIntFilter']
      inc_bInt: Union[int, 'types.BigIntFilter']
  
      # should be noted that AND and NOT should be Union['AWhereInputRecursive1', List['AWhereInputRecursive1']]
      # but this causes mypy to hang :/
      AND: List['AWhereInputRecursive1']
      OR: List['AWhereInputRecursive1']
      NOT: List['AWhereInputRecursive1']
  
  
  class AWhereInputRecursive1(TypedDict, total=False):
      """A arguments for searching"""
      email: Union[str, 'types.StringFilter']
      name: Union[str, 'types.StringFilter']
      int: Union[int, 'types.IntFilter']
      sInt: Union[int, 'types.IntFilter']
      inc_int: Union[int, 'types.IntFilter']
      inc_sInt: Union[int, 'types.IntFilter']
      bInt: Union[int, 'types.BigIntFilter']
      inc_bInt: Union[int, 'types.BigIntFilter']
  
      # should be noted that AND and NOT should be Union['AWhereInputRecursive2', List['AWhereInputRecursive2']]
      # but this causes mypy to hang :/
      AND: List['AWhereInputRecursive2']
      OR: List['AWhereInputRecursive2']
      NOT: List['AWhereInputRecursive2']
  
  
  class AWhereInputRecursive2(TypedDict, total=False):
      """A arguments for searching"""
      email: Union[str, 'types.StringFilter']
      name: Union[str, 'types.StringFilter']
      int: Union[int, 'types.IntFilter']
      sInt: Union[int, 'types.IntFilter']
      inc_int: Union[int, 'types.IntFilter']
      inc_sInt: Union[int, 'types.IntFilter']
      bInt: Union[int, 'types.BigIntFilter']
      inc_bInt: Union[int, 'types.BigIntFilter']
  
  
  
  ACountAggregateInput = TypedDict(
      'ACountAggregateInput',
      {
          'email': bool,
          'name': bool,
          'int': bool,
          'sInt': bool,
          'inc_int': bool,
          'inc_sInt': bool,
          'bInt': bool,
          'inc_bInt': bool,
          '_all': bool,
      },
      total=False,
  )
  
  ACountAggregateOutput = TypedDict(
      'ACountAggregateOutput',
      {
          'email': int,
          'name': int,
          'int': int,
          'sInt': int,
          'inc_int': int,
          'inc_sInt': int,
          'bInt': int,
          'inc_bInt': int,
          '_all': int,
      },
      total=False,
  )
  
  
  AKeys = Literal[
      'email',
      'name',
      'int',
      'sInt',
      'inc_int',
      'inc_sInt',
      'bInt',
      'inc_bInt',
  ]
  
  ARelationalFieldKeys = _NoneType
  
  # B types
  
  class BOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the B create method"""
      id: str
  
  
  class BCreateInput(BOptionalCreateInput):
      """Required arguments to the B create method"""
      float: float
      d_float: float
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class BOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the B create method, without relations"""
      id: str
  
  
  class BCreateWithoutRelationsInput(BOptionalCreateWithoutRelationsInput):
      """Required arguments to the B create method, without relations"""
      float: float
      d_float: float
  
  
  class BCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'BCreateWithoutRelationsInput'
      connect: 'BWhereUniqueInput'
  
  
  class BCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['BCreateWithoutRelationsInput', List['BCreateWithoutRelationsInput']]
      connect: Union['BWhereUniqueInput', List['BWhereUniqueInput']]
  
  
  
  _BWhereUnique_id_Input = TypedDict(
      '_BWhereUnique_id_Input',
      {
          'id': 'str',
      },
      total=True
  )
  
  _BCompoundmy_constraintKeyInner = TypedDict(
      '_BCompoundmy_constraintKeyInner',
      {
          'float': 'float',
          'd_float': 'float',
      },
      total=True
  )
  
  _BCompoundmy_constraintKey = TypedDict(
      '_BCompoundmy_constraintKey',
      {
          'my_constraint': '_BCompoundmy_constraintKeyInner',
      },
      total=True
  )
  
  BWhereUniqueInput = Union[
      '_BWhereUnique_id_Input',
      '_BCompoundmy_constraintKey',
  ]
  
  
  class BUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      float: Union[AtomicFloatInput, float]
      d_float: Union[AtomicFloatInput, float]
  
  
  class BUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: str
      float: Union[AtomicFloatInput, float]
      d_float: Union[AtomicFloatInput, float]
  
  
  class BUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['BCreateWithoutRelationsInput']
      connect: List['BWhereUniqueInput']
      set: List['BWhereUniqueInput']
      disconnect: List['BWhereUniqueInput']
      delete: List['BWhereUniqueInput']
  
      # TODO
      # update: List['BUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['BUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['BScalarWhereInput']
      # upsert: List['BUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['BCreateOrConnectWithoutRelationsInput']
  
  
  class BUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'BCreateWithoutRelationsInput'
      connect: 'BWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'BUpdateInput'
      # upsert: 'BUpsertWithoutRelationsInput'
      # connectOrCreate: 'BCreateOrConnectWithoutRelationsInput'
  
  
  class BUpsertInput(TypedDict):
      create: 'BCreateInput'
      update: 'BUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class BOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      float: 'SortOrder'
      d_float: 'SortOrder'
  
  
  # recursive B types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/
  
  BRelationFilter = TypedDict(
      'BRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class BListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class BInclude(TypedDict, total=False):
      """B relational arguments"""
  
  
      
  
  class PostIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
      author: Union[bool, 'UserArgsFromBRecursive1']
  
  
  class PostIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
      author: Union[bool, 'UserArgsFromBRecursive2']
  
  
  class PostIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class PostArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyPostArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
      posts: Union[bool, 'FindManyPostArgsFromBRecursive1']
  
  
  class UserIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
      posts: Union[bool, 'FindManyPostArgsFromBRecursive2']
  
  
  class UserIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class UserArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyUserArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
      n: Union[bool, 'FindManyNArgsFromBRecursive1']
  
  
  class MIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
      n: Union[bool, 'FindManyNArgsFromBRecursive2']
  
  
  class MIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class MArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyMArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
      m: Union[bool, 'FindManyMArgsFromBRecursive1']
  
  
  class NIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
      m: Union[bool, 'FindManyMArgsFromBRecursive2']
  
  
  class NIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class NArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyNArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
      many: Union[bool, 'FindManyManyRequiredArgsFromBRecursive1']
  
  
  class OneOptionalIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
      many: Union[bool, 'FindManyManyRequiredArgsFromBRecursive2']
  
  
  class OneOptionalIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class OneOptionalArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyOneOptionalArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
      one: Union[bool, 'OneOptionalArgsFromBRecursive1']
  
  
  class ManyRequiredIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
      one: Union[bool, 'OneOptionalArgsFromBRecursive2']
  
  
  class ManyRequiredIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class ManyRequiredArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyManyRequiredArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class ListsIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class ListsIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class ListsIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class ListsArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class ListsArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class ListsArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyListsArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class FindManyListsArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class FindManyListsArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      
      
  
  class AIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class AIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class AIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class AArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyAArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class BIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class BIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class BArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyBArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class CIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class CIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class CArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyCArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class DIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class DIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class DArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyDArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class EIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class EIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class EArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyEArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyBArgs = FindManyBArgsFromB
  FindFirstBArgs = FindManyBArgsFromB
  
  
      
  
  class BWhereInput(TypedDict, total=False):
      """B arguments for searching"""
      id: Union[str, 'types.StringFilter']
      float: Union[float, 'types.FloatFilter']
      d_float: Union[float, 'types.FloatFilter']
  
      # should be noted that AND and NOT should be Union['BWhereInputRecursive1', List['BWhereInputRecursive1']]
      # but this causes mypy to hang :/
      AND: List['BWhereInputRecursive1']
      OR: List['BWhereInputRecursive1']
      NOT: List['BWhereInputRecursive1']
  
  
  class BWhereInputRecursive1(TypedDict, total=False):
      """B arguments for searching"""
      id: Union[str, 'types.StringFilter']
      float: Union[float, 'types.FloatFilter']
      d_float: Union[float, 'types.FloatFilter']
  
      # should be noted that AND and NOT should be Union['BWhereInputRecursive2', List['BWhereInputRecursive2']]
      # but this causes mypy to hang :/
      AND: List['BWhereInputRecursive2']
      OR: List['BWhereInputRecursive2']
      NOT: List['BWhereInputRecursive2']
  
  
  class BWhereInputRecursive2(TypedDict, total=False):
      """B arguments for searching"""
      id: Union[str, 'types.StringFilter']
      float: Union[float, 'types.FloatFilter']
      d_float: Union[float, 'types.FloatFilter']
  
  
  
  BCountAggregateInput = TypedDict(
      'BCountAggregateInput',
      {
          'id': bool,
          'float': bool,
          'd_float': bool,
          '_all': bool,
      },
      total=False,
  )
  
  BCountAggregateOutput = TypedDict(
      'BCountAggregateOutput',
      {
          'id': int,
          'float': int,
          'd_float': int,
          '_all': int,
      },
      total=False,
  )
  
  
  BKeys = Literal[
      'id',
      'float',
      'd_float',
  ]
  
  BRelationalFieldKeys = _NoneType
  
  # C types
  
  class COptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the C create method"""
  
  
  class CCreateInput(COptionalCreateInput):
      """Required arguments to the C create method"""
      char: str
      v_char: str
      text: str
      bit: str
      v_bit: str
      uuid: str
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class COptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the C create method, without relations"""
  
  
  class CCreateWithoutRelationsInput(COptionalCreateWithoutRelationsInput):
      """Required arguments to the C create method, without relations"""
      char: str
      v_char: str
      text: str
      bit: str
      v_bit: str
      uuid: str
  
  
  class CCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'CCreateWithoutRelationsInput'
      connect: 'CWhereUniqueInput'
  
  
  class CCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['CCreateWithoutRelationsInput', List['CCreateWithoutRelationsInput']]
      connect: Union['CWhereUniqueInput', List['CWhereUniqueInput']]
  
  
  
  _CCompoundPrimaryKeyInner = TypedDict(
      '_CCompoundPrimaryKeyInner',
      {
          'char': 'str',
          'text': 'str',
      },
      total=True
  )
  
  _CCompoundPrimaryKey = TypedDict(
      '_CCompoundPrimaryKey',
      {
          'my_id': '_CCompoundPrimaryKeyInner',
      },
      total=True
  )
  
  CWhereUniqueInput = _CCompoundPrimaryKey
  
  
  class CUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      char: str
      v_char: str
      text: str
      bit: str
      v_bit: str
      uuid: str
  
  
  class CUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      char: str
      v_char: str
      text: str
      bit: str
      v_bit: str
      uuid: str
  
  
  class CUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['CCreateWithoutRelationsInput']
      connect: List['CWhereUniqueInput']
      set: List['CWhereUniqueInput']
      disconnect: List['CWhereUniqueInput']
      delete: List['CWhereUniqueInput']
  
      # TODO
      # update: List['CUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['CUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['CScalarWhereInput']
      # upsert: List['CUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['CCreateOrConnectWithoutRelationsInput']
  
  
  class CUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'CCreateWithoutRelationsInput'
      connect: 'CWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'CUpdateInput'
      # upsert: 'CUpsertWithoutRelationsInput'
      # connectOrCreate: 'CCreateOrConnectWithoutRelationsInput'
  
  
  class CUpsertInput(TypedDict):
      create: 'CCreateInput'
      update: 'CUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class COrderByInput(TypedDict, total=False):
      char: 'SortOrder'
      v_char: 'SortOrder'
      text: 'SortOrder'
      bit: 'SortOrder'
      v_bit: 'SortOrder'
      uuid: 'SortOrder'
  
  
  # recursive C types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/
  
  CRelationFilter = TypedDict(
      'CRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class CListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class CInclude(TypedDict, total=False):
      """C relational arguments"""
  
  
      
  
  class PostIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
      author: Union[bool, 'UserArgsFromCRecursive1']
  
  
  class PostIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
      author: Union[bool, 'UserArgsFromCRecursive2']
  
  
  class PostIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class PostArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyPostArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
      posts: Union[bool, 'FindManyPostArgsFromCRecursive1']
  
  
  class UserIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
      posts: Union[bool, 'FindManyPostArgsFromCRecursive2']
  
  
  class UserIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class UserArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyUserArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
      n: Union[bool, 'FindManyNArgsFromCRecursive1']
  
  
  class MIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
      n: Union[bool, 'FindManyNArgsFromCRecursive2']
  
  
  class MIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class MArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyMArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
      m: Union[bool, 'FindManyMArgsFromCRecursive1']
  
  
  class NIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
      m: Union[bool, 'FindManyMArgsFromCRecursive2']
  
  
  class NIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class NArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyNArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
      many: Union[bool, 'FindManyManyRequiredArgsFromCRecursive1']
  
  
  class OneOptionalIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
      many: Union[bool, 'FindManyManyRequiredArgsFromCRecursive2']
  
  
  class OneOptionalIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class OneOptionalArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyOneOptionalArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
      one: Union[bool, 'OneOptionalArgsFromCRecursive1']
  
  
  class ManyRequiredIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
      one: Union[bool, 'OneOptionalArgsFromCRecursive2']
  
  
  class ManyRequiredIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class ManyRequiredArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyManyRequiredArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class ListsIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class ListsIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class ListsIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class ListsArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class ListsArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class ListsArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyListsArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class FindManyListsArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class FindManyListsArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      
      
  
  class AIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class AIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class AIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class AArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyAArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class BIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class BIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class BArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyBArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class CIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class CIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class CArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyCArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class DIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class DIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class DArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyDArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class EIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class EIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class EArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyEArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyCArgs = FindManyCArgsFromC
  FindFirstCArgs = FindManyCArgsFromC
  
  
      
  
  class CWhereInput(TypedDict, total=False):
      """C arguments for searching"""
      char: Union[str, 'types.StringFilter']
      v_char: Union[str, 'types.StringFilter']
      text: Union[str, 'types.StringFilter']
      bit: Union[str, 'types.StringFilter']
      v_bit: Union[str, 'types.StringFilter']
      uuid: Union[str, 'types.StringFilter']
  
      # should be noted that AND and NOT should be Union['CWhereInputRecursive1', List['CWhereInputRecursive1']]
      # but this causes mypy to hang :/
      AND: List['CWhereInputRecursive1']
      OR: List['CWhereInputRecursive1']
      NOT: List['CWhereInputRecursive1']
  
  
  class CWhereInputRecursive1(TypedDict, total=False):
      """C arguments for searching"""
      char: Union[str, 'types.StringFilter']
      v_char: Union[str, 'types.StringFilter']
      text: Union[str, 'types.StringFilter']
      bit: Union[str, 'types.StringFilter']
      v_bit: Union[str, 'types.StringFilter']
      uuid: Union[str, 'types.StringFilter']
  
      # should be noted that AND and NOT should be Union['CWhereInputRecursive2', List['CWhereInputRecursive2']]
      # but this causes mypy to hang :/
      AND: List['CWhereInputRecursive2']
      OR: List['CWhereInputRecursive2']
      NOT: List['CWhereInputRecursive2']
  
  
  class CWhereInputRecursive2(TypedDict, total=False):
      """C arguments for searching"""
      char: Union[str, 'types.StringFilter']
      v_char: Union[str, 'types.StringFilter']
      text: Union[str, 'types.StringFilter']
      bit: Union[str, 'types.StringFilter']
      v_bit: Union[str, 'types.StringFilter']
      uuid: Union[str, 'types.StringFilter']
  
  
  
  CCountAggregateInput = TypedDict(
      'CCountAggregateInput',
      {
          'char': bool,
          'v_char': bool,
          'text': bool,
          'bit': bool,
          'v_bit': bool,
          'uuid': bool,
          '_all': bool,
      },
      total=False,
  )
  
  CCountAggregateOutput = TypedDict(
      'CCountAggregateOutput',
      {
          'char': int,
          'v_char': int,
          'text': int,
          'bit': int,
          'v_bit': int,
          'uuid': int,
          '_all': int,
      },
      total=False,
  )
  
  
  CKeys = Literal[
      'char',
      'v_char',
      'text',
      'bit',
      'v_bit',
      'uuid',
  ]
  
  CRelationalFieldKeys = _NoneType
  
  # D types
  
  class DOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the D create method"""
      id: str
  
  
  class DCreateInput(DOptionalCreateInput):
      """Required arguments to the D create method"""
      bool: bool
      xml: str
      json_: 'fields.Json'
      jsonb: 'fields.Json'
      binary: 'fields.Base64'
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class DOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the D create method, without relations"""
      id: str
  
  
  class DCreateWithoutRelationsInput(DOptionalCreateWithoutRelationsInput):
      """Required arguments to the D create method, without relations"""
      bool: bool
      xml: str
      json_: 'fields.Json'
      jsonb: 'fields.Json'
      binary: 'fields.Base64'
  
  
  class DCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'DCreateWithoutRelationsInput'
      connect: 'DWhereUniqueInput'
  
  
  class DCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['DCreateWithoutRelationsInput', List['DCreateWithoutRelationsInput']]
      connect: Union['DWhereUniqueInput', List['DWhereUniqueInput']]
  
  
  
  _DWhereUnique_id_Input = TypedDict(
      '_DWhereUnique_id_Input',
      {
          'id': 'str',
      },
      total=True
  )
  
  DWhereUniqueInput = _DWhereUnique_id_Input
  
  
  class DUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      bool: bool
      xml: str
      json_: 'fields.Json'
      jsonb: 'fields.Json'
      binary: 'fields.Base64'
  
  
  class DUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: str
      bool: bool
      xml: str
      json_: 'fields.Json'
      jsonb: 'fields.Json'
      binary: 'fields.Base64'
  
  
  class DUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['DCreateWithoutRelationsInput']
      connect: List['DWhereUniqueInput']
      set: List['DWhereUniqueInput']
      disconnect: List['DWhereUniqueInput']
      delete: List['DWhereUniqueInput']
  
      # TODO
      # update: List['DUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['DUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['DScalarWhereInput']
      # upsert: List['DUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['DCreateOrConnectWithoutRelationsInput']
  
  
  class DUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'DCreateWithoutRelationsInput'
      connect: 'DWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'DUpdateInput'
      # upsert: 'DUpsertWithoutRelationsInput'
      # connectOrCreate: 'DCreateOrConnectWithoutRelationsInput'
  
  
  class DUpsertInput(TypedDict):
      create: 'DCreateInput'
      update: 'DUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class DOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      bool: 'SortOrder'
      xml: 'SortOrder'
      json_: 'SortOrder'
      jsonb: 'SortOrder'
      binary: 'SortOrder'
  
  
  # recursive D types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/
  
  DRelationFilter = TypedDict(
      'DRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class DListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class DInclude(TypedDict, total=False):
      """D relational arguments"""
  
  
      
  
  class PostIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
      author: Union[bool, 'UserArgsFromDRecursive1']
  
  
  class PostIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
      author: Union[bool, 'UserArgsFromDRecursive2']
  
  
  class PostIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class PostArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyPostArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
      posts: Union[bool, 'FindManyPostArgsFromDRecursive1']
  
  
  class UserIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
      posts: Union[bool, 'FindManyPostArgsFromDRecursive2']
  
  
  class UserIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class UserArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyUserArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
      n: Union[bool, 'FindManyNArgsFromDRecursive1']
  
  
  class MIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
      n: Union[bool, 'FindManyNArgsFromDRecursive2']
  
  
  class MIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class MArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyMArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
      m: Union[bool, 'FindManyMArgsFromDRecursive1']
  
  
  class NIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
      m: Union[bool, 'FindManyMArgsFromDRecursive2']
  
  
  class NIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class NArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyNArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
      many: Union[bool, 'FindManyManyRequiredArgsFromDRecursive1']
  
  
  class OneOptionalIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
      many: Union[bool, 'FindManyManyRequiredArgsFromDRecursive2']
  
  
  class OneOptionalIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class OneOptionalArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyOneOptionalArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
      one: Union[bool, 'OneOptionalArgsFromDRecursive1']
  
  
  class ManyRequiredIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
      one: Union[bool, 'OneOptionalArgsFromDRecursive2']
  
  
  class ManyRequiredIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class ManyRequiredArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyManyRequiredArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class ListsIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class ListsIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class ListsIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class ListsArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class ListsArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class ListsArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyListsArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class FindManyListsArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class FindManyListsArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      
      
  
  class AIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class AIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class AIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class AArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyAArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class BIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class BIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class BArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyBArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class CIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class CIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class CArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyCArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class DIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class DIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class DArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyDArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class EIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class EIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class EArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyEArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyDArgs = FindManyDArgsFromD
  FindFirstDArgs = FindManyDArgsFromD
  
  
      
  
  class DWhereInput(TypedDict, total=False):
      """D arguments for searching"""
      id: Union[str, 'types.StringFilter']
      bool: Union[bool, 'types.BooleanFilter']
      xml: Union[str, 'types.StringFilter']
      json_: Union['fields.Json', 'types.JsonFilter']
      jsonb: Union['fields.Json', 'types.JsonFilter']
      binary: Union['fields.Base64', 'types.BytesFilter']
  
      # should be noted that AND and NOT should be Union['DWhereInputRecursive1', List['DWhereInputRecursive1']]
      # but this causes mypy to hang :/
      AND: List['DWhereInputRecursive1']
      OR: List['DWhereInputRecursive1']
      NOT: List['DWhereInputRecursive1']
  
  
  class DWhereInputRecursive1(TypedDict, total=False):
      """D arguments for searching"""
      id: Union[str, 'types.StringFilter']
      bool: Union[bool, 'types.BooleanFilter']
      xml: Union[str, 'types.StringFilter']
      json_: Union['fields.Json', 'types.JsonFilter']
      jsonb: Union['fields.Json', 'types.JsonFilter']
      binary: Union['fields.Base64', 'types.BytesFilter']
  
      # should be noted that AND and NOT should be Union['DWhereInputRecursive2', List['DWhereInputRecursive2']]
      # but this causes mypy to hang :/
      AND: List['DWhereInputRecursive2']
      OR: List['DWhereInputRecursive2']
      NOT: List['DWhereInputRecursive2']
  
  
  class DWhereInputRecursive2(TypedDict, total=False):
      """D arguments for searching"""
      id: Union[str, 'types.StringFilter']
      bool: Union[bool, 'types.BooleanFilter']
      xml: Union[str, 'types.StringFilter']
      json_: Union['fields.Json', 'types.JsonFilter']
      jsonb: Union['fields.Json', 'types.JsonFilter']
      binary: Union['fields.Base64', 'types.BytesFilter']
  
  
  
  DCountAggregateInput = TypedDict(
      'DCountAggregateInput',
      {
          'id': bool,
          'bool': bool,
          'xml': bool,
          'json_': bool,
          'jsonb': bool,
          'binary': bool,
          '_all': bool,
      },
      total=False,
  )
  
  DCountAggregateOutput = TypedDict(
      'DCountAggregateOutput',
      {
          'id': int,
          'bool': int,
          'xml': int,
          'json_': int,
          'jsonb': int,
          'binary': int,
          '_all': int,
      },
      total=False,
  )
  
  
  DKeys = Literal[
      'id',
      'bool',
      'xml',
      'json_',
      'jsonb',
      'binary',
  ]
  
  DRelationalFieldKeys = _NoneType
  
  # E types
  
  class EOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the E create method"""
      id: str
  
  
  class ECreateInput(EOptionalCreateInput):
      """Required arguments to the E create method"""
      date: datetime.datetime
      time: datetime.datetime
      ts: datetime.datetime
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class EOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the E create method, without relations"""
      id: str
  
  
  class ECreateWithoutRelationsInput(EOptionalCreateWithoutRelationsInput):
      """Required arguments to the E create method, without relations"""
      date: datetime.datetime
      time: datetime.datetime
      ts: datetime.datetime
  
  
  class ECreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'ECreateWithoutRelationsInput'
      connect: 'EWhereUniqueInput'
  
  
  class ECreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['ECreateWithoutRelationsInput', List['ECreateWithoutRelationsInput']]
      connect: Union['EWhereUniqueInput', List['EWhereUniqueInput']]
  
  
  
  _EWhereUnique_id_Input = TypedDict(
      '_EWhereUnique_id_Input',
      {
          'id': 'str',
      },
      total=True
  )
  
  EWhereUniqueInput = _EWhereUnique_id_Input
  
  
  class EUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      date: datetime.datetime
      time: datetime.datetime
      ts: datetime.datetime
  
  
  class EUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: str
      date: datetime.datetime
      time: datetime.datetime
      ts: datetime.datetime
  
  
  class EUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['ECreateWithoutRelationsInput']
      connect: List['EWhereUniqueInput']
      set: List['EWhereUniqueInput']
      disconnect: List['EWhereUniqueInput']
      delete: List['EWhereUniqueInput']
  
      # TODO
      # update: List['EUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['EUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['EScalarWhereInput']
      # upsert: List['EUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['ECreateOrConnectWithoutRelationsInput']
  
  
  class EUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'ECreateWithoutRelationsInput'
      connect: 'EWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'EUpdateInput'
      # upsert: 'EUpsertWithoutRelationsInput'
      # connectOrCreate: 'ECreateOrConnectWithoutRelationsInput'
  
  
  class EUpsertInput(TypedDict):
      create: 'ECreateInput'
      update: 'EUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class EOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      date: 'SortOrder'
      time: 'SortOrder'
      ts: 'SortOrder'
  
  
  # recursive E types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/
  
  ERelationFilter = TypedDict(
      'ERelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class EListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class EInclude(TypedDict, total=False):
      """E relational arguments"""
  
  
      
  
  class PostIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
      author: Union[bool, 'UserArgsFromERecursive1']
  
  
  class PostIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
      author: Union[bool, 'UserArgsFromERecursive2']
  
  
  class PostIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class PostArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyPostArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
      posts: Union[bool, 'FindManyPostArgsFromERecursive1']
  
  
  class UserIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
      posts: Union[bool, 'FindManyPostArgsFromERecursive2']
  
  
  class UserIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class UserArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyUserArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
      n: Union[bool, 'FindManyNArgsFromERecursive1']
  
  
  class MIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
      n: Union[bool, 'FindManyNArgsFromERecursive2']
  
  
  class MIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class MArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyMArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
      m: Union[bool, 'FindManyMArgsFromERecursive1']
  
  
  class NIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
      m: Union[bool, 'FindManyMArgsFromERecursive2']
  
  
  class NIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class NArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyNArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
      many: Union[bool, 'FindManyManyRequiredArgsFromERecursive1']
  
  
  class OneOptionalIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
      many: Union[bool, 'FindManyManyRequiredArgsFromERecursive2']
  
  
  class OneOptionalIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class OneOptionalArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyOneOptionalArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
      one: Union[bool, 'OneOptionalArgsFromERecursive1']
  
  
  class ManyRequiredIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
      one: Union[bool, 'OneOptionalArgsFromERecursive2']
  
  
  class ManyRequiredIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class ManyRequiredArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyManyRequiredArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class ListsIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class ListsIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class ListsIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class ListsArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class ListsArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class ListsArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyListsArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class FindManyListsArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class FindManyListsArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      
      
  
  class AIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class AIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class AIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class AArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyAArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class BIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class BIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class BArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyBArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class CIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class CIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class CArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyCArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class DIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class DIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class DArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyDArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class EIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class EIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class EArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyEArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyEArgs = FindManyEArgsFromE
  FindFirstEArgs = FindManyEArgsFromE
  
  
      
  
  class EWhereInput(TypedDict, total=False):
      """E arguments for searching"""
      id: Union[str, 'types.StringFilter']
      date: Union[datetime.datetime, 'types.DateTimeFilter']
      time: Union[datetime.datetime, 'types.DateTimeFilter']
      ts: Union[datetime.datetime, 'types.DateTimeFilter']
  
      # should be noted that AND and NOT should be Union['EWhereInputRecursive1', List['EWhereInputRecursive1']]
      # but this causes mypy to hang :/
      AND: List['EWhereInputRecursive1']
      OR: List['EWhereInputRecursive1']
      NOT: List['EWhereInputRecursive1']
  
  
  class EWhereInputRecursive1(TypedDict, total=False):
      """E arguments for searching"""
      id: Union[str, 'types.StringFilter']
      date: Union[datetime.datetime, 'types.DateTimeFilter']
      time: Union[datetime.datetime, 'types.DateTimeFilter']
      ts: Union[datetime.datetime, 'types.DateTimeFilter']
  
      # should be noted that AND and NOT should be Union['EWhereInputRecursive2', List['EWhereInputRecursive2']]
      # but this causes mypy to hang :/
      AND: List['EWhereInputRecursive2']
      OR: List['EWhereInputRecursive2']
      NOT: List['EWhereInputRecursive2']
  
  
  class EWhereInputRecursive2(TypedDict, total=False):
      """E arguments for searching"""
      id: Union[str, 'types.StringFilter']
      date: Union[datetime.datetime, 'types.DateTimeFilter']
      time: Union[datetime.datetime, 'types.DateTimeFilter']
      ts: Union[datetime.datetime, 'types.DateTimeFilter']
  
  
  
  ECountAggregateInput = TypedDict(
      'ECountAggregateInput',
      {
          'id': bool,
          'date': bool,
          'time': bool,
          'ts': bool,
          '_all': bool,
      },
      total=False,
  )
  
  ECountAggregateOutput = TypedDict(
      'ECountAggregateOutput',
      {
          'id': int,
          'date': int,
          'time': int,
          'ts': int,
          '_all': int,
      },
      total=False,
  )
  
  
  EKeys = Literal[
      'id',
      'date',
      'time',
      'ts',
  ]
  
  ERelationalFieldKeys = _NoneType
  
  
  
  # we have to import ourselves as types can be namespaced to types
  from . import types, enums, models, fields
  '
---
# name: test_sync[actions.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Callable,
      Generic,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  from typing_extensions import TypedDict, Literal
  
  # -- template actions.py.jinja --
  import warnings
  
  from . import types, errors
  from ._types import BaseModelT
  
  
  if TYPE_CHECKING:
      from .client import Client
  
  
  class PostActions:
      def __init__(self, client: 'Client', model: Type['models.Post']) -> None:
          self._client = client
          self._model = model
  
      def query_raw(
          self,
          query: str,
          *args: Any,
      ) -> List['models.Post']:
          """Execute a raw SQL query
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          List[prisma.models.Post]
              The records returned by the SQL query
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          users = Post.prisma().query_raw(
              'SELECT * FROM Post WHERE id = $1',
              1103527590,
          )
          ```
          """
          return self._client.query_raw(query, *args, model=self._model)
  
      def query_first(
          self,
          query: str,
          *args: Any,
      ) -> Optional['models.Post']:
          """Execute a raw SQL query, returning the first result
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          prisma.models.Post
              The first record returned by the SQL query
          None
              The raw SQL query did not return any records
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          user = Post.prisma().query_first(
              'SELECT * FROM Post WHERE created_at = $1',
              datetime.datetime.utcnow(),
          )
          ```
          """
          return self._client.query_first(query, *args, model=self._model)
  
      def create(
          self,
          data: types.PostCreateInput,
          include: Optional[types.PostInclude] = None
      ) -> 'models.Post':
          """Create a new Post record.
  
          Parameters
          ----------
          data
              Post record data
          include
              Specifies which relations should be loaded on the returned Post model
  
          Returns
          -------
          prisma.models.Post
              The created Post record
  
          Raises
          ------
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # create a Post record from just the required fields
          post = Post.prisma().create(
              data={
                  # data to create a Post record
                  'title': 'dhheabfhf',
                  'author_id': 662824084,
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='createOne',
              model='Post',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      def create_many(
          self,
          data: List[types.PostCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          """Create multiple Post records at once.
  
          This function is *not* available when using SQLite.
  
          Parameters
          ----------
          data
              List of Post record data
          skip_duplicates
              Boolean flag for ignoring unique constraint errors
  
          Returns
          -------
          int
              The total number of records created
  
          Raises
          ------
          prisma.errors.UnsupportedDatabaseError
              Attempting to query when using SQLite
          prisma.errors.UniqueViolationError
              A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          total = Post.prisma().create_many(
              data=[
                  {
                      # data to create a Post record
                      'title': 'bbehjachib',
                      'author_id': 2035015474,
                  },
                  {
                      # data to create a Post record
                      'title': 'dgiiaaijj',
                      'author_id': 1508029952,
                  },
              ],
              skip_duplicates=True,
          )
          ```
          """
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = self._client._execute(
              operation='mutation',
              method='createMany',
              model='Post',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def delete(
          self,
          where: types.PostWhereUniqueInput,
          include: Optional[types.PostInclude] = None
      ) -> Optional['models.Post']:
          """Delete a single Post record.
  
          Parameters
          ----------
          where
              Post filter to select the record to be deleted, must be unique
          include
              Specifies which relations should be loaded on the returned Post model
  
          Returns
          -------
          prisma.models.Post
              The deleted Post record
          None
              Could not find a record to delete
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          post = Post.prisma().delete(
              where={
                  'id': 486256185,
              },
          )
          ```
          """
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='Post',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      def find_unique(
          self,
          where: types.PostWhereUniqueInput,
          include: Optional[types.PostInclude] = None
      ) -> Optional['models.Post']:
          """Find a unique Post record.
  
          Parameters
          ----------
          where
              Post filter to find the record, must be unique
          include
              Specifies which relations should be loaded on the returned Post model
  
          Returns
          -------
          prisma.models.Post
              The found Post record
          None
              No record matching the given input could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          post = Post.prisma().find_unique(
              where={
                  'id': 1062517886,
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findUnique',
              model='Post',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.PostWhereInput] = None,
          cursor: Optional[types.PostWhereUniqueInput] = None,
          include: Optional[types.PostInclude] = None,
          order: Optional[Union[types.PostOrderByInput, List[types.PostOrderByInput]]] = None,
      ) -> List['models.Post']:
          """Find multiple Post records.
  
          An empty list is returned if no records could be found.
  
          Parameters
          ----------
          take
              Limit the maximum number of Post records returned
          skip
              Ignore the first N results
          where
              Post filter to select records
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned Post model
          order
              Order the returned Post records by any field
  
          Returns
          -------
          List[prisma.models.Post]
              The list of all Post records that could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the first 10 Post records
          posts = Post.prisma().find_many(take=10)
  
          # find the first 5 Post records ordered by the title field
          posts = Post.prisma().find_many(
              take=5,
              order={
                  'title': 'desc',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findMany',
              model='Post',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [self._model.parse_obj(r) for r in resp['data']['result']]
  
      def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.PostWhereInput] = None,
          cursor: Optional[types.PostWhereUniqueInput] = None,
          include: Optional[types.PostInclude] = None,
          order: Optional[Union[types.PostOrderByInput, List[types.PostOrderByInput]]] = None,
      ) -> Optional['models.Post']:
          """Find a single Post record.
  
          Parameters
          ----------
          skip
              Ignore the first N records
          where
              Post filter to select the record
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned Post model
          order
              Order the returned Post records by any field
  
          Returns
          -------
          prisma.models.Post
              The first Post record found, matching the given arguments
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the second Post record ordered by the content field
          post = Post.prisma().find_first(
              skip=1,
              order={
                  'content': 'desc',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findFirst',
              model='Post',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      def update(
          self,
          data: types.PostUpdateInput,
          where: types.PostWhereUniqueInput,
          include: Optional[types.PostInclude] = None
      ) -> Optional['models.Post']:
          """Update a single Post record.
  
          Parameters
          ----------
          data
              Post record data specifying what to update
          where
              Post filter to select the unique record to create / update
          include
              Specifies which relations should be loaded on the returned Post model
  
          Returns
          -------
          prisma.models.Post
              The updated Post record
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          post = Post.prisma().update(
              where={
                  'id': 267834847,
              },
              data={
                  # data to update the Post record to
              },
          )
          ```
          """
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='Post',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      def upsert(
          self,
          where: types.PostWhereUniqueInput,
          data: types.PostUpsertInput,
          include: Optional[types.PostInclude] = None,
      ) -> 'models.Post':
          """Updates an existing record or create a new one
  
          Parameters
          ----------
          where
              Post filter to select the unique record to create / update
          data
              Data specifying what fields to set on create and update
          include
              Specifies which relations should be loaded on the returned Post model
  
          Returns
          -------
          prisma.models.Post
              The created or updated Post record
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          post = Post.prisma().upsert(
              where={
                  'id': 180171308,
              },
              data={
                  'create': {
                      'id': 180171308,
                      'title': 'dgiiaaijj',
                      'author_id': 1508029952,
                  },
                  'update': {
                      'title': 'dgiiaaijj',
                      'author_id': 1508029952,
                  },
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='Post',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      def update_many(
          self,
          data: types.PostUpdateManyMutationInput,
          where: types.PostWhereInput,
      ) -> int:
          """Update multiple Post records
  
          Parameters
          ----------
          data
              Post data to update the selected Post records to
          where
              Filter to select the Post records to update
  
          Returns
          -------
          int
              The total number of Post records that were updated
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # update all Post records
          total = Post.prisma().update_many(
              data={
                  'published': False
              },
              where={}
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='updateMany',
              model='Post',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      @overload
      def count(
          self,
          select: None = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.PostWhereInput] = None,
          cursor: Optional[types.PostWhereUniqueInput] = None,
          order: Optional[Union[types.PostOrderByInput, List[types.PostOrderByInput]]] = None,
      ) -> int:
          """Count the number of Post records present in the database
  
          Parameters
          ----------
          select
              Select the Post fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              Post filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.PostCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = Post.prisma().count()
  
          # results: prisma.types.PostCountAggregateOutput
          results = Post.prisma().count(
              select={
                  '_all': True,
                  'author_id': True,
              },
          )
          ```
          """
  
  
      @overload
      def count(
          self,
          select: types.PostCountAggregateInput,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.PostWhereInput] = None,
          cursor: Optional[types.PostWhereUniqueInput] = None,
          order: Optional[Union[types.PostOrderByInput, List[types.PostOrderByInput]]] = None,
      ) -> types.PostCountAggregateOutput:
          ...
  
      def count(
          self,
          select: Optional[types.PostCountAggregateInput] = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.PostWhereInput] = None,
          cursor: Optional[types.PostWhereUniqueInput] = None,
          order: Optional[Union[types.PostOrderByInput, List[types.PostOrderByInput]]] = None,
      ) -> Union[int, types.PostCountAggregateOutput]:
          """Count the number of Post records present in the database
  
          Parameters
          ----------
          select
              Select the Post fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              Post filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.PostCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = Post.prisma().count()
  
          # results: prisma.types.PostCountAggregateOutput
          results = Post.prisma().count(
              select={
                  '_all': True,
                  'id': True,
              },
          )
          ```
          """
  
          # TODO: this selection building should be moved to the QueryBuilder
          #
          # note the distinction between checking for `not select` here and `select is None`
          # later is to handle the case that the given select dictionary is empty, this
          # is a limitation of our types.
          if not select:
              root_selection = ['_count { _all }']
          else:
  
              root_selection = [
                  '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
              ]
  
          if order is not None:
              warnings.warn(
                  'The `order` argument is redundant and will be removed in the next release',
                  DeprecationWarning,
                  stacklevel=2,
              )
  
          resp = self._client._execute(
              operation='query',
              method='aggregate',
              model='Post',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=root_selection,
          )
  
          if select is None:
              return cast(int, resp['data']['result']['_count']['_all'])
          else:
              return cast(types.PostCountAggregateOutput, resp['data']['result']['_count'])
  
      def delete_many(
          self,
          where: Optional[types.PostWhereInput] = None
      ) -> int:
          """Delete multiple Post records.
  
          Parameters
          ----------
          where
              Optional Post filter to find the records to be deleted
  
          Returns
          -------
          int
              The total number of Post records that were deleted
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # delete all Post records
          total = Post.prisma().delete_many()
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='Post',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  class UserActions:
      def __init__(self, client: 'Client', model: Type['models.User']) -> None:
          self._client = client
          self._model = model
  
      def query_raw(
          self,
          query: str,
          *args: Any,
      ) -> List['models.User']:
          """Execute a raw SQL query
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          List[prisma.models.User]
              The records returned by the SQL query
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          users = User.prisma().query_raw(
              'SELECT * FROM User WHERE id = $1',
              595337866,
          )
          ```
          """
          return self._client.query_raw(query, *args, model=self._model)
  
      def query_first(
          self,
          query: str,
          *args: Any,
      ) -> Optional['models.User']:
          """Execute a raw SQL query, returning the first result
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          prisma.models.User
              The first record returned by the SQL query
          None
              The raw SQL query did not return any records
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          user = User.prisma().query_first(
              'SELECT * FROM User WHERE email = $1',
              'hjaecfifb',
          )
          ```
          """
          return self._client.query_first(query, *args, model=self._model)
  
      def create(
          self,
          data: types.UserCreateInput,
          include: Optional[types.UserInclude] = None
      ) -> 'models.User':
          """Create a new User record.
  
          Parameters
          ----------
          data
              User record data
          include
              Specifies which relations should be loaded on the returned User model
  
          Returns
          -------
          prisma.models.User
              The created User record
  
          Raises
          ------
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # create a User record from just the required fields
          user = User.prisma().create(
              data={
                  # data to create a User record
                  'email': 'cbbbjbfcii',
                  'int': 1149758321,
                  'float': 1644289366.138829,
                  'string': 'bgehebiafc',
                  'enum': enums.ABeautifulEnum.A,
                  'boolean': False,
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='createOne',
              model='User',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      def create_many(
          self,
          data: List[types.UserCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          """Create multiple User records at once.
  
          This function is *not* available when using SQLite.
  
          Parameters
          ----------
          data
              List of User record data
          skip_duplicates
              Boolean flag for ignoring unique constraint errors
  
          Returns
          -------
          int
              The total number of records created
  
          Raises
          ------
          prisma.errors.UnsupportedDatabaseError
              Attempting to query when using SQLite
          prisma.errors.UniqueViolationError
              A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          total = User.prisma().create_many(
              data=[
                  {
                      # data to create a User record
                      'email': 'bhghchehcc',
                      'int': 326272115,
                      'float': 1343201072.67578,
                      'string': 'heejgedji',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': False,
                  },
                  {
                      # data to create a User record
                      'email': 'bbbgbhfjge',
                      'int': 861472101,
                      'float': 1303003706.168663,
                      'string': 'caaaedabfc',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': False,
                  },
              ],
              skip_duplicates=True,
          )
          ```
          """
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = self._client._execute(
              operation='mutation',
              method='createMany',
              model='User',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def delete(
          self,
          where: types.UserWhereUniqueInput,
          include: Optional[types.UserInclude] = None
      ) -> Optional['models.User']:
          """Delete a single User record.
  
          Parameters
          ----------
          where
              User filter to select the record to be deleted, must be unique
          include
              Specifies which relations should be loaded on the returned User model
  
          Returns
          -------
          prisma.models.User
              The deleted User record
          None
              Could not find a record to delete
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          user = User.prisma().delete(
              where={
                  'id': 1860847622,
              },
          )
          ```
          """
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='User',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      def find_unique(
          self,
          where: types.UserWhereUniqueInput,
          include: Optional[types.UserInclude] = None
      ) -> Optional['models.User']:
          """Find a unique User record.
  
          Parameters
          ----------
          where
              User filter to find the record, must be unique
          include
              Specifies which relations should be loaded on the returned User model
  
          Returns
          -------
          prisma.models.User
              The found User record
          None
              No record matching the given input could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          user = User.prisma().find_unique(
              where={
                  'id': 1448521415,
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findUnique',
              model='User',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.UserWhereInput] = None,
          cursor: Optional[types.UserWhereUniqueInput] = None,
          include: Optional[types.UserInclude] = None,
          order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
      ) -> List['models.User']:
          """Find multiple User records.
  
          An empty list is returned if no records could be found.
  
          Parameters
          ----------
          take
              Limit the maximum number of User records returned
          skip
              Ignore the first N results
          where
              User filter to select records
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned User model
          order
              Order the returned User records by any field
  
          Returns
          -------
          List[prisma.models.User]
              The list of all User records that could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the first 10 User records
          users = User.prisma().find_many(take=10)
  
          # find the first 5 User records ordered by the int field
          users = User.prisma().find_many(
              take=5,
              order={
                  'int': 'desc',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findMany',
              model='User',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [self._model.parse_obj(r) for r in resp['data']['result']]
  
      def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.UserWhereInput] = None,
          cursor: Optional[types.UserWhereUniqueInput] = None,
          include: Optional[types.UserInclude] = None,
          order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
      ) -> Optional['models.User']:
          """Find a single User record.
  
          Parameters
          ----------
          skip
              Ignore the first N records
          where
              User filter to select the record
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned User model
          order
              Order the returned User records by any field
  
          Returns
          -------
          prisma.models.User
              The first User record found, matching the given arguments
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the second User record ordered by the optional_int field
          user = User.prisma().find_first(
              skip=1,
              order={
                  'optional_int': 'desc',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findFirst',
              model='User',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      def update(
          self,
          data: types.UserUpdateInput,
          where: types.UserWhereUniqueInput,
          include: Optional[types.UserInclude] = None
      ) -> Optional['models.User']:
          """Update a single User record.
  
          Parameters
          ----------
          data
              User record data specifying what to update
          where
              User filter to select the unique record to create / update
          include
              Specifies which relations should be loaded on the returned User model
  
          Returns
          -------
          prisma.models.User
              The updated User record
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          user = User.prisma().update(
              where={
                  'id': 1628650740,
              },
              data={
                  # data to update the User record to
              },
          )
          ```
          """
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='User',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      def upsert(
          self,
          where: types.UserWhereUniqueInput,
          data: types.UserUpsertInput,
          include: Optional[types.UserInclude] = None,
      ) -> 'models.User':
          """Updates an existing record or create a new one
  
          Parameters
          ----------
          where
              User filter to select the unique record to create / update
          data
              Data specifying what fields to set on create and update
          include
              Specifies which relations should be loaded on the returned User model
  
          Returns
          -------
          prisma.models.User
              The created or updated User record
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          user = User.prisma().upsert(
              where={
                  'id': 1249606685,
              },
              data={
                  'create': {
                      'id': 1249606685,
                      'email': 'bbbgbhfjge',
                      'int': 861472101,
                      'float': 1303003706.168663,
                      'string': 'caaaedabfc',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': False,
                  },
                  'update': {
                      'email': 'bbbgbhfjge',
                      'int': 861472101,
                      'float': 1303003706.168663,
                      'string': 'caaaedabfc',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': False,
                  },
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='User',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      def update_many(
          self,
          data: types.UserUpdateManyMutationInput,
          where: types.UserWhereInput,
      ) -> int:
          """Update multiple User records
  
          Parameters
          ----------
          data
              User data to update the selected User records to
          where
              Filter to select the User records to update
  
          Returns
          -------
          int
              The total number of User records that were updated
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # update all User records
          total = User.prisma().update_many(
              data={
                  'float': 835903122.76371
              },
              where={}
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='updateMany',
              model='User',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      @overload
      def count(
          self,
          select: None = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.UserWhereInput] = None,
          cursor: Optional[types.UserWhereUniqueInput] = None,
          order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
      ) -> int:
          """Count the number of User records present in the database
  
          Parameters
          ----------
          select
              Select the User fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              User filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.UserCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = User.prisma().count()
  
          # results: prisma.types.UserCountAggregateOutput
          results = User.prisma().count(
              select={
                  '_all': True,
                  'optional_float': True,
              },
          )
          ```
          """
  
  
      @overload
      def count(
          self,
          select: types.UserCountAggregateInput,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.UserWhereInput] = None,
          cursor: Optional[types.UserWhereUniqueInput] = None,
          order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
      ) -> types.UserCountAggregateOutput:
          ...
  
      def count(
          self,
          select: Optional[types.UserCountAggregateInput] = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.UserWhereInput] = None,
          cursor: Optional[types.UserWhereUniqueInput] = None,
          order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
      ) -> Union[int, types.UserCountAggregateOutput]:
          """Count the number of User records present in the database
  
          Parameters
          ----------
          select
              Select the User fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              User filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.UserCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = User.prisma().count()
  
          # results: prisma.types.UserCountAggregateOutput
          results = User.prisma().count(
              select={
                  '_all': True,
                  'string': True,
              },
          )
          ```
          """
  
          # TODO: this selection building should be moved to the QueryBuilder
          #
          # note the distinction between checking for `not select` here and `select is None`
          # later is to handle the case that the given select dictionary is empty, this
          # is a limitation of our types.
          if not select:
              root_selection = ['_count { _all }']
          else:
  
              root_selection = [
                  '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
              ]
  
          if order is not None:
              warnings.warn(
                  'The `order` argument is redundant and will be removed in the next release',
                  DeprecationWarning,
                  stacklevel=2,
              )
  
          resp = self._client._execute(
              operation='query',
              method='aggregate',
              model='User',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=root_selection,
          )
  
          if select is None:
              return cast(int, resp['data']['result']['_count']['_all'])
          else:
              return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])
  
      def delete_many(
          self,
          where: Optional[types.UserWhereInput] = None
      ) -> int:
          """Delete multiple User records.
  
          Parameters
          ----------
          where
              Optional User filter to find the records to be deleted
  
          Returns
          -------
          int
              The total number of User records that were deleted
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # delete all User records
          total = User.prisma().delete_many()
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='User',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  class MActions:
      def __init__(self, client: 'Client', model: Type['models.M']) -> None:
          self._client = client
          self._model = model
  
      def query_raw(
          self,
          query: str,
          *args: Any,
      ) -> List['models.M']:
          """Execute a raw SQL query
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          List[prisma.models.M]
              The records returned by the SQL query
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          users = M.prisma().query_raw(
              'SELECT * FROM M WHERE id = $1',
              429995104,
          )
          ```
          """
          return self._client.query_raw(query, *args, model=self._model)
  
      def query_first(
          self,
          query: str,
          *args: Any,
      ) -> Optional['models.M']:
          """Execute a raw SQL query, returning the first result
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          prisma.models.M
              The first record returned by the SQL query
          None
              The raw SQL query did not return any records
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          user = M.prisma().query_first(
              'SELECT * FROM M WHERE int = $1',
              1775811865,
          )
          ```
          """
          return self._client.query_first(query, *args, model=self._model)
  
      def create(
          self,
          data: types.MCreateInput,
          include: Optional[types.MInclude] = None
      ) -> 'models.M':
          """Create a new M record.
  
          Parameters
          ----------
          data
              M record data
          include
              Specifies which relations should be loaded on the returned M model
  
          Returns
          -------
          prisma.models.M
              The created M record
  
          Raises
          ------
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # create a M record from just the required fields
          m = M.prisma().create(
              data={
                  # data to create a M record
                  'int': 893145566,
                  'float': 995405759.210273,
                  'string': 'chbfcacbd',
                  'enum': enums.ABeautifulEnum.A,
                  'boolean': True,
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='createOne',
              model='M',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      def create_many(
          self,
          data: List[types.MCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          """Create multiple M records at once.
  
          This function is *not* available when using SQLite.
  
          Parameters
          ----------
          data
              List of M record data
          skip_duplicates
              Boolean flag for ignoring unique constraint errors
  
          Returns
          -------
          int
              The total number of records created
  
          Raises
          ------
          prisma.errors.UnsupportedDatabaseError
              Attempting to query when using SQLite
          prisma.errors.UniqueViolationError
              A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          total = M.prisma().create_many(
              data=[
                  {
                      # data to create a M record
                      'int': 2058258651,
                      'float': 1583689592.87844,
                      'string': 'bghfciaafe',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': False,
                  },
                  {
                      # data to create a M record
                      'int': 2054802212,
                      'float': 60335757.68446,
                      'string': 'bgcffadich',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': True,
                  },
              ],
              skip_duplicates=True,
          )
          ```
          """
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = self._client._execute(
              operation='mutation',
              method='createMany',
              model='M',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def delete(
          self,
          where: types.MWhereUniqueInput,
          include: Optional[types.MInclude] = None
      ) -> Optional['models.M']:
          """Delete a single M record.
  
          Parameters
          ----------
          where
              M filter to select the record to be deleted, must be unique
          include
              Specifies which relations should be loaded on the returned M model
  
          Returns
          -------
          prisma.models.M
              The deleted M record
          None
              Could not find a record to delete
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          m = M.prisma().delete(
              where={
                  'id': 1266032265,
              },
          )
          ```
          """
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='M',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      def find_unique(
          self,
          where: types.MWhereUniqueInput,
          include: Optional[types.MInclude] = None
      ) -> Optional['models.M']:
          """Find a unique M record.
  
          Parameters
          ----------
          where
              M filter to find the record, must be unique
          include
              Specifies which relations should be loaded on the returned M model
  
          Returns
          -------
          prisma.models.M
              The found M record
          None
              No record matching the given input could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          m = M.prisma().find_unique(
              where={
                  'id': 93253262,
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findUnique',
              model='M',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.MWhereInput] = None,
          cursor: Optional[types.MWhereUniqueInput] = None,
          include: Optional[types.MInclude] = None,
          order: Optional[Union[types.MOrderByInput, List[types.MOrderByInput]]] = None,
      ) -> List['models.M']:
          """Find multiple M records.
  
          An empty list is returned if no records could be found.
  
          Parameters
          ----------
          take
              Limit the maximum number of M records returned
          skip
              Ignore the first N results
          where
              M filter to select records
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned M model
          order
              Order the returned M records by any field
  
          Returns
          -------
          List[prisma.models.M]
              The list of all M records that could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the first 10 M records
          ms = M.prisma().find_many(take=10)
  
          # find the first 5 M records ordered by the optional_int field
          ms = M.prisma().find_many(
              take=5,
              order={
                  'optional_int': 'desc',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findMany',
              model='M',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [self._model.parse_obj(r) for r in resp['data']['result']]
  
      def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.MWhereInput] = None,
          cursor: Optional[types.MWhereUniqueInput] = None,
          include: Optional[types.MInclude] = None,
          order: Optional[Union[types.MOrderByInput, List[types.MOrderByInput]]] = None,
      ) -> Optional['models.M']:
          """Find a single M record.
  
          Parameters
          ----------
          skip
              Ignore the first N records
          where
              M filter to select the record
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned M model
          order
              Order the returned M records by any field
  
          Returns
          -------
          prisma.models.M
              The first M record found, matching the given arguments
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the second M record ordered by the float field
          m = M.prisma().find_first(
              skip=1,
              order={
                  'float': 'desc',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findFirst',
              model='M',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      def update(
          self,
          data: types.MUpdateInput,
          where: types.MWhereUniqueInput,
          include: Optional[types.MInclude] = None
      ) -> Optional['models.M']:
          """Update a single M record.
  
          Parameters
          ----------
          data
              M record data specifying what to update
          where
              M filter to select the unique record to create / update
          include
              Specifies which relations should be loaded on the returned M model
  
          Returns
          -------
          prisma.models.M
              The updated M record
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          m = M.prisma().update(
              where={
                  'id': 2053047983,
              },
              data={
                  # data to update the M record to
              },
          )
          ```
          """
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='M',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      def upsert(
          self,
          where: types.MWhereUniqueInput,
          data: types.MUpsertInput,
          include: Optional[types.MInclude] = None,
      ) -> 'models.M':
          """Updates an existing record or create a new one
  
          Parameters
          ----------
          where
              M filter to select the unique record to create / update
          data
              Data specifying what fields to set on create and update
          include
              Specifies which relations should be loaded on the returned M model
  
          Returns
          -------
          prisma.models.M
              The created or updated M record
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          m = M.prisma().upsert(
              where={
                  'id': 685333180,
              },
              data={
                  'create': {
                      'id': 685333180,
                      'int': 2054802212,
                      'float': 60335757.68446,
                      'string': 'bgcffadich',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': True,
                  },
                  'update': {
                      'int': 2054802212,
                      'float': 60335757.68446,
                      'string': 'bgcffadich',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': True,
                  },
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='M',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      def update_many(
          self,
          data: types.MUpdateManyMutationInput,
          where: types.MWhereInput,
      ) -> int:
          """Update multiple M records
  
          Parameters
          ----------
          data
              M data to update the selected M records to
          where
              Filter to select the M records to update
  
          Returns
          -------
          int
              The total number of M records that were updated
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # update all M records
          total = M.prisma().update_many(
              data={
                  'optional_float': 127474245.94892
              },
              where={}
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='updateMany',
              model='M',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      @overload
      def count(
          self,
          select: None = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.MWhereInput] = None,
          cursor: Optional[types.MWhereUniqueInput] = None,
          order: Optional[Union[types.MOrderByInput, List[types.MOrderByInput]]] = None,
      ) -> int:
          """Count the number of M records present in the database
  
          Parameters
          ----------
          select
              Select the M fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              M filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.MCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = M.prisma().count()
  
          # results: prisma.types.MCountAggregateOutput
          results = M.prisma().count(
              select={
                  '_all': True,
                  'string': True,
              },
          )
          ```
          """
  
  
      @overload
      def count(
          self,
          select: types.MCountAggregateInput,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.MWhereInput] = None,
          cursor: Optional[types.MWhereUniqueInput] = None,
          order: Optional[Union[types.MOrderByInput, List[types.MOrderByInput]]] = None,
      ) -> types.MCountAggregateOutput:
          ...
  
      def count(
          self,
          select: Optional[types.MCountAggregateInput] = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.MWhereInput] = None,
          cursor: Optional[types.MWhereUniqueInput] = None,
          order: Optional[Union[types.MOrderByInput, List[types.MOrderByInput]]] = None,
      ) -> Union[int, types.MCountAggregateOutput]:
          """Count the number of M records present in the database
  
          Parameters
          ----------
          select
              Select the M fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              M filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.MCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = M.prisma().count()
  
          # results: prisma.types.MCountAggregateOutput
          results = M.prisma().count(
              select={
                  '_all': True,
                  'optional_string': True,
              },
          )
          ```
          """
  
          # TODO: this selection building should be moved to the QueryBuilder
          #
          # note the distinction between checking for `not select` here and `select is None`
          # later is to handle the case that the given select dictionary is empty, this
          # is a limitation of our types.
          if not select:
              root_selection = ['_count { _all }']
          else:
  
              root_selection = [
                  '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
              ]
  
          if order is not None:
              warnings.warn(
                  'The `order` argument is redundant and will be removed in the next release',
                  DeprecationWarning,
                  stacklevel=2,
              )
  
          resp = self._client._execute(
              operation='query',
              method='aggregate',
              model='M',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=root_selection,
          )
  
          if select is None:
              return cast(int, resp['data']['result']['_count']['_all'])
          else:
              return cast(types.MCountAggregateOutput, resp['data']['result']['_count'])
  
      def delete_many(
          self,
          where: Optional[types.MWhereInput] = None
      ) -> int:
          """Delete multiple M records.
  
          Parameters
          ----------
          where
              Optional M filter to find the records to be deleted
  
          Returns
          -------
          int
              The total number of M records that were deleted
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # delete all M records
          total = M.prisma().delete_many()
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='M',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  class NActions:
      def __init__(self, client: 'Client', model: Type['models.N']) -> None:
          self._client = client
          self._model = model
  
      def query_raw(
          self,
          query: str,
          *args: Any,
      ) -> List['models.N']:
          """Execute a raw SQL query
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          List[prisma.models.N]
              The records returned by the SQL query
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          users = N.prisma().query_raw(
              'SELECT * FROM N WHERE id = $1',
              1964990155,
          )
          ```
          """
          return self._client.query_raw(query, *args, model=self._model)
  
      def query_first(
          self,
          query: str,
          *args: Any,
      ) -> Optional['models.N']:
          """Execute a raw SQL query, returning the first result
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          prisma.models.N
              The first record returned by the SQL query
          None
              The raw SQL query did not return any records
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          user = N.prisma().query_first(
              'SELECT * FROM N WHERE int = $1',
              1228891816,
          )
          ```
          """
          return self._client.query_first(query, *args, model=self._model)
  
      def create(
          self,
          data: types.NCreateInput,
          include: Optional[types.NInclude] = None
      ) -> 'models.N':
          """Create a new N record.
  
          Parameters
          ----------
          data
              N record data
          include
              Specifies which relations should be loaded on the returned N model
  
          Returns
          -------
          prisma.models.N
              The created N record
  
          Raises
          ------
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # create a N record from just the required fields
          n = N.prisma().create(
              data={
                  # data to create a N record
                  'int': 255202753,
                  'float': 1223573862.54126,
                  'string': 'bageiegghg',
                  'json_': Json({'faidicegb': True}),
                  'enum': enums.ABeautifulEnum.A,
                  'boolean': True,
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='createOne',
              model='N',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      def create_many(
          self,
          data: List[types.NCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          """Create multiple N records at once.
  
          This function is *not* available when using SQLite.
  
          Parameters
          ----------
          data
              List of N record data
          skip_duplicates
              Boolean flag for ignoring unique constraint errors
  
          Returns
          -------
          int
              The total number of records created
  
          Raises
          ------
          prisma.errors.UnsupportedDatabaseError
              Attempting to query when using SQLite
          prisma.errors.UniqueViolationError
              A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          total = N.prisma().create_many(
              data=[
                  {
                      # data to create a N record
                      'int': 872078403,
                      'float': 1874748096.91689,
                      'string': 'hgjcghfbi',
                      'json_': Json({'icadbcehj': True}),
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': True,
                  },
                  {
                      # data to create a N record
                      'int': 344858293,
                      'float': 1121741130.149589,
                      'string': 'caifcbgii',
                      'json_': Json({'igaibbfgj': True}),
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': True,
                  },
              ],
              skip_duplicates=True,
          )
          ```
          """
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = self._client._execute(
              operation='mutation',
              method='createMany',
              model='N',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def delete(
          self,
          where: types.NWhereUniqueInput,
          include: Optional[types.NInclude] = None
      ) -> Optional['models.N']:
          """Delete a single N record.
  
          Parameters
          ----------
          where
              N filter to select the record to be deleted, must be unique
          include
              Specifies which relations should be loaded on the returned N model
  
          Returns
          -------
          prisma.models.N
              The deleted N record
          None
              Could not find a record to delete
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          n = N.prisma().delete(
              where={
                  'id': 525761943,
              },
          )
          ```
          """
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='N',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      def find_unique(
          self,
          where: types.NWhereUniqueInput,
          include: Optional[types.NInclude] = None
      ) -> Optional['models.N']:
          """Find a unique N record.
  
          Parameters
          ----------
          where
              N filter to find the record, must be unique
          include
              Specifies which relations should be loaded on the returned N model
  
          Returns
          -------
          prisma.models.N
              The found N record
          None
              No record matching the given input could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          n = N.prisma().find_unique(
              where={
                  'id': 736209796,
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findUnique',
              model='N',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.NWhereInput] = None,
          cursor: Optional[types.NWhereUniqueInput] = None,
          include: Optional[types.NInclude] = None,
          order: Optional[Union[types.NOrderByInput, List[types.NOrderByInput]]] = None,
      ) -> List['models.N']:
          """Find multiple N records.
  
          An empty list is returned if no records could be found.
  
          Parameters
          ----------
          take
              Limit the maximum number of N records returned
          skip
              Ignore the first N results
          where
              N filter to select records
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned N model
          order
              Order the returned N records by any field
  
          Returns
          -------
          List[prisma.models.N]
              The list of all N records that could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the first 10 N records
          ns = N.prisma().find_many(take=10)
  
          # find the first 5 N records ordered by the optional_int field
          ns = N.prisma().find_many(
              take=5,
              order={
                  'optional_int': 'desc',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findMany',
              model='N',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [self._model.parse_obj(r) for r in resp['data']['result']]
  
      def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.NWhereInput] = None,
          cursor: Optional[types.NWhereUniqueInput] = None,
          include: Optional[types.NInclude] = None,
          order: Optional[Union[types.NOrderByInput, List[types.NOrderByInput]]] = None,
      ) -> Optional['models.N']:
          """Find a single N record.
  
          Parameters
          ----------
          skip
              Ignore the first N records
          where
              N filter to select the record
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned N model
          order
              Order the returned N records by any field
  
          Returns
          -------
          prisma.models.N
              The first N record found, matching the given arguments
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the second N record ordered by the float field
          n = N.prisma().find_first(
              skip=1,
              order={
                  'float': 'desc',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findFirst',
              model='N',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      def update(
          self,
          data: types.NUpdateInput,
          where: types.NWhereUniqueInput,
          include: Optional[types.NInclude] = None
      ) -> Optional['models.N']:
          """Update a single N record.
  
          Parameters
          ----------
          data
              N record data specifying what to update
          where
              N filter to select the unique record to create / update
          include
              Specifies which relations should be loaded on the returned N model
  
          Returns
          -------
          prisma.models.N
              The updated N record
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          n = N.prisma().update(
              where={
                  'id': 493907821,
              },
              data={
                  # data to update the N record to
              },
          )
          ```
          """
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='N',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      def upsert(
          self,
          where: types.NWhereUniqueInput,
          data: types.NUpsertInput,
          include: Optional[types.NInclude] = None,
      ) -> 'models.N':
          """Updates an existing record or create a new one
  
          Parameters
          ----------
          where
              N filter to select the unique record to create / update
          data
              Data specifying what fields to set on create and update
          include
              Specifies which relations should be loaded on the returned N model
  
          Returns
          -------
          prisma.models.N
              The created or updated N record
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          n = N.prisma().upsert(
              where={
                  'id': 639686562,
              },
              data={
                  'create': {
                      'id': 639686562,
                      'int': 344858293,
                      'float': 1121741130.149589,
                      'string': 'caifcbgii',
                      'json_': Json({'igaibbfgj': True}),
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': True,
                  },
                  'update': {
                      'int': 344858293,
                      'float': 1121741130.149589,
                      'string': 'caifcbgii',
                      'json_': Json({'igaibbfgj': True}),
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': True,
                  },
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='N',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      def update_many(
          self,
          data: types.NUpdateManyMutationInput,
          where: types.NWhereInput,
      ) -> int:
          """Update multiple N records
  
          Parameters
          ----------
          data
              N data to update the selected N records to
          where
              Filter to select the N records to update
  
          Returns
          -------
          int
              The total number of N records that were updated
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # update all N records
          total = N.prisma().update_many(
              data={
                  'optional_float': 654007347.190526
              },
              where={}
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='updateMany',
              model='N',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      @overload
      def count(
          self,
          select: None = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.NWhereInput] = None,
          cursor: Optional[types.NWhereUniqueInput] = None,
          order: Optional[Union[types.NOrderByInput, List[types.NOrderByInput]]] = None,
      ) -> int:
          """Count the number of N records present in the database
  
          Parameters
          ----------
          select
              Select the N fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              N filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.NCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = N.prisma().count()
  
          # results: prisma.types.NCountAggregateOutput
          results = N.prisma().count(
              select={
                  '_all': True,
                  'string': True,
              },
          )
          ```
          """
  
  
      @overload
      def count(
          self,
          select: types.NCountAggregateInput,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.NWhereInput] = None,
          cursor: Optional[types.NWhereUniqueInput] = None,
          order: Optional[Union[types.NOrderByInput, List[types.NOrderByInput]]] = None,
      ) -> types.NCountAggregateOutput:
          ...
  
      def count(
          self,
          select: Optional[types.NCountAggregateInput] = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.NWhereInput] = None,
          cursor: Optional[types.NWhereUniqueInput] = None,
          order: Optional[Union[types.NOrderByInput, List[types.NOrderByInput]]] = None,
      ) -> Union[int, types.NCountAggregateOutput]:
          """Count the number of N records present in the database
  
          Parameters
          ----------
          select
              Select the N fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              N filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.NCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = N.prisma().count()
  
          # results: prisma.types.NCountAggregateOutput
          results = N.prisma().count(
              select={
                  '_all': True,
                  'optional_string': True,
              },
          )
          ```
          """
  
          # TODO: this selection building should be moved to the QueryBuilder
          #
          # note the distinction between checking for `not select` here and `select is None`
          # later is to handle the case that the given select dictionary is empty, this
          # is a limitation of our types.
          if not select:
              root_selection = ['_count { _all }']
          else:
  
              root_selection = [
                  '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
              ]
  
          if order is not None:
              warnings.warn(
                  'The `order` argument is redundant and will be removed in the next release',
                  DeprecationWarning,
                  stacklevel=2,
              )
  
          resp = self._client._execute(
              operation='query',
              method='aggregate',
              model='N',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=root_selection,
          )
  
          if select is None:
              return cast(int, resp['data']['result']['_count']['_all'])
          else:
              return cast(types.NCountAggregateOutput, resp['data']['result']['_count'])
  
      def delete_many(
          self,
          where: Optional[types.NWhereInput] = None
      ) -> int:
          """Delete multiple N records.
  
          Parameters
          ----------
          where
              Optional N filter to find the records to be deleted
  
          Returns
          -------
          int
              The total number of N records that were deleted
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # delete all N records
          total = N.prisma().delete_many()
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='N',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  class OneOptionalActions:
      def __init__(self, client: 'Client', model: Type['models.OneOptional']) -> None:
          self._client = client
          self._model = model
  
      def query_raw(
          self,
          query: str,
          *args: Any,
      ) -> List['models.OneOptional']:
          """Execute a raw SQL query
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          List[prisma.models.OneOptional]
              The records returned by the SQL query
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          users = OneOptional.prisma().query_raw(
              'SELECT * FROM OneOptional WHERE id = $1',
              78746985,
          )
          ```
          """
          return self._client.query_raw(query, *args, model=self._model)
  
      def query_first(
          self,
          query: str,
          *args: Any,
      ) -> Optional['models.OneOptional']:
          """Execute a raw SQL query, returning the first result
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          prisma.models.OneOptional
              The first record returned by the SQL query
          None
              The raw SQL query did not return any records
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          user = OneOptional.prisma().query_first(
              'SELECT * FROM OneOptional WHERE int = $1',
              1398328302,
          )
          ```
          """
          return self._client.query_first(query, *args, model=self._model)
  
      def create(
          self,
          data: types.OneOptionalCreateInput,
          include: Optional[types.OneOptionalInclude] = None
      ) -> 'models.OneOptional':
          """Create a new OneOptional record.
  
          Parameters
          ----------
          data
              OneOptional record data
          include
              Specifies which relations should be loaded on the returned OneOptional model
  
          Returns
          -------
          prisma.models.OneOptional
              The created OneOptional record
  
          Raises
          ------
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # create a OneOptional record from just the required fields
          oneoptional = OneOptional.prisma().create(
              data={
                  # data to create a OneOptional record
                  'int': 856000655,
                  'float': 1452336924.157319,
                  'string': 'cabdjadaji',
                  'enum': enums.ABeautifulEnum.A,
                  'boolean': False,
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='createOne',
              model='OneOptional',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      def create_many(
          self,
          data: List[types.OneOptionalCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          """Create multiple OneOptional records at once.
  
          This function is *not* available when using SQLite.
  
          Parameters
          ----------
          data
              List of OneOptional record data
          skip_duplicates
              Boolean flag for ignoring unique constraint errors
  
          Returns
          -------
          int
              The total number of records created
  
          Raises
          ------
          prisma.errors.UnsupportedDatabaseError
              Attempting to query when using SQLite
          prisma.errors.UniqueViolationError
              A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          total = OneOptional.prisma().create_many(
              data=[
                  {
                      # data to create a OneOptional record
                      'int': 1800624392,
                      'float': 2077067425.167211,
                      'string': 'jcgghhgdj',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': True,
                  },
                  {
                      # data to create a OneOptional record
                      'int': 1738083805,
                      'float': 340946258.60107,
                      'string': 'cjagadcjg',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': False,
                  },
              ],
              skip_duplicates=True,
          )
          ```
          """
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = self._client._execute(
              operation='mutation',
              method='createMany',
              model='OneOptional',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def delete(
          self,
          where: types.OneOptionalWhereUniqueInput,
          include: Optional[types.OneOptionalInclude] = None
      ) -> Optional['models.OneOptional']:
          """Delete a single OneOptional record.
  
          Parameters
          ----------
          where
              OneOptional filter to select the record to be deleted, must be unique
          include
              Specifies which relations should be loaded on the returned OneOptional model
  
          Returns
          -------
          prisma.models.OneOptional
              The deleted OneOptional record
          None
              Could not find a record to delete
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          oneoptional = OneOptional.prisma().delete(
              where={
                  'id': 1611009182,
              },
          )
          ```
          """
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='OneOptional',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      def find_unique(
          self,
          where: types.OneOptionalWhereUniqueInput,
          include: Optional[types.OneOptionalInclude] = None
      ) -> Optional['models.OneOptional']:
          """Find a unique OneOptional record.
  
          Parameters
          ----------
          where
              OneOptional filter to find the record, must be unique
          include
              Specifies which relations should be loaded on the returned OneOptional model
  
          Returns
          -------
          prisma.models.OneOptional
              The found OneOptional record
          None
              No record matching the given input could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          oneoptional = OneOptional.prisma().find_unique(
              where={
                  'id': 446673791,
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findUnique',
              model='OneOptional',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.OneOptionalWhereInput] = None,
          cursor: Optional[types.OneOptionalWhereUniqueInput] = None,
          include: Optional[types.OneOptionalInclude] = None,
          order: Optional[Union[types.OneOptionalOrderByInput, List[types.OneOptionalOrderByInput]]] = None,
      ) -> List['models.OneOptional']:
          """Find multiple OneOptional records.
  
          An empty list is returned if no records could be found.
  
          Parameters
          ----------
          take
              Limit the maximum number of OneOptional records returned
          skip
              Ignore the first N results
          where
              OneOptional filter to select records
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned OneOptional model
          order
              Order the returned OneOptional records by any field
  
          Returns
          -------
          List[prisma.models.OneOptional]
              The list of all OneOptional records that could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the first 10 OneOptional records
          oneoptionals = OneOptional.prisma().find_many(take=10)
  
          # find the first 5 OneOptional records ordered by the optional_int field
          oneoptionals = OneOptional.prisma().find_many(
              take=5,
              order={
                  'optional_int': 'desc',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findMany',
              model='OneOptional',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [self._model.parse_obj(r) for r in resp['data']['result']]
  
      def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.OneOptionalWhereInput] = None,
          cursor: Optional[types.OneOptionalWhereUniqueInput] = None,
          include: Optional[types.OneOptionalInclude] = None,
          order: Optional[Union[types.OneOptionalOrderByInput, List[types.OneOptionalOrderByInput]]] = None,
      ) -> Optional['models.OneOptional']:
          """Find a single OneOptional record.
  
          Parameters
          ----------
          skip
              Ignore the first N records
          where
              OneOptional filter to select the record
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned OneOptional model
          order
              Order the returned OneOptional records by any field
  
          Returns
          -------
          prisma.models.OneOptional
              The first OneOptional record found, matching the given arguments
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the second OneOptional record ordered by the float field
          oneoptional = OneOptional.prisma().find_first(
              skip=1,
              order={
                  'float': 'desc',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findFirst',
              model='OneOptional',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      def update(
          self,
          data: types.OneOptionalUpdateInput,
          where: types.OneOptionalWhereUniqueInput,
          include: Optional[types.OneOptionalInclude] = None
      ) -> Optional['models.OneOptional']:
          """Update a single OneOptional record.
  
          Parameters
          ----------
          data
              OneOptional record data specifying what to update
          where
              OneOptional filter to select the unique record to create / update
          include
              Specifies which relations should be loaded on the returned OneOptional model
  
          Returns
          -------
          prisma.models.OneOptional
              The updated OneOptional record
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          oneoptional = OneOptional.prisma().update(
              where={
                  'id': 300568396,
              },
              data={
                  # data to update the OneOptional record to
              },
          )
          ```
          """
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='OneOptional',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      def upsert(
          self,
          where: types.OneOptionalWhereUniqueInput,
          data: types.OneOptionalUpsertInput,
          include: Optional[types.OneOptionalInclude] = None,
      ) -> 'models.OneOptional':
          """Updates an existing record or create a new one
  
          Parameters
          ----------
          where
              OneOptional filter to select the unique record to create / update
          data
              Data specifying what fields to set on create and update
          include
              Specifies which relations should be loaded on the returned OneOptional model
  
          Returns
          -------
          prisma.models.OneOptional
              The created or updated OneOptional record
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          oneoptional = OneOptional.prisma().upsert(
              where={
                  'id': 632626069,
              },
              data={
                  'create': {
                      'id': 632626069,
                      'int': 1738083805,
                      'float': 340946258.60107,
                      'string': 'cjagadcjg',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': False,
                  },
                  'update': {
                      'int': 1738083805,
                      'float': 340946258.60107,
                      'string': 'cjagadcjg',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': False,
                  },
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='OneOptional',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      def update_many(
          self,
          data: types.OneOptionalUpdateManyMutationInput,
          where: types.OneOptionalWhereInput,
      ) -> int:
          """Update multiple OneOptional records
  
          Parameters
          ----------
          data
              OneOptional data to update the selected OneOptional records to
          where
              Filter to select the OneOptional records to update
  
          Returns
          -------
          int
              The total number of OneOptional records that were updated
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # update all OneOptional records
          total = OneOptional.prisma().update_many(
              data={
                  'optional_float': 1724011690.47015
              },
              where={}
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='updateMany',
              model='OneOptional',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      @overload
      def count(
          self,
          select: None = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.OneOptionalWhereInput] = None,
          cursor: Optional[types.OneOptionalWhereUniqueInput] = None,
          order: Optional[Union[types.OneOptionalOrderByInput, List[types.OneOptionalOrderByInput]]] = None,
      ) -> int:
          """Count the number of OneOptional records present in the database
  
          Parameters
          ----------
          select
              Select the OneOptional fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              OneOptional filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.OneOptionalCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = OneOptional.prisma().count()
  
          # results: prisma.types.OneOptionalCountAggregateOutput
          results = OneOptional.prisma().count(
              select={
                  '_all': True,
                  'string': True,
              },
          )
          ```
          """
  
  
      @overload
      def count(
          self,
          select: types.OneOptionalCountAggregateInput,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.OneOptionalWhereInput] = None,
          cursor: Optional[types.OneOptionalWhereUniqueInput] = None,
          order: Optional[Union[types.OneOptionalOrderByInput, List[types.OneOptionalOrderByInput]]] = None,
      ) -> types.OneOptionalCountAggregateOutput:
          ...
  
      def count(
          self,
          select: Optional[types.OneOptionalCountAggregateInput] = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.OneOptionalWhereInput] = None,
          cursor: Optional[types.OneOptionalWhereUniqueInput] = None,
          order: Optional[Union[types.OneOptionalOrderByInput, List[types.OneOptionalOrderByInput]]] = None,
      ) -> Union[int, types.OneOptionalCountAggregateOutput]:
          """Count the number of OneOptional records present in the database
  
          Parameters
          ----------
          select
              Select the OneOptional fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              OneOptional filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.OneOptionalCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = OneOptional.prisma().count()
  
          # results: prisma.types.OneOptionalCountAggregateOutput
          results = OneOptional.prisma().count(
              select={
                  '_all': True,
                  'optional_string': True,
              },
          )
          ```
          """
  
          # TODO: this selection building should be moved to the QueryBuilder
          #
          # note the distinction between checking for `not select` here and `select is None`
          # later is to handle the case that the given select dictionary is empty, this
          # is a limitation of our types.
          if not select:
              root_selection = ['_count { _all }']
          else:
  
              root_selection = [
                  '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
              ]
  
          if order is not None:
              warnings.warn(
                  'The `order` argument is redundant and will be removed in the next release',
                  DeprecationWarning,
                  stacklevel=2,
              )
  
          resp = self._client._execute(
              operation='query',
              method='aggregate',
              model='OneOptional',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=root_selection,
          )
  
          if select is None:
              return cast(int, resp['data']['result']['_count']['_all'])
          else:
              return cast(types.OneOptionalCountAggregateOutput, resp['data']['result']['_count'])
  
      def delete_many(
          self,
          where: Optional[types.OneOptionalWhereInput] = None
      ) -> int:
          """Delete multiple OneOptional records.
  
          Parameters
          ----------
          where
              Optional OneOptional filter to find the records to be deleted
  
          Returns
          -------
          int
              The total number of OneOptional records that were deleted
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # delete all OneOptional records
          total = OneOptional.prisma().delete_many()
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='OneOptional',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  class ManyRequiredActions:
      def __init__(self, client: 'Client', model: Type['models.ManyRequired']) -> None:
          self._client = client
          self._model = model
  
      def query_raw(
          self,
          query: str,
          *args: Any,
      ) -> List['models.ManyRequired']:
          """Execute a raw SQL query
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          List[prisma.models.ManyRequired]
              The records returned by the SQL query
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          users = ManyRequired.prisma().query_raw(
              'SELECT * FROM ManyRequired WHERE id = $1',
              1209209912,
          )
          ```
          """
          return self._client.query_raw(query, *args, model=self._model)
  
      def query_first(
          self,
          query: str,
          *args: Any,
      ) -> Optional['models.ManyRequired']:
          """Execute a raw SQL query, returning the first result
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          prisma.models.ManyRequired
              The first record returned by the SQL query
          None
              The raw SQL query did not return any records
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          user = ManyRequired.prisma().query_first(
              'SELECT * FROM ManyRequired WHERE one_optional_id = $1',
              1536744465,
          )
          ```
          """
          return self._client.query_first(query, *args, model=self._model)
  
      def create(
          self,
          data: types.ManyRequiredCreateInput,
          include: Optional[types.ManyRequiredInclude] = None
      ) -> 'models.ManyRequired':
          """Create a new ManyRequired record.
  
          Parameters
          ----------
          data
              ManyRequired record data
          include
              Specifies which relations should be loaded on the returned ManyRequired model
  
          Returns
          -------
          prisma.models.ManyRequired
              The created ManyRequired record
  
          Raises
          ------
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # create a ManyRequired record from just the required fields
          manyrequired = ManyRequired.prisma().create(
              data={
                  # data to create a ManyRequired record
                  'int': 424218998,
                  'float': 2125632375.53695,
                  'string': 'jcehcdchh',
                  'enum': enums.ABeautifulEnum.A,
                  'boolean': True,
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='createOne',
              model='ManyRequired',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      def create_many(
          self,
          data: List[types.ManyRequiredCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          """Create multiple ManyRequired records at once.
  
          This function is *not* available when using SQLite.
  
          Parameters
          ----------
          data
              List of ManyRequired record data
          skip_duplicates
              Boolean flag for ignoring unique constraint errors
  
          Returns
          -------
          int
              The total number of records created
  
          Raises
          ------
          prisma.errors.UnsupportedDatabaseError
              Attempting to query when using SQLite
          prisma.errors.UniqueViolationError
              A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          total = ManyRequired.prisma().create_many(
              data=[
                  {
                      # data to create a ManyRequired record
                      'int': 1848832019,
                      'float': 1921528400.210042,
                      'string': 'iejbeaaeg',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': False,
                  },
                  {
                      # data to create a ManyRequired record
                      'int': 273032060,
                      'float': 982848517.51073,
                      'string': 'cbbheiicgh',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': True,
                  },
              ],
              skip_duplicates=True,
          )
          ```
          """
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = self._client._execute(
              operation='mutation',
              method='createMany',
              model='ManyRequired',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def delete(
          self,
          where: types.ManyRequiredWhereUniqueInput,
          include: Optional[types.ManyRequiredInclude] = None
      ) -> Optional['models.ManyRequired']:
          """Delete a single ManyRequired record.
  
          Parameters
          ----------
          where
              ManyRequired filter to select the record to be deleted, must be unique
          include
              Specifies which relations should be loaded on the returned ManyRequired model
  
          Returns
          -------
          prisma.models.ManyRequired
              The deleted ManyRequired record
          None
              Could not find a record to delete
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          manyrequired = ManyRequired.prisma().delete(
              where={
                  'id': 1297607553,
              },
          )
          ```
          """
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='ManyRequired',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      def find_unique(
          self,
          where: types.ManyRequiredWhereUniqueInput,
          include: Optional[types.ManyRequiredInclude] = None
      ) -> Optional['models.ManyRequired']:
          """Find a unique ManyRequired record.
  
          Parameters
          ----------
          where
              ManyRequired filter to find the record, must be unique
          include
              Specifies which relations should be loaded on the returned ManyRequired model
  
          Returns
          -------
          prisma.models.ManyRequired
              The found ManyRequired record
          None
              No record matching the given input could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          manyrequired = ManyRequired.prisma().find_unique(
              where={
                  'id': 519488550,
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findUnique',
              model='ManyRequired',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.ManyRequiredWhereInput] = None,
          cursor: Optional[types.ManyRequiredWhereUniqueInput] = None,
          include: Optional[types.ManyRequiredInclude] = None,
          order: Optional[Union[types.ManyRequiredOrderByInput, List[types.ManyRequiredOrderByInput]]] = None,
      ) -> List['models.ManyRequired']:
          """Find multiple ManyRequired records.
  
          An empty list is returned if no records could be found.
  
          Parameters
          ----------
          take
              Limit the maximum number of ManyRequired records returned
          skip
              Ignore the first N results
          where
              ManyRequired filter to select records
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned ManyRequired model
          order
              Order the returned ManyRequired records by any field
  
          Returns
          -------
          List[prisma.models.ManyRequired]
              The list of all ManyRequired records that could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the first 10 ManyRequired records
          manyrequireds = ManyRequired.prisma().find_many(take=10)
  
          # find the first 5 ManyRequired records ordered by the int field
          manyrequireds = ManyRequired.prisma().find_many(
              take=5,
              order={
                  'int': 'desc',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findMany',
              model='ManyRequired',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [self._model.parse_obj(r) for r in resp['data']['result']]
  
      def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.ManyRequiredWhereInput] = None,
          cursor: Optional[types.ManyRequiredWhereUniqueInput] = None,
          include: Optional[types.ManyRequiredInclude] = None,
          order: Optional[Union[types.ManyRequiredOrderByInput, List[types.ManyRequiredOrderByInput]]] = None,
      ) -> Optional['models.ManyRequired']:
          """Find a single ManyRequired record.
  
          Parameters
          ----------
          skip
              Ignore the first N records
          where
              ManyRequired filter to select the record
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned ManyRequired model
          order
              Order the returned ManyRequired records by any field
  
          Returns
          -------
          prisma.models.ManyRequired
              The first ManyRequired record found, matching the given arguments
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the second ManyRequired record ordered by the optional_int field
          manyrequired = ManyRequired.prisma().find_first(
              skip=1,
              order={
                  'optional_int': 'desc',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findFirst',
              model='ManyRequired',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      def update(
          self,
          data: types.ManyRequiredUpdateInput,
          where: types.ManyRequiredWhereUniqueInput,
          include: Optional[types.ManyRequiredInclude] = None
      ) -> Optional['models.ManyRequired']:
          """Update a single ManyRequired record.
  
          Parameters
          ----------
          data
              ManyRequired record data specifying what to update
          where
              ManyRequired filter to select the unique record to create / update
          include
              Specifies which relations should be loaded on the returned ManyRequired model
  
          Returns
          -------
          prisma.models.ManyRequired
              The updated ManyRequired record
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          manyrequired = ManyRequired.prisma().update(
              where={
                  'id': 976832615,
              },
              data={
                  # data to update the ManyRequired record to
              },
          )
          ```
          """
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='ManyRequired',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      def upsert(
          self,
          where: types.ManyRequiredWhereUniqueInput,
          data: types.ManyRequiredUpsertInput,
          include: Optional[types.ManyRequiredInclude] = None,
      ) -> 'models.ManyRequired':
          """Updates an existing record or create a new one
  
          Parameters
          ----------
          where
              ManyRequired filter to select the unique record to create / update
          data
              Data specifying what fields to set on create and update
          include
              Specifies which relations should be loaded on the returned ManyRequired model
  
          Returns
          -------
          prisma.models.ManyRequired
              The created or updated ManyRequired record
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          manyrequired = ManyRequired.prisma().upsert(
              where={
                  'id': 1696425492,
              },
              data={
                  'create': {
                      'id': 1696425492,
                      'int': 273032060,
                      'float': 982848517.51073,
                      'string': 'cbbheiicgh',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': True,
                  },
                  'update': {
                      'int': 273032060,
                      'float': 982848517.51073,
                      'string': 'cbbheiicgh',
                      'enum': enums.ABeautifulEnum.A,
                      'boolean': True,
                  },
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='ManyRequired',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      def update_many(
          self,
          data: types.ManyRequiredUpdateManyMutationInput,
          where: types.ManyRequiredWhereInput,
      ) -> int:
          """Update multiple ManyRequired records
  
          Parameters
          ----------
          data
              ManyRequired data to update the selected ManyRequired records to
          where
              Filter to select the ManyRequired records to update
  
          Returns
          -------
          int
              The total number of ManyRequired records that were updated
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # update all ManyRequired records
          total = ManyRequired.prisma().update_many(
              data={
                  'float': 169262781.102308
              },
              where={}
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='updateMany',
              model='ManyRequired',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      @overload
      def count(
          self,
          select: None = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.ManyRequiredWhereInput] = None,
          cursor: Optional[types.ManyRequiredWhereUniqueInput] = None,
          order: Optional[Union[types.ManyRequiredOrderByInput, List[types.ManyRequiredOrderByInput]]] = None,
      ) -> int:
          """Count the number of ManyRequired records present in the database
  
          Parameters
          ----------
          select
              Select the ManyRequired fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              ManyRequired filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.ManyRequiredCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = ManyRequired.prisma().count()
  
          # results: prisma.types.ManyRequiredCountAggregateOutput
          results = ManyRequired.prisma().count(
              select={
                  '_all': True,
                  'optional_float': True,
              },
          )
          ```
          """
  
  
      @overload
      def count(
          self,
          select: types.ManyRequiredCountAggregateInput,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.ManyRequiredWhereInput] = None,
          cursor: Optional[types.ManyRequiredWhereUniqueInput] = None,
          order: Optional[Union[types.ManyRequiredOrderByInput, List[types.ManyRequiredOrderByInput]]] = None,
      ) -> types.ManyRequiredCountAggregateOutput:
          ...
  
      def count(
          self,
          select: Optional[types.ManyRequiredCountAggregateInput] = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.ManyRequiredWhereInput] = None,
          cursor: Optional[types.ManyRequiredWhereUniqueInput] = None,
          order: Optional[Union[types.ManyRequiredOrderByInput, List[types.ManyRequiredOrderByInput]]] = None,
      ) -> Union[int, types.ManyRequiredCountAggregateOutput]:
          """Count the number of ManyRequired records present in the database
  
          Parameters
          ----------
          select
              Select the ManyRequired fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              ManyRequired filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.ManyRequiredCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = ManyRequired.prisma().count()
  
          # results: prisma.types.ManyRequiredCountAggregateOutput
          results = ManyRequired.prisma().count(
              select={
                  '_all': True,
                  'string': True,
              },
          )
          ```
          """
  
          # TODO: this selection building should be moved to the QueryBuilder
          #
          # note the distinction between checking for `not select` here and `select is None`
          # later is to handle the case that the given select dictionary is empty, this
          # is a limitation of our types.
          if not select:
              root_selection = ['_count { _all }']
          else:
  
              root_selection = [
                  '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
              ]
  
          if order is not None:
              warnings.warn(
                  'The `order` argument is redundant and will be removed in the next release',
                  DeprecationWarning,
                  stacklevel=2,
              )
  
          resp = self._client._execute(
              operation='query',
              method='aggregate',
              model='ManyRequired',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=root_selection,
          )
  
          if select is None:
              return cast(int, resp['data']['result']['_count']['_all'])
          else:
              return cast(types.ManyRequiredCountAggregateOutput, resp['data']['result']['_count'])
  
      def delete_many(
          self,
          where: Optional[types.ManyRequiredWhereInput] = None
      ) -> int:
          """Delete multiple ManyRequired records.
  
          Parameters
          ----------
          where
              Optional ManyRequired filter to find the records to be deleted
  
          Returns
          -------
          int
              The total number of ManyRequired records that were deleted
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # delete all ManyRequired records
          total = ManyRequired.prisma().delete_many()
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='ManyRequired',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  class ListsActions:
      def __init__(self, client: 'Client', model: Type['models.Lists']) -> None:
          self._client = client
          self._model = model
  
      def query_raw(
          self,
          query: str,
          *args: Any,
      ) -> List['models.Lists']:
          """Execute a raw SQL query
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          List[prisma.models.Lists]
              The records returned by the SQL query
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          users = Lists.prisma().query_raw(
              'SELECT * FROM Lists WHERE id = $1',
              'dchgibach',
          )
          ```
          """
          return self._client.query_raw(query, *args, model=self._model)
  
      def query_first(
          self,
          query: str,
          *args: Any,
      ) -> Optional['models.Lists']:
          """Execute a raw SQL query, returning the first result
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          prisma.models.Lists
              The first record returned by the SQL query
          None
              The raw SQL query did not return any records
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          user = Lists.prisma().query_first(
              'SELECT * FROM Lists WHERE strings = $1',
              ['fchheijjc'],
          )
          ```
          """
          return self._client.query_first(query, *args, model=self._model)
  
      def create(
          self,
          data: types.ListsCreateInput,
          include: Optional[types.ListsInclude] = None
      ) -> 'models.Lists':
          """Create a new Lists record.
  
          Parameters
          ----------
          data
              Lists record data
          include
              Specifies which relations should be loaded on the returned Lists model
  
          Returns
          -------
          prisma.models.Lists
              The created Lists record
  
          Raises
          ------
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # create a Lists record from just the required fields
          lists = Lists.prisma().create(
              data={
                  # data to create a Lists record
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='createOne',
              model='Lists',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      def create_many(
          self,
          data: List[types.ListsCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          """Create multiple Lists records at once.
  
          This function is *not* available when using SQLite.
  
          Parameters
          ----------
          data
              List of Lists record data
          skip_duplicates
              Boolean flag for ignoring unique constraint errors
  
          Returns
          -------
          int
              The total number of records created
  
          Raises
          ------
          prisma.errors.UnsupportedDatabaseError
              Attempting to query when using SQLite
          prisma.errors.UniqueViolationError
              A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          total = Lists.prisma().create_many(
              data=[
                  {
                      # data to create a Lists record
                  },
                  {
                      # data to create a Lists record
                  },
              ],
              skip_duplicates=True,
          )
          ```
          """
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = self._client._execute(
              operation='mutation',
              method='createMany',
              model='Lists',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def delete(
          self,
          where: types.ListsWhereUniqueInput,
          include: Optional[types.ListsInclude] = None
      ) -> Optional['models.Lists']:
          """Delete a single Lists record.
  
          Parameters
          ----------
          where
              Lists filter to select the record to be deleted, must be unique
          include
              Specifies which relations should be loaded on the returned Lists model
  
          Returns
          -------
          prisma.models.Lists
              The deleted Lists record
          None
              Could not find a record to delete
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          lists = Lists.prisma().delete(
              where={
                  'id': 'cacjdfhejh',
              },
          )
          ```
          """
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='Lists',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      def find_unique(
          self,
          where: types.ListsWhereUniqueInput,
          include: Optional[types.ListsInclude] = None
      ) -> Optional['models.Lists']:
          """Find a unique Lists record.
  
          Parameters
          ----------
          where
              Lists filter to find the record, must be unique
          include
              Specifies which relations should be loaded on the returned Lists model
  
          Returns
          -------
          prisma.models.Lists
              The found Lists record
          None
              No record matching the given input could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          lists = Lists.prisma().find_unique(
              where={
                  'id': 'bdbifjhbbi',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findUnique',
              model='Lists',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.ListsWhereInput] = None,
          cursor: Optional[types.ListsWhereUniqueInput] = None,
          include: Optional[types.ListsInclude] = None,
          order: Optional[Union[types.ListsOrderByInput, List[types.ListsOrderByInput]]] = None,
      ) -> List['models.Lists']:
          """Find multiple Lists records.
  
          An empty list is returned if no records could be found.
  
          Parameters
          ----------
          take
              Limit the maximum number of Lists records returned
          skip
              Ignore the first N results
          where
              Lists filter to select records
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned Lists model
          order
              Order the returned Lists records by any field
  
          Returns
          -------
          List[prisma.models.Lists]
              The list of all Lists records that could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the first 10 Lists records
          lists = Lists.prisma().find_many(take=10)
  
          # find the first 5 Lists records ordered by the bytes field
          lists = Lists.prisma().find_many(
              take=5,
              order={
                  'bytes': 'desc',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findMany',
              model='Lists',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [self._model.parse_obj(r) for r in resp['data']['result']]
  
      def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.ListsWhereInput] = None,
          cursor: Optional[types.ListsWhereUniqueInput] = None,
          include: Optional[types.ListsInclude] = None,
          order: Optional[Union[types.ListsOrderByInput, List[types.ListsOrderByInput]]] = None,
      ) -> Optional['models.Lists']:
          """Find a single Lists record.
  
          Parameters
          ----------
          skip
              Ignore the first N records
          where
              Lists filter to select the record
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned Lists model
          order
              Order the returned Lists records by any field
  
          Returns
          -------
          prisma.models.Lists
              The first Lists record found, matching the given arguments
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the second Lists record ordered by the dates field
          lists = Lists.prisma().find_first(
              skip=1,
              order={
                  'dates': 'desc',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findFirst',
              model='Lists',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      def update(
          self,
          data: types.ListsUpdateInput,
          where: types.ListsWhereUniqueInput,
          include: Optional[types.ListsInclude] = None
      ) -> Optional['models.Lists']:
          """Update a single Lists record.
  
          Parameters
          ----------
          data
              Lists record data specifying what to update
          where
              Lists filter to select the unique record to create / update
          include
              Specifies which relations should be loaded on the returned Lists model
  
          Returns
          -------
          prisma.models.Lists
              The updated Lists record
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          lists = Lists.prisma().update(
              where={
                  'id': 'cbccbbcdfb',
              },
              data={
                  # data to update the Lists record to
              },
          )
          ```
          """
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='Lists',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      def upsert(
          self,
          where: types.ListsWhereUniqueInput,
          data: types.ListsUpsertInput,
          include: Optional[types.ListsInclude] = None,
      ) -> 'models.Lists':
          """Updates an existing record or create a new one
  
          Parameters
          ----------
          where
              Lists filter to select the unique record to create / update
          data
              Data specifying what fields to set on create and update
          include
              Specifies which relations should be loaded on the returned Lists model
  
          Returns
          -------
          prisma.models.Lists
              The created or updated Lists record
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          lists = Lists.prisma().upsert(
              where={
                  'id': 'bacejedaca',
              },
              data={
                  'create': {
                      'id': 'bacejedaca',
                  },
                  'update': {
                  },
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='Lists',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      def update_many(
          self,
          data: types.ListsUpdateManyMutationInput,
          where: types.ListsWhereInput,
      ) -> int:
          """Update multiple Lists records
  
          Parameters
          ----------
          data
              Lists data to update the selected Lists records to
          where
              Filter to select the Lists records to update
  
          Returns
          -------
          int
              The total number of Lists records that were updated
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # update all Lists records
          total = Lists.prisma().update_many(
              data={
                  'bools': [False]
              },
              where={}
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='updateMany',
              model='Lists',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      @overload
      def count(
          self,
          select: None = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.ListsWhereInput] = None,
          cursor: Optional[types.ListsWhereUniqueInput] = None,
          order: Optional[Union[types.ListsOrderByInput, List[types.ListsOrderByInput]]] = None,
      ) -> int:
          """Count the number of Lists records present in the database
  
          Parameters
          ----------
          select
              Select the Lists fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              Lists filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.ListsCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = Lists.prisma().count()
  
          # results: prisma.types.ListsCountAggregateOutput
          results = Lists.prisma().count(
              select={
                  '_all': True,
                  'ints': True,
              },
          )
          ```
          """
  
  
      @overload
      def count(
          self,
          select: types.ListsCountAggregateInput,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.ListsWhereInput] = None,
          cursor: Optional[types.ListsWhereUniqueInput] = None,
          order: Optional[Union[types.ListsOrderByInput, List[types.ListsOrderByInput]]] = None,
      ) -> types.ListsCountAggregateOutput:
          ...
  
      def count(
          self,
          select: Optional[types.ListsCountAggregateInput] = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.ListsWhereInput] = None,
          cursor: Optional[types.ListsWhereUniqueInput] = None,
          order: Optional[Union[types.ListsOrderByInput, List[types.ListsOrderByInput]]] = None,
      ) -> Union[int, types.ListsCountAggregateOutput]:
          """Count the number of Lists records present in the database
  
          Parameters
          ----------
          select
              Select the Lists fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              Lists filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.ListsCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = Lists.prisma().count()
  
          # results: prisma.types.ListsCountAggregateOutput
          results = Lists.prisma().count(
              select={
                  '_all': True,
                  'floats': True,
              },
          )
          ```
          """
  
          # TODO: this selection building should be moved to the QueryBuilder
          #
          # note the distinction between checking for `not select` here and `select is None`
          # later is to handle the case that the given select dictionary is empty, this
          # is a limitation of our types.
          if not select:
              root_selection = ['_count { _all }']
          else:
  
              root_selection = [
                  '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
              ]
  
          if order is not None:
              warnings.warn(
                  'The `order` argument is redundant and will be removed in the next release',
                  DeprecationWarning,
                  stacklevel=2,
              )
  
          resp = self._client._execute(
              operation='query',
              method='aggregate',
              model='Lists',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=root_selection,
          )
  
          if select is None:
              return cast(int, resp['data']['result']['_count']['_all'])
          else:
              return cast(types.ListsCountAggregateOutput, resp['data']['result']['_count'])
  
      def delete_many(
          self,
          where: Optional[types.ListsWhereInput] = None
      ) -> int:
          """Delete multiple Lists records.
  
          Parameters
          ----------
          where
              Optional Lists filter to find the records to be deleted
  
          Returns
          -------
          int
              The total number of Lists records that were deleted
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # delete all Lists records
          total = Lists.prisma().delete_many()
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='Lists',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  class AActions:
      def __init__(self, client: 'Client', model: Type['models.A']) -> None:
          self._client = client
          self._model = model
  
      def query_raw(
          self,
          query: str,
          *args: Any,
      ) -> List['models.A']:
          """Execute a raw SQL query
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          List[prisma.models.A]
              The records returned by the SQL query
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          users = A.prisma().query_raw(
              'SELECT * FROM A WHERE email = $1',
              'bfjibceaec',
          )
          ```
          """
          return self._client.query_raw(query, *args, model=self._model)
  
      def query_first(
          self,
          query: str,
          *args: Any,
      ) -> Optional['models.A']:
          """Execute a raw SQL query, returning the first result
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          prisma.models.A
              The first record returned by the SQL query
          None
              The raw SQL query did not return any records
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          user = A.prisma().query_first(
              'SELECT * FROM A WHERE name = $1',
              'ibhgcdbgd',
          )
          ```
          """
          return self._client.query_first(query, *args, model=self._model)
  
      def create(
          self,
          data: types.ACreateInput,
          include: Optional[types.AInclude] = None
      ) -> 'models.A':
          """Create a new A record.
  
          Parameters
          ----------
          data
              A record data
          include
              Specifies which relations should be loaded on the returned A model
  
          Returns
          -------
          prisma.models.A
              The created A record
  
          Raises
          ------
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # create a A record from just the required fields
          a = A.prisma().create(
              data={
                  # data to create a A record
                  'email': 'badaffhddg',
                  'int': 1131525873,
                  'sInt': 210666198,
                  'bInt': 15312695316,
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='createOne',
              model='A',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      def create_many(
          self,
          data: List[types.ACreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          """Create multiple A records at once.
  
          This function is *not* available when using SQLite.
  
          Parameters
          ----------
          data
              List of A record data
          skip_duplicates
              Boolean flag for ignoring unique constraint errors
  
          Returns
          -------
          int
              The total number of records created
  
          Raises
          ------
          prisma.errors.UnsupportedDatabaseError
              Attempting to query when using SQLite
          prisma.errors.UniqueViolationError
              A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          total = A.prisma().create_many(
              data=[
                  {
                      # data to create a A record
                      'email': 'heffgjdei',
                      'int': 307876141,
                      'sInt': 1674049122,
                      'bInt': 18322255716,
                  },
                  {
                      # data to create a A record
                      'email': 'jfiahhbae',
                      'int': 1513050921,
                      'sInt': 204674734,
                      'bInt': 24811819956,
                  },
              ],
              skip_duplicates=True,
          )
          ```
          """
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = self._client._execute(
              operation='mutation',
              method='createMany',
              model='A',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def delete(
          self,
          where: types.AWhereUniqueInput,
          include: Optional[types.AInclude] = None
      ) -> Optional['models.A']:
          """Delete a single A record.
  
          Parameters
          ----------
          where
              A filter to select the record to be deleted, must be unique
          include
              Specifies which relations should be loaded on the returned A model
  
          Returns
          -------
          prisma.models.A
              The deleted A record
          None
              Could not find a record to delete
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          a = A.prisma().delete(
              where={
                  'email': 'bbidjbbjaa',
              },
          )
          ```
          """
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='A',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      def find_unique(
          self,
          where: types.AWhereUniqueInput,
          include: Optional[types.AInclude] = None
      ) -> Optional['models.A']:
          """Find a unique A record.
  
          Parameters
          ----------
          where
              A filter to find the record, must be unique
          include
              Specifies which relations should be loaded on the returned A model
  
          Returns
          -------
          prisma.models.A
              The found A record
          None
              No record matching the given input could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          a = A.prisma().find_unique(
              where={
                  'email': 'bfijhaejdd',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findUnique',
              model='A',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.AWhereInput] = None,
          cursor: Optional[types.AWhereUniqueInput] = None,
          include: Optional[types.AInclude] = None,
          order: Optional[Union[types.AOrderByInput, List[types.AOrderByInput]]] = None,
      ) -> List['models.A']:
          """Find multiple A records.
  
          An empty list is returned if no records could be found.
  
          Parameters
          ----------
          take
              Limit the maximum number of A records returned
          skip
              Ignore the first N results
          where
              A filter to select records
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned A model
          order
              Order the returned A records by any field
  
          Returns
          -------
          List[prisma.models.A]
              The list of all A records that could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the first 10 A records
          as = A.prisma().find_many(take=10)
  
          # find the first 5 A records ordered by the int field
          as = A.prisma().find_many(
              take=5,
              order={
                  'int': 'desc',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findMany',
              model='A',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [self._model.parse_obj(r) for r in resp['data']['result']]
  
      def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.AWhereInput] = None,
          cursor: Optional[types.AWhereUniqueInput] = None,
          include: Optional[types.AInclude] = None,
          order: Optional[Union[types.AOrderByInput, List[types.AOrderByInput]]] = None,
      ) -> Optional['models.A']:
          """Find a single A record.
  
          Parameters
          ----------
          skip
              Ignore the first N records
          where
              A filter to select the record
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned A model
          order
              Order the returned A records by any field
  
          Returns
          -------
          prisma.models.A
              The first A record found, matching the given arguments
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the second A record ordered by the sInt field
          a = A.prisma().find_first(
              skip=1,
              order={
                  'sInt': 'desc',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findFirst',
              model='A',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      def update(
          self,
          data: types.AUpdateInput,
          where: types.AWhereUniqueInput,
          include: Optional[types.AInclude] = None
      ) -> Optional['models.A']:
          """Update a single A record.
  
          Parameters
          ----------
          data
              A record data specifying what to update
          where
              A filter to select the unique record to create / update
          include
              Specifies which relations should be loaded on the returned A model
  
          Returns
          -------
          prisma.models.A
              The updated A record
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          a = A.prisma().update(
              where={
                  'email': 'bcedehfiji',
              },
              data={
                  # data to update the A record to
              },
          )
          ```
          """
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='A',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      def upsert(
          self,
          where: types.AWhereUniqueInput,
          data: types.AUpsertInput,
          include: Optional[types.AInclude] = None,
      ) -> 'models.A':
          """Updates an existing record or create a new one
  
          Parameters
          ----------
          where
              A filter to select the unique record to create / update
          data
              Data specifying what fields to set on create and update
          include
              Specifies which relations should be loaded on the returned A model
  
          Returns
          -------
          prisma.models.A
              The created or updated A record
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          a = A.prisma().upsert(
              where={
                  'email': 'bdgjicijhb',
              },
              data={
                  'create': {
                      'email': 'bdgjicijhb',
                      'int': 1513050921,
                      'sInt': 204674734,
                      'bInt': 24811819956,
                  },
                  'update': {
                      'int': 1513050921,
                      'sInt': 204674734,
                      'bInt': 24811819956,
                  },
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='A',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      def update_many(
          self,
          data: types.AUpdateManyMutationInput,
          where: types.AWhereInput,
      ) -> int:
          """Update multiple A records
  
          Parameters
          ----------
          data
              A data to update the selected A records to
          where
              Filter to select the A records to update
  
          Returns
          -------
          int
              The total number of A records that were updated
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # update all A records
          total = A.prisma().update_many(
              data={
                  'inc_int': 1678593480
              },
              where={}
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='updateMany',
              model='A',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      @overload
      def count(
          self,
          select: None = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.AWhereInput] = None,
          cursor: Optional[types.AWhereUniqueInput] = None,
          order: Optional[Union[types.AOrderByInput, List[types.AOrderByInput]]] = None,
      ) -> int:
          """Count the number of A records present in the database
  
          Parameters
          ----------
          select
              Select the A fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              A filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.ACountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = A.prisma().count()
  
          # results: prisma.types.ACountAggregateOutput
          results = A.prisma().count(
              select={
                  '_all': True,
                  'inc_sInt': True,
              },
          )
          ```
          """
  
  
      @overload
      def count(
          self,
          select: types.ACountAggregateInput,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.AWhereInput] = None,
          cursor: Optional[types.AWhereUniqueInput] = None,
          order: Optional[Union[types.AOrderByInput, List[types.AOrderByInput]]] = None,
      ) -> types.ACountAggregateOutput:
          ...
  
      def count(
          self,
          select: Optional[types.ACountAggregateInput] = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.AWhereInput] = None,
          cursor: Optional[types.AWhereUniqueInput] = None,
          order: Optional[Union[types.AOrderByInput, List[types.AOrderByInput]]] = None,
      ) -> Union[int, types.ACountAggregateOutput]:
          """Count the number of A records present in the database
  
          Parameters
          ----------
          select
              Select the A fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              A filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.ACountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = A.prisma().count()
  
          # results: prisma.types.ACountAggregateOutput
          results = A.prisma().count(
              select={
                  '_all': True,
                  'bInt': True,
              },
          )
          ```
          """
  
          # TODO: this selection building should be moved to the QueryBuilder
          #
          # note the distinction between checking for `not select` here and `select is None`
          # later is to handle the case that the given select dictionary is empty, this
          # is a limitation of our types.
          if not select:
              root_selection = ['_count { _all }']
          else:
  
              root_selection = [
                  '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
              ]
  
          if order is not None:
              warnings.warn(
                  'The `order` argument is redundant and will be removed in the next release',
                  DeprecationWarning,
                  stacklevel=2,
              )
  
          resp = self._client._execute(
              operation='query',
              method='aggregate',
              model='A',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=root_selection,
          )
  
          if select is None:
              return cast(int, resp['data']['result']['_count']['_all'])
          else:
              return cast(types.ACountAggregateOutput, resp['data']['result']['_count'])
  
      def delete_many(
          self,
          where: Optional[types.AWhereInput] = None
      ) -> int:
          """Delete multiple A records.
  
          Parameters
          ----------
          where
              Optional A filter to find the records to be deleted
  
          Returns
          -------
          int
              The total number of A records that were deleted
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # delete all A records
          total = A.prisma().delete_many()
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='A',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  class BActions:
      def __init__(self, client: 'Client', model: Type['models.B']) -> None:
          self._client = client
          self._model = model
  
      def query_raw(
          self,
          query: str,
          *args: Any,
      ) -> List['models.B']:
          """Execute a raw SQL query
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          List[prisma.models.B]
              The records returned by the SQL query
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          users = B.prisma().query_raw(
              'SELECT * FROM B WHERE id = $1',
              'eadfcbbcb',
          )
          ```
          """
          return self._client.query_raw(query, *args, model=self._model)
  
      def query_first(
          self,
          query: str,
          *args: Any,
      ) -> Optional['models.B']:
          """Execute a raw SQL query, returning the first result
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          prisma.models.B
              The first record returned by the SQL query
          None
              The raw SQL query did not return any records
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          user = B.prisma().query_first(
              'SELECT * FROM B WHERE float = $1',
              648760710.60732,
          )
          ```
          """
          return self._client.query_first(query, *args, model=self._model)
  
      def create(
          self,
          data: types.BCreateInput,
          include: Optional[types.BInclude] = None
      ) -> 'models.B':
          """Create a new B record.
  
          Parameters
          ----------
          data
              B record data
          include
              Specifies which relations should be loaded on the returned B model
  
          Returns
          -------
          prisma.models.B
              The created B record
  
          Raises
          ------
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # create a B record from just the required fields
          b = B.prisma().create(
              data={
                  # data to create a B record
                  'float': 1468890740.62903,
                  'd_float': 1214168082.89861,
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='createOne',
              model='B',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      def create_many(
          self,
          data: List[types.BCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          """Create multiple B records at once.
  
          This function is *not* available when using SQLite.
  
          Parameters
          ----------
          data
              List of B record data
          skip_duplicates
              Boolean flag for ignoring unique constraint errors
  
          Returns
          -------
          int
              The total number of records created
  
          Raises
          ------
          prisma.errors.UnsupportedDatabaseError
              Attempting to query when using SQLite
          prisma.errors.UniqueViolationError
              A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          total = B.prisma().create_many(
              data=[
                  {
                      # data to create a B record
                      'float': 658378208.95462,
                      'd_float': 1214809950.104782,
                  },
                  {
                      # data to create a B record
                      'float': 1302734860.89305,
                      'd_float': 280083306.54966,
                  },
              ],
              skip_duplicates=True,
          )
          ```
          """
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = self._client._execute(
              operation='mutation',
              method='createMany',
              model='B',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def delete(
          self,
          where: types.BWhereUniqueInput,
          include: Optional[types.BInclude] = None
      ) -> Optional['models.B']:
          """Delete a single B record.
  
          Parameters
          ----------
          where
              B filter to select the record to be deleted, must be unique
          include
              Specifies which relations should be loaded on the returned B model
  
          Returns
          -------
          prisma.models.B
              The deleted B record
          None
              Could not find a record to delete
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          b = B.prisma().delete(
              where={
                  'id': 'hghjaaai',
              },
          )
          ```
          """
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='B',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      def find_unique(
          self,
          where: types.BWhereUniqueInput,
          include: Optional[types.BInclude] = None
      ) -> Optional['models.B']:
          """Find a unique B record.
  
          Parameters
          ----------
          where
              B filter to find the record, must be unique
          include
              Specifies which relations should be loaded on the returned B model
  
          Returns
          -------
          prisma.models.B
              The found B record
          None
              No record matching the given input could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          b = B.prisma().find_unique(
              where={
                  'id': 'cajicjjdef',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findUnique',
              model='B',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.BWhereInput] = None,
          cursor: Optional[types.BWhereUniqueInput] = None,
          include: Optional[types.BInclude] = None,
          order: Optional[Union[types.BOrderByInput, List[types.BOrderByInput]]] = None,
      ) -> List['models.B']:
          """Find multiple B records.
  
          An empty list is returned if no records could be found.
  
          Parameters
          ----------
          take
              Limit the maximum number of B records returned
          skip
              Ignore the first N results
          where
              B filter to select records
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned B model
          order
              Order the returned B records by any field
  
          Returns
          -------
          List[prisma.models.B]
              The list of all B records that could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the first 10 B records
          bs = B.prisma().find_many(take=10)
  
          # find the first 5 B records ordered by the d_float field
          bs = B.prisma().find_many(
              take=5,
              order={
                  'd_float': 'desc',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findMany',
              model='B',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [self._model.parse_obj(r) for r in resp['data']['result']]
  
      def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.BWhereInput] = None,
          cursor: Optional[types.BWhereUniqueInput] = None,
          include: Optional[types.BInclude] = None,
          order: Optional[Union[types.BOrderByInput, List[types.BOrderByInput]]] = None,
      ) -> Optional['models.B']:
          """Find a single B record.
  
          Parameters
          ----------
          skip
              Ignore the first N records
          where
              B filter to select the record
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned B model
          order
              Order the returned B records by any field
  
          Returns
          -------
          prisma.models.B
              The first B record found, matching the given arguments
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the second B record ordered by the id field
          b = B.prisma().find_first(
              skip=1,
              order={
                  'id': 'desc',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findFirst',
              model='B',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      def update(
          self,
          data: types.BUpdateInput,
          where: types.BWhereUniqueInput,
          include: Optional[types.BInclude] = None
      ) -> Optional['models.B']:
          """Update a single B record.
  
          Parameters
          ----------
          data
              B record data specifying what to update
          where
              B filter to select the unique record to create / update
          include
              Specifies which relations should be loaded on the returned B model
  
          Returns
          -------
          prisma.models.B
              The updated B record
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          b = B.prisma().update(
              where={
                  'id': 'cefjaadec',
              },
              data={
                  # data to update the B record to
              },
          )
          ```
          """
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='B',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      def upsert(
          self,
          where: types.BWhereUniqueInput,
          data: types.BUpsertInput,
          include: Optional[types.BInclude] = None,
      ) -> 'models.B':
          """Updates an existing record or create a new one
  
          Parameters
          ----------
          where
              B filter to select the unique record to create / update
          data
              Data specifying what fields to set on create and update
          include
              Specifies which relations should be loaded on the returned B model
  
          Returns
          -------
          prisma.models.B
              The created or updated B record
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          b = B.prisma().upsert(
              where={
                  'id': 'ibbigdigd',
              },
              data={
                  'create': {
                      'id': 'ibbigdigd',
                      'float': 1302734860.89305,
                      'd_float': 280083306.54966,
                  },
                  'update': {
                      'float': 1302734860.89305,
                      'd_float': 280083306.54966,
                  },
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='B',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      def update_many(
          self,
          data: types.BUpdateManyMutationInput,
          where: types.BWhereInput,
      ) -> int:
          """Update multiple B records
  
          Parameters
          ----------
          data
              B data to update the selected B records to
          where
              Filter to select the B records to update
  
          Returns
          -------
          int
              The total number of B records that were updated
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # update all B records
          total = B.prisma().update_many(
              data={
                  'float': 1388801188.75257
              },
              where={}
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='updateMany',
              model='B',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      @overload
      def count(
          self,
          select: None = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.BWhereInput] = None,
          cursor: Optional[types.BWhereUniqueInput] = None,
          order: Optional[Union[types.BOrderByInput, List[types.BOrderByInput]]] = None,
      ) -> int:
          """Count the number of B records present in the database
  
          Parameters
          ----------
          select
              Select the B fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              B filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.BCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = B.prisma().count()
  
          # results: prisma.types.BCountAggregateOutput
          results = B.prisma().count(
              select={
                  '_all': True,
                  'd_float': True,
              },
          )
          ```
          """
  
  
      @overload
      def count(
          self,
          select: types.BCountAggregateInput,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.BWhereInput] = None,
          cursor: Optional[types.BWhereUniqueInput] = None,
          order: Optional[Union[types.BOrderByInput, List[types.BOrderByInput]]] = None,
      ) -> types.BCountAggregateOutput:
          ...
  
      def count(
          self,
          select: Optional[types.BCountAggregateInput] = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.BWhereInput] = None,
          cursor: Optional[types.BWhereUniqueInput] = None,
          order: Optional[Union[types.BOrderByInput, List[types.BOrderByInput]]] = None,
      ) -> Union[int, types.BCountAggregateOutput]:
          """Count the number of B records present in the database
  
          Parameters
          ----------
          select
              Select the B fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              B filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.BCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = B.prisma().count()
  
          # results: prisma.types.BCountAggregateOutput
          results = B.prisma().count(
              select={
                  '_all': True,
                  'id': True,
              },
          )
          ```
          """
  
          # TODO: this selection building should be moved to the QueryBuilder
          #
          # note the distinction between checking for `not select` here and `select is None`
          # later is to handle the case that the given select dictionary is empty, this
          # is a limitation of our types.
          if not select:
              root_selection = ['_count { _all }']
          else:
  
              root_selection = [
                  '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
              ]
  
          if order is not None:
              warnings.warn(
                  'The `order` argument is redundant and will be removed in the next release',
                  DeprecationWarning,
                  stacklevel=2,
              )
  
          resp = self._client._execute(
              operation='query',
              method='aggregate',
              model='B',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=root_selection,
          )
  
          if select is None:
              return cast(int, resp['data']['result']['_count']['_all'])
          else:
              return cast(types.BCountAggregateOutput, resp['data']['result']['_count'])
  
      def delete_many(
          self,
          where: Optional[types.BWhereInput] = None
      ) -> int:
          """Delete multiple B records.
  
          Parameters
          ----------
          where
              Optional B filter to find the records to be deleted
  
          Returns
          -------
          int
              The total number of B records that were deleted
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # delete all B records
          total = B.prisma().delete_many()
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='B',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  class CActions:
      def __init__(self, client: 'Client', model: Type['models.C']) -> None:
          self._client = client
          self._model = model
  
      def query_raw(
          self,
          query: str,
          *args: Any,
      ) -> List['models.C']:
          """Execute a raw SQL query
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          List[prisma.models.C]
              The records returned by the SQL query
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          users = C.prisma().query_raw(
              'SELECT * FROM C WHERE char = $1',
              'bbihggdcji',
          )
          ```
          """
          return self._client.query_raw(query, *args, model=self._model)
  
      def query_first(
          self,
          query: str,
          *args: Any,
      ) -> Optional['models.C']:
          """Execute a raw SQL query, returning the first result
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          prisma.models.C
              The first record returned by the SQL query
          None
              The raw SQL query did not return any records
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          user = C.prisma().query_first(
              'SELECT * FROM C WHERE v_char = $1',
              'hgjgibdgd',
          )
          ```
          """
          return self._client.query_first(query, *args, model=self._model)
  
      def create(
          self,
          data: types.CCreateInput,
          include: Optional[types.CInclude] = None
      ) -> 'models.C':
          """Create a new C record.
  
          Parameters
          ----------
          data
              C record data
          include
              Specifies which relations should be loaded on the returned C model
  
          Returns
          -------
          prisma.models.C
              The created C record
  
          Raises
          ------
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # create a C record from just the required fields
          c = C.prisma().create(
              data={
                  # data to create a C record
                  'char': 'bcbecjfice',
                  'v_char': 'bacbebhjjd',
                  'text': 'dfbfaddhe',
                  'bit': 'bdcbbieibf',
                  'v_bit': 'dgjhdcggi',
                  'uuid': 'bbjbcdfabd',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='createOne',
              model='C',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      def create_many(
          self,
          data: List[types.CCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          """Create multiple C records at once.
  
          This function is *not* available when using SQLite.
  
          Parameters
          ----------
          data
              List of C record data
          skip_duplicates
              Boolean flag for ignoring unique constraint errors
  
          Returns
          -------
          int
              The total number of records created
  
          Raises
          ------
          prisma.errors.UnsupportedDatabaseError
              Attempting to query when using SQLite
          prisma.errors.UniqueViolationError
              A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          total = C.prisma().create_many(
              data=[
                  {
                      # data to create a C record
                      'char': 'gchfgbcec',
                      'v_char': 'bihcjfcjah',
                      'text': 'bhjdcicaii',
                      'bit': 'bibedjhcej',
                      'v_bit': 'bjcdajabfa',
                      'uuid': 'bchhceeeff',
                  },
                  {
                      # data to create a C record
                      'char': 'bbgaifhdaa',
                      'v_char': 'dgbcdaegb',
                      'text': 'beagfbbjig',
                      'bit': 'beicihhijb',
                      'v_bit': 'fgggcdcjg',
                      'uuid': 'ccjbbjigf',
                  },
              ],
              skip_duplicates=True,
          )
          ```
          """
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = self._client._execute(
              operation='mutation',
              method='createMany',
              model='C',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def delete(
          self,
          where: types.CWhereUniqueInput,
          include: Optional[types.CInclude] = None
      ) -> Optional['models.C']:
          """Delete a single C record.
  
          Parameters
          ----------
          where
              C filter to select the record to be deleted, must be unique
          include
              Specifies which relations should be loaded on the returned C model
  
          Returns
          -------
          prisma.models.C
              The deleted C record
          None
              Could not find a record to delete
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          c = C.prisma().delete(
              where={
                  # C where unique filter
  
              },
          )
          ```
          """
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='C',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      def find_unique(
          self,
          where: types.CWhereUniqueInput,
          include: Optional[types.CInclude] = None
      ) -> Optional['models.C']:
          """Find a unique C record.
  
          Parameters
          ----------
          where
              C filter to find the record, must be unique
          include
              Specifies which relations should be loaded on the returned C model
  
          Returns
          -------
          prisma.models.C
              The found C record
          None
              No record matching the given input could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          c = C.prisma().find_unique(
              where={
                  # C where unique filter
  
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findUnique',
              model='C',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.CWhereInput] = None,
          cursor: Optional[types.CWhereUniqueInput] = None,
          include: Optional[types.CInclude] = None,
          order: Optional[Union[types.COrderByInput, List[types.COrderByInput]]] = None,
      ) -> List['models.C']:
          """Find multiple C records.
  
          An empty list is returned if no records could be found.
  
          Parameters
          ----------
          take
              Limit the maximum number of C records returned
          skip
              Ignore the first N results
          where
              C filter to select records
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned C model
          order
              Order the returned C records by any field
  
          Returns
          -------
          List[prisma.models.C]
              The list of all C records that could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the first 10 C records
          cs = C.prisma().find_many(take=10)
  
          # find the first 5 C records ordered by the text field
          cs = C.prisma().find_many(
              take=5,
              order={
                  'text': 'desc',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findMany',
              model='C',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [self._model.parse_obj(r) for r in resp['data']['result']]
  
      def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.CWhereInput] = None,
          cursor: Optional[types.CWhereUniqueInput] = None,
          include: Optional[types.CInclude] = None,
          order: Optional[Union[types.COrderByInput, List[types.COrderByInput]]] = None,
      ) -> Optional['models.C']:
          """Find a single C record.
  
          Parameters
          ----------
          skip
              Ignore the first N records
          where
              C filter to select the record
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned C model
          order
              Order the returned C records by any field
  
          Returns
          -------
          prisma.models.C
              The first C record found, matching the given arguments
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the second C record ordered by the bit field
          c = C.prisma().find_first(
              skip=1,
              order={
                  'bit': 'desc',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findFirst',
              model='C',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      def update(
          self,
          data: types.CUpdateInput,
          where: types.CWhereUniqueInput,
          include: Optional[types.CInclude] = None
      ) -> Optional['models.C']:
          """Update a single C record.
  
          Parameters
          ----------
          data
              C record data specifying what to update
          where
              C filter to select the unique record to create / update
          include
              Specifies which relations should be loaded on the returned C model
  
          Returns
          -------
          prisma.models.C
              The updated C record
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          c = C.prisma().update(
              where={
                  # C where unique filter
  
              },
              data={
                  # data to update the C record to
              },
          )
          ```
          """
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='C',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      def upsert(
          self,
          where: types.CWhereUniqueInput,
          data: types.CUpsertInput,
          include: Optional[types.CInclude] = None,
      ) -> 'models.C':
          """Updates an existing record or create a new one
  
          Parameters
          ----------
          where
              C filter to select the unique record to create / update
          data
              Data specifying what fields to set on create and update
          include
              Specifies which relations should be loaded on the returned C model
  
          Returns
          -------
          prisma.models.C
              The created or updated C record
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          c = C.prisma().upsert(
              where={
                  # C where unique filter
              },
              data={
                  'create': {
                      # C data to be set if the record does not exist
                  },
                  'update': {
                      # C data to be set if the record does exist
                  },
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='C',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      def update_many(
          self,
          data: types.CUpdateManyMutationInput,
          where: types.CWhereInput,
      ) -> int:
          """Update multiple C records
  
          Parameters
          ----------
          data
              C data to update the selected C records to
          where
              Filter to select the C records to update
  
          Returns
          -------
          int
              The total number of C records that were updated
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # update all C records
          total = C.prisma().update_many(
              data={
                  'v_bit': 'bhfaabbaha'
              },
              where={}
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='updateMany',
              model='C',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      @overload
      def count(
          self,
          select: None = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.CWhereInput] = None,
          cursor: Optional[types.CWhereUniqueInput] = None,
          order: Optional[Union[types.COrderByInput, List[types.COrderByInput]]] = None,
      ) -> int:
          """Count the number of C records present in the database
  
          Parameters
          ----------
          select
              Select the C fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              C filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.CCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = C.prisma().count()
  
          # results: prisma.types.CCountAggregateOutput
          results = C.prisma().count(
              select={
                  '_all': True,
                  'uuid': True,
              },
          )
          ```
          """
  
  
      @overload
      def count(
          self,
          select: types.CCountAggregateInput,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.CWhereInput] = None,
          cursor: Optional[types.CWhereUniqueInput] = None,
          order: Optional[Union[types.COrderByInput, List[types.COrderByInput]]] = None,
      ) -> types.CCountAggregateOutput:
          ...
  
      def count(
          self,
          select: Optional[types.CCountAggregateInput] = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.CWhereInput] = None,
          cursor: Optional[types.CWhereUniqueInput] = None,
          order: Optional[Union[types.COrderByInput, List[types.COrderByInput]]] = None,
      ) -> Union[int, types.CCountAggregateOutput]:
          """Count the number of C records present in the database
  
          Parameters
          ----------
          select
              Select the C fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              C filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.CCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = C.prisma().count()
  
          # results: prisma.types.CCountAggregateOutput
          results = C.prisma().count(
              select={
                  '_all': True,
                  'char': True,
              },
          )
          ```
          """
  
          # TODO: this selection building should be moved to the QueryBuilder
          #
          # note the distinction between checking for `not select` here and `select is None`
          # later is to handle the case that the given select dictionary is empty, this
          # is a limitation of our types.
          if not select:
              root_selection = ['_count { _all }']
          else:
  
              root_selection = [
                  '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
              ]
  
          if order is not None:
              warnings.warn(
                  'The `order` argument is redundant and will be removed in the next release',
                  DeprecationWarning,
                  stacklevel=2,
              )
  
          resp = self._client._execute(
              operation='query',
              method='aggregate',
              model='C',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=root_selection,
          )
  
          if select is None:
              return cast(int, resp['data']['result']['_count']['_all'])
          else:
              return cast(types.CCountAggregateOutput, resp['data']['result']['_count'])
  
      def delete_many(
          self,
          where: Optional[types.CWhereInput] = None
      ) -> int:
          """Delete multiple C records.
  
          Parameters
          ----------
          where
              Optional C filter to find the records to be deleted
  
          Returns
          -------
          int
              The total number of C records that were deleted
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # delete all C records
          total = C.prisma().delete_many()
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='C',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  class DActions:
      def __init__(self, client: 'Client', model: Type['models.D']) -> None:
          self._client = client
          self._model = model
  
      def query_raw(
          self,
          query: str,
          *args: Any,
      ) -> List['models.D']:
          """Execute a raw SQL query
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          List[prisma.models.D]
              The records returned by the SQL query
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          users = D.prisma().query_raw(
              'SELECT * FROM D WHERE id = $1',
              'ebajedhhf',
          )
          ```
          """
          return self._client.query_raw(query, *args, model=self._model)
  
      def query_first(
          self,
          query: str,
          *args: Any,
      ) -> Optional['models.D']:
          """Execute a raw SQL query, returning the first result
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          prisma.models.D
              The first record returned by the SQL query
          None
              The raw SQL query did not return any records
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          user = D.prisma().query_first(
              'SELECT * FROM D WHERE bool = $1',
              True,
          )
          ```
          """
          return self._client.query_first(query, *args, model=self._model)
  
      def create(
          self,
          data: types.DCreateInput,
          include: Optional[types.DInclude] = None
      ) -> 'models.D':
          """Create a new D record.
  
          Parameters
          ----------
          data
              D record data
          include
              Specifies which relations should be loaded on the returned D model
  
          Returns
          -------
          prisma.models.D
              The created D record
  
          Raises
          ------
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # create a D record from just the required fields
          d = D.prisma().create(
              data={
                  # data to create a D record
                  'bool': False,
                  'xml': 'biacbiieja',
                  'json_': Json({'cjejbgbff': True}),
                  'jsonb': Json({'fgeahddae': True}),
                  'binary': Base64.encode(b'diageigcf'),
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='createOne',
              model='D',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      def create_many(
          self,
          data: List[types.DCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          """Create multiple D records at once.
  
          This function is *not* available when using SQLite.
  
          Parameters
          ----------
          data
              List of D record data
          skip_duplicates
              Boolean flag for ignoring unique constraint errors
  
          Returns
          -------
          int
              The total number of records created
  
          Raises
          ------
          prisma.errors.UnsupportedDatabaseError
              Attempting to query when using SQLite
          prisma.errors.UniqueViolationError
              A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          total = D.prisma().create_many(
              data=[
                  {
                      # data to create a D record
                      'bool': True,
                      'xml': 'ibgebbjch',
                      'json_': Json({'baieajjiee': True}),
                      'jsonb': Json({'bahjhaccfd': True}),
                      'binary': Base64.encode(b'hffhfabhi'),
                  },
                  {
                      # data to create a D record
                      'bool': False,
                      'xml': 'cfjagbbae',
                      'json_': Json({'bbbfhdidef': True}),
                      'jsonb': Json({'bdadhibhec': True}),
                      'binary': Base64.encode(b'bfhdjaiejf'),
                  },
              ],
              skip_duplicates=True,
          )
          ```
          """
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = self._client._execute(
              operation='mutation',
              method='createMany',
              model='D',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def delete(
          self,
          where: types.DWhereUniqueInput,
          include: Optional[types.DInclude] = None
      ) -> Optional['models.D']:
          """Delete a single D record.
  
          Parameters
          ----------
          where
              D filter to select the record to be deleted, must be unique
          include
              Specifies which relations should be loaded on the returned D model
  
          Returns
          -------
          prisma.models.D
              The deleted D record
          None
              Could not find a record to delete
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          d = D.prisma().delete(
              where={
                  'id': 'bbjfijjadg',
              },
          )
          ```
          """
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='D',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      def find_unique(
          self,
          where: types.DWhereUniqueInput,
          include: Optional[types.DInclude] = None
      ) -> Optional['models.D']:
          """Find a unique D record.
  
          Parameters
          ----------
          where
              D filter to find the record, must be unique
          include
              Specifies which relations should be loaded on the returned D model
  
          Returns
          -------
          prisma.models.D
              The found D record
          None
              No record matching the given input could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          d = D.prisma().find_unique(
              where={
                  'id': 'hdjacbehh',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findUnique',
              model='D',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.DWhereInput] = None,
          cursor: Optional[types.DWhereUniqueInput] = None,
          include: Optional[types.DInclude] = None,
          order: Optional[Union[types.DOrderByInput, List[types.DOrderByInput]]] = None,
      ) -> List['models.D']:
          """Find multiple D records.
  
          An empty list is returned if no records could be found.
  
          Parameters
          ----------
          take
              Limit the maximum number of D records returned
          skip
              Ignore the first N results
          where
              D filter to select records
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned D model
          order
              Order the returned D records by any field
  
          Returns
          -------
          List[prisma.models.D]
              The list of all D records that could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the first 10 D records
          ds = D.prisma().find_many(take=10)
  
          # find the first 5 D records ordered by the xml field
          ds = D.prisma().find_many(
              take=5,
              order={
                  'xml': 'desc',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findMany',
              model='D',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [self._model.parse_obj(r) for r in resp['data']['result']]
  
      def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.DWhereInput] = None,
          cursor: Optional[types.DWhereUniqueInput] = None,
          include: Optional[types.DInclude] = None,
          order: Optional[Union[types.DOrderByInput, List[types.DOrderByInput]]] = None,
      ) -> Optional['models.D']:
          """Find a single D record.
  
          Parameters
          ----------
          skip
              Ignore the first N records
          where
              D filter to select the record
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned D model
          order
              Order the returned D records by any field
  
          Returns
          -------
          prisma.models.D
              The first D record found, matching the given arguments
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the second D record ordered by the json_ field
          d = D.prisma().find_first(
              skip=1,
              order={
                  'json_': 'desc',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findFirst',
              model='D',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      def update(
          self,
          data: types.DUpdateInput,
          where: types.DWhereUniqueInput,
          include: Optional[types.DInclude] = None
      ) -> Optional['models.D']:
          """Update a single D record.
  
          Parameters
          ----------
          data
              D record data specifying what to update
          where
              D filter to select the unique record to create / update
          include
              Specifies which relations should be loaded on the returned D model
  
          Returns
          -------
          prisma.models.D
              The updated D record
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          d = D.prisma().update(
              where={
                  'id': 'bhcccbeaba',
              },
              data={
                  # data to update the D record to
              },
          )
          ```
          """
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='D',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      def upsert(
          self,
          where: types.DWhereUniqueInput,
          data: types.DUpsertInput,
          include: Optional[types.DInclude] = None,
      ) -> 'models.D':
          """Updates an existing record or create a new one
  
          Parameters
          ----------
          where
              D filter to select the unique record to create / update
          data
              Data specifying what fields to set on create and update
          include
              Specifies which relations should be loaded on the returned D model
  
          Returns
          -------
          prisma.models.D
              The created or updated D record
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          d = D.prisma().upsert(
              where={
                  'id': 'bcgjbdgjdj',
              },
              data={
                  'create': {
                      'id': 'bcgjbdgjdj',
                      'bool': False,
                      'xml': 'cfjagbbae',
                      'json_': Json({'bbbfhdidef': True}),
                      'jsonb': Json({'bdadhibhec': True}),
                      'binary': Base64.encode(b'bfhdjaiejf'),
                  },
                  'update': {
                      'bool': False,
                      'xml': 'cfjagbbae',
                      'json_': Json({'bbbfhdidef': True}),
                      'jsonb': Json({'bdadhibhec': True}),
                      'binary': Base64.encode(b'bfhdjaiejf'),
                  },
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='D',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      def update_many(
          self,
          data: types.DUpdateManyMutationInput,
          where: types.DWhereInput,
      ) -> int:
          """Update multiple D records
  
          Parameters
          ----------
          data
              D data to update the selected D records to
          where
              Filter to select the D records to update
  
          Returns
          -------
          int
              The total number of D records that were updated
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # update all D records
          total = D.prisma().update_many(
              data={
                  'jsonb': Json({'fhdbhifae': True})
              },
              where={}
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='updateMany',
              model='D',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      @overload
      def count(
          self,
          select: None = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.DWhereInput] = None,
          cursor: Optional[types.DWhereUniqueInput] = None,
          order: Optional[Union[types.DOrderByInput, List[types.DOrderByInput]]] = None,
      ) -> int:
          """Count the number of D records present in the database
  
          Parameters
          ----------
          select
              Select the D fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              D filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.DCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = D.prisma().count()
  
          # results: prisma.types.DCountAggregateOutput
          results = D.prisma().count(
              select={
                  '_all': True,
                  'binary': True,
              },
          )
          ```
          """
  
  
      @overload
      def count(
          self,
          select: types.DCountAggregateInput,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.DWhereInput] = None,
          cursor: Optional[types.DWhereUniqueInput] = None,
          order: Optional[Union[types.DOrderByInput, List[types.DOrderByInput]]] = None,
      ) -> types.DCountAggregateOutput:
          ...
  
      def count(
          self,
          select: Optional[types.DCountAggregateInput] = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.DWhereInput] = None,
          cursor: Optional[types.DWhereUniqueInput] = None,
          order: Optional[Union[types.DOrderByInput, List[types.DOrderByInput]]] = None,
      ) -> Union[int, types.DCountAggregateOutput]:
          """Count the number of D records present in the database
  
          Parameters
          ----------
          select
              Select the D fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              D filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.DCountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = D.prisma().count()
  
          # results: prisma.types.DCountAggregateOutput
          results = D.prisma().count(
              select={
                  '_all': True,
                  'id': True,
              },
          )
          ```
          """
  
          # TODO: this selection building should be moved to the QueryBuilder
          #
          # note the distinction between checking for `not select` here and `select is None`
          # later is to handle the case that the given select dictionary is empty, this
          # is a limitation of our types.
          if not select:
              root_selection = ['_count { _all }']
          else:
  
              root_selection = [
                  '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
              ]
  
          if order is not None:
              warnings.warn(
                  'The `order` argument is redundant and will be removed in the next release',
                  DeprecationWarning,
                  stacklevel=2,
              )
  
          resp = self._client._execute(
              operation='query',
              method='aggregate',
              model='D',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=root_selection,
          )
  
          if select is None:
              return cast(int, resp['data']['result']['_count']['_all'])
          else:
              return cast(types.DCountAggregateOutput, resp['data']['result']['_count'])
  
      def delete_many(
          self,
          where: Optional[types.DWhereInput] = None
      ) -> int:
          """Delete multiple D records.
  
          Parameters
          ----------
          where
              Optional D filter to find the records to be deleted
  
          Returns
          -------
          int
              The total number of D records that were deleted
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # delete all D records
          total = D.prisma().delete_many()
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='D',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  class EActions:
      def __init__(self, client: 'Client', model: Type['models.E']) -> None:
          self._client = client
          self._model = model
  
      def query_raw(
          self,
          query: str,
          *args: Any,
      ) -> List['models.E']:
          """Execute a raw SQL query
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          List[prisma.models.E]
              The records returned by the SQL query
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          users = E.prisma().query_raw(
              'SELECT * FROM E WHERE id = $1',
              'beeacgfcej',
          )
          ```
          """
          return self._client.query_raw(query, *args, model=self._model)
  
      def query_first(
          self,
          query: str,
          *args: Any,
      ) -> Optional['models.E']:
          """Execute a raw SQL query, returning the first result
  
          Parameters
          ----------
          query
              The raw SQL query string to be executed
          *args
              Parameters to be passed to the SQL query, these MUST be used over
              string formatting to avoid an SQL injection vulnerability
  
          Returns
          -------
          prisma.models.E
              The first record returned by the SQL query
          None
              The raw SQL query did not return any records
  
          Raises
          ------
          prisma_errors.RawQueryError
              This could be due to invalid syntax, mismatched number of parameters or any other error
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          user = E.prisma().query_first(
              'SELECT * FROM E WHERE date = $1',
              datetime.datetime.utcnow(),
          )
          ```
          """
          return self._client.query_first(query, *args, model=self._model)
  
      def create(
          self,
          data: types.ECreateInput,
          include: Optional[types.EInclude] = None
      ) -> 'models.E':
          """Create a new E record.
  
          Parameters
          ----------
          data
              E record data
          include
              Specifies which relations should be loaded on the returned E model
  
          Returns
          -------
          prisma.models.E
              The created E record
  
          Raises
          ------
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # create a E record from just the required fields
          e = E.prisma().create(
              data={
                  # data to create a E record
                  'date': datetime.datetime.utcnow(),
                  'time': datetime.datetime.utcnow(),
                  'ts': datetime.datetime.utcnow(),
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='createOne',
              model='E',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      def create_many(
          self,
          data: List[types.ECreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> int:
          """Create multiple E records at once.
  
          This function is *not* available when using SQLite.
  
          Parameters
          ----------
          data
              List of E record data
          skip_duplicates
              Boolean flag for ignoring unique constraint errors
  
          Returns
          -------
          int
              The total number of records created
  
          Raises
          ------
          prisma.errors.UnsupportedDatabaseError
              Attempting to query when using SQLite
          prisma.errors.UniqueViolationError
              A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          total = E.prisma().create_many(
              data=[
                  {
                      # data to create a E record
                      'date': datetime.datetime.utcnow(),
                      'time': datetime.datetime.utcnow(),
                      'ts': datetime.datetime.utcnow(),
                  },
                  {
                      # data to create a E record
                      'date': datetime.datetime.utcnow(),
                      'time': datetime.datetime.utcnow(),
                      'ts': datetime.datetime.utcnow(),
                  },
              ],
              skip_duplicates=True,
          )
          ```
          """
          if self._client._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          resp = self._client._execute(
              operation='mutation',
              method='createMany',
              model='E',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      def delete(
          self,
          where: types.EWhereUniqueInput,
          include: Optional[types.EInclude] = None
      ) -> Optional['models.E']:
          """Delete a single E record.
  
          Parameters
          ----------
          where
              E filter to select the record to be deleted, must be unique
          include
              Specifies which relations should be loaded on the returned E model
  
          Returns
          -------
          prisma.models.E
              The deleted E record
          None
              Could not find a record to delete
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          e = E.prisma().delete(
              where={
                  'id': 'bbifhdiicc',
              },
          )
          ```
          """
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='deleteOne',
                  model='E',
                  arguments={
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      def find_unique(
          self,
          where: types.EWhereUniqueInput,
          include: Optional[types.EInclude] = None
      ) -> Optional['models.E']:
          """Find a unique E record.
  
          Parameters
          ----------
          where
              E filter to find the record, must be unique
          include
              Specifies which relations should be loaded on the returned E model
  
          Returns
          -------
          prisma.models.E
              The found E record
          None
              No record matching the given input could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          e = E.prisma().find_unique(
              where={
                  'id': 'bgjeccejad',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findUnique',
              model='E',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      def find_many(
          self,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.EWhereInput] = None,
          cursor: Optional[types.EWhereUniqueInput] = None,
          include: Optional[types.EInclude] = None,
          order: Optional[Union[types.EOrderByInput, List[types.EOrderByInput]]] = None,
      ) -> List['models.E']:
          """Find multiple E records.
  
          An empty list is returned if no records could be found.
  
          Parameters
          ----------
          take
              Limit the maximum number of E records returned
          skip
              Ignore the first N results
          where
              E filter to select records
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned E model
          order
              Order the returned E records by any field
  
          Returns
          -------
          List[prisma.models.E]
              The list of all E records that could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the first 10 E records
          es = E.prisma().find_many(take=10)
  
          # find the first 5 E records ordered by the time field
          es = E.prisma().find_many(
              take=5,
              order={
                  'time': 'desc',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findMany',
              model='E',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include,
              },
          )
          return [self._model.parse_obj(r) for r in resp['data']['result']]
  
      def find_first(
          self,
          skip: Optional[int] = None,
          where: Optional[types.EWhereInput] = None,
          cursor: Optional[types.EWhereUniqueInput] = None,
          include: Optional[types.EInclude] = None,
          order: Optional[Union[types.EOrderByInput, List[types.EOrderByInput]]] = None,
      ) -> Optional['models.E']:
          """Find a single E record.
  
          Parameters
          ----------
          skip
              Ignore the first N records
          where
              E filter to select the record
          cursor
              Specifies the position in the list to start returning results from, (typically an ID field)
          include
              Specifies which relations should be loaded on the returned E model
          order
              Order the returned E records by any field
  
          Returns
          -------
          prisma.models.E
              The first E record found, matching the given arguments
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # find the second E record ordered by the ts field
          e = E.prisma().find_first(
              skip=1,
              order={
                  'ts': 'desc',
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='query',
              method='findFirst',
              model='E',
              arguments={
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
                  'include': include
              },
          )
          result = resp['data']['result']
          if result is None:
              return None
          return self._model.parse_obj(result)
  
      def update(
          self,
          data: types.EUpdateInput,
          where: types.EWhereUniqueInput,
          include: Optional[types.EInclude] = None
      ) -> Optional['models.E']:
          """Update a single E record.
  
          Parameters
          ----------
          data
              E record data specifying what to update
          where
              E filter to select the unique record to create / update
          include
              Specifies which relations should be loaded on the returned E model
  
          Returns
          -------
          prisma.models.E
              The updated E record
          None
              No record could be found
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          e = E.prisma().update(
              where={
                  'id': 'bjagdgabbg',
              },
              data={
                  # data to update the E record to
              },
          )
          ```
          """
          try:
              resp = self._client._execute(
                  operation='mutation',
                  method='updateOne',
                  model='E',
                  arguments={
                      'data': data,
                      'where': where,
                      'include': include,
                  },
              )
          except errors.RecordNotFoundError:
              return None
  
          return self._model.parse_obj(resp['data']['result'])
  
      def upsert(
          self,
          where: types.EWhereUniqueInput,
          data: types.EUpsertInput,
          include: Optional[types.EInclude] = None,
      ) -> 'models.E':
          """Updates an existing record or create a new one
  
          Parameters
          ----------
          where
              E filter to select the unique record to create / update
          data
              Data specifying what fields to set on create and update
          include
              Specifies which relations should be loaded on the returned E model
  
          Returns
          -------
          prisma.models.E
              The created or updated E record
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
          prisma.errors.MissingRequiredValueError
              Value is required but was not found
  
          Example
          -------
          ```py
          e = E.prisma().upsert(
              where={
                  'id': 'bjbbcffdij',
              },
              data={
                  'create': {
                      'id': 'bjbbcffdij',
                      'date': datetime.datetime.utcnow(),
                      'time': datetime.datetime.utcnow(),
                      'ts': datetime.datetime.utcnow(),
                  },
                  'update': {
                      'date': datetime.datetime.utcnow(),
                      'time': datetime.datetime.utcnow(),
                      'ts': datetime.datetime.utcnow(),
                  },
              },
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='upsertOne',
              model='E',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
          return self._model.parse_obj(resp['data']['result'])
  
      def update_many(
          self,
          data: types.EUpdateManyMutationInput,
          where: types.EWhereInput,
      ) -> int:
          """Update multiple E records
  
          Parameters
          ----------
          data
              E data to update the selected E records to
          where
              Filter to select the E records to update
  
          Returns
          -------
          int
              The total number of E records that were updated
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # update all E records
          total = E.prisma().update_many(
              data={
                  'id': 'begcgchdi'
              },
              where={}
          )
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='updateMany',
              model='E',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
      @overload
      def count(
          self,
          select: None = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.EWhereInput] = None,
          cursor: Optional[types.EWhereUniqueInput] = None,
          order: Optional[Union[types.EOrderByInput, List[types.EOrderByInput]]] = None,
      ) -> int:
          """Count the number of E records present in the database
  
          Parameters
          ----------
          select
              Select the E fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              E filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.ECountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = E.prisma().count()
  
          # results: prisma.types.ECountAggregateOutput
          results = E.prisma().count(
              select={
                  '_all': True,
                  'date': True,
              },
          )
          ```
          """
  
  
      @overload
      def count(
          self,
          select: types.ECountAggregateInput,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.EWhereInput] = None,
          cursor: Optional[types.EWhereUniqueInput] = None,
          order: Optional[Union[types.EOrderByInput, List[types.EOrderByInput]]] = None,
      ) -> types.ECountAggregateOutput:
          ...
  
      def count(
          self,
          select: Optional[types.ECountAggregateInput] = None,
          take: Optional[int] = None,
          skip: Optional[int] = None,
          where: Optional[types.EWhereInput] = None,
          cursor: Optional[types.EWhereUniqueInput] = None,
          order: Optional[Union[types.EOrderByInput, List[types.EOrderByInput]]] = None,
      ) -> Union[int, types.ECountAggregateOutput]:
          """Count the number of E records present in the database
  
          Parameters
          ----------
          select
              Select the E fields to be counted
          take
              Limit the maximum result
          skip
              Ignore the first N records
          where
              E filter to find records
          cursor
              Specifies the position in the list to start counting results from, (typically an ID field)
          order
              This parameter is deprecated and will be removed in a future release
  
          Returns
          -------
          int
              The total number of records found, returned if `select` is not given
  
          prisma.types.ECountAggregateOutput
              Data returned when `select` is used, the fields present in this dictionary will
              match the fields passed in the `select` argument
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # total: int
          total = E.prisma().count()
  
          # results: prisma.types.ECountAggregateOutput
          results = E.prisma().count(
              select={
                  '_all': True,
                  'time': True,
              },
          )
          ```
          """
  
          # TODO: this selection building should be moved to the QueryBuilder
          #
          # note the distinction between checking for `not select` here and `select is None`
          # later is to handle the case that the given select dictionary is empty, this
          # is a limitation of our types.
          if not select:
              root_selection = ['_count { _all }']
          else:
  
              root_selection = [
                  '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
              ]
  
          if order is not None:
              warnings.warn(
                  'The `order` argument is redundant and will be removed in the next release',
                  DeprecationWarning,
                  stacklevel=2,
              )
  
          resp = self._client._execute(
              operation='query',
              method='aggregate',
              model='E',
              arguments={
                  'take': take,
                  'skip': skip,
                  'where': where,
                  'order_by': order,
                  'cursor': cursor,
              },
              root_selection=root_selection,
          )
  
          if select is None:
              return cast(int, resp['data']['result']['_count']['_all'])
          else:
              return cast(types.ECountAggregateOutput, resp['data']['result']['_count'])
  
      def delete_many(
          self,
          where: Optional[types.EWhereInput] = None
      ) -> int:
          """Delete multiple E records.
  
          Parameters
          ----------
          where
              Optional E filter to find the records to be deleted
  
          Returns
          -------
          int
              The total number of E records that were deleted
  
          Raises
          ------
          prisma.errors.PrismaError
              Catch all for every exception raised by Prisma Client Python
  
          Example
          -------
          ```py
          # delete all E records
          total = E.prisma().delete_many()
          ```
          """
          resp = self._client._execute(
              operation='mutation',
              method='deleteMany',
              model='E',
              arguments={'where': where},
              root_selection=['count'],
          )
          return int(resp['data']['result']['count'])
  
  
  from . import models
  
  '
---
# name: test_sync[builder.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Callable,
      Generic,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  from typing_extensions import TypedDict, Literal
  
  # -- template builder.py.jinja --
  
  # TODO: the QueryBuilder should validate and add type information context.
  #       currently we just naively iterate through arguments and encode them
  #       using standard json when we don't have any special casing for it.
  #       this makes it more difficult to add support for non-standard types
  #       such as the `Json` type.
  # TODO: optimise for performance (switch to c / cython?)
  # TODO: pass context around differently, relying on the builder instance is
  #       not ideal, context should be local to each node
  
  
  import json
  import logging
  import inspect
  from textwrap import indent
  from datetime import timezone
  from abc import abstractmethod, ABC
  from functools import singledispatch
  
  from . import fields
  from .types import Serializable
  from .errors import UnknownModelError, UnknownRelationalFieldError
  from ._constants import QUERY_BUILDER_ALIASES
  
  
  log: logging.Logger = logging.getLogger(__name__)
  
  ChildType = Union['AbstractNode', str]
  
  
  DEFAULT_FIELDS_MAPPING: Dict[str, List[str]] = {
      'Post': [
          'id',
          'created_at',
          'title',
          'content',
          'published',
          'author_id',
      ],
      'User': [
          'id',
          'email',
          'int',
          'optional_int',
          'float',
          'optional_float',
          'string',
          'optional_string',
          'enum',
          'optional_enum',
          'boolean',
          'optional_boolean',
      ],
      'M': [
          'id',
          'int',
          'optional_int',
          'float',
          'optional_float',
          'string',
          'optional_string',
          'enum',
          'optional_enum',
          'boolean',
          'optional_boolean',
      ],
      'N': [
          'id',
          'int',
          'optional_int',
          'float',
          'optional_float',
          'string',
          'optional_string',
          'json_',
          'optional_json',
          'enum',
          'optional_enum',
          'boolean',
          'optional_boolean',
      ],
      'OneOptional': [
          'id',
          'int',
          'optional_int',
          'float',
          'optional_float',
          'string',
          'optional_string',
          'enum',
          'optional_enum',
          'boolean',
          'optional_boolean',
      ],
      'ManyRequired': [
          'id',
          'one_optional_id',
          'int',
          'optional_int',
          'float',
          'optional_float',
          'string',
          'optional_string',
          'enum',
          'optional_enum',
          'boolean',
          'optional_boolean',
      ],
      'Lists': [
          'id',
          'strings',
          'bytes',
          'dates',
          'bools',
          'ints',
          'floats',
          'bigints',
          'json_objects',
      ],
      'A': [
          'email',
          'name',
          'int',
          'sInt',
          'inc_int',
          'inc_sInt',
          'bInt',
          'inc_bInt',
      ],
      'B': [
          'id',
          'float',
          'd_float',
      ],
      'C': [
          'char',
          'v_char',
          'text',
          'bit',
          'v_bit',
          'uuid',
      ],
      'D': [
          'id',
          'bool',
          'xml',
          'json_',
          'jsonb',
          'binary',
      ],
      'E': [
          'id',
          'date',
          'time',
          'ts',
      ],
  }
  
  RELATIONAL_FIELD_MAPPINGS: Dict[str, Dict[str, str]] = {
      'Post': {
          'author': 'User',
      },
      'User': {
          'posts': 'Post',
      },
      'M': {
          'n': 'N',
      },
      'N': {
          'm': 'M',
      },
      'OneOptional': {
          'many': 'ManyRequired',
      },
      'ManyRequired': {
          'one': 'OneOptional',
      },
      'Lists': {
      },
      'A': {
      },
      'B': {
      },
      'C': {
      },
      'D': {
      },
      'E': {
      },
  }
  
  
  class QueryBuilder:
      # prisma method
      method: str
  
      # GraphQL operation
      operation: str
  
      # prisma model
      model: Optional[str]
  
      # mapping of relational fields to include in the result
      include: Optional[Dict[str, Any]]
  
      # arguments to pass to the query
      arguments: Dict[str, Any]
  
      # list of fields to select
      root_selection: Optional[List[str]]
  
      def __init__(
          self,
          *,
          method: str,
          operation: str,
          arguments: Dict[str, Any],
          model: Optional[str] = None,
          root_selection: Optional[List[str]] = None
      ) -> None:
          self.model = model
          self.method = method
          self.operation = operation
          self.root_selection = root_selection
          self.arguments = args = self._transform_aliases(arguments)
          self.include = args.pop('include', None)
  
      def build(self) -> str:
          """Build the payload that should be sent to the QueryEngine"""
          data = {
              'variables': {},
              'operation_name': self.operation,
              'query': self.build_query(),
          }
          return dumps(data)
  
      def build_query(self) -> str:
          """Build the GraphQL query
  
          Example query:
  
          query {
            result: findUniqueUser
            (
              where: {
                id: "ckq23ky3003510r8zll5m2hma"
              }
            )
            {
              id
              name
              profile {
                id
                user_id
                bio
              }
            }
          }
          """
          query = self._create_root_node().render()
          log.debug('Generated query: \n%s', query)
          return query
  
      def _create_root_node(self) -> 'RootNode':
          root = RootNode(builder=self)
          root.add(ResultNode.create(self))
          root.add(
              Selection.create(
                  self,
                  model=self.model,
                  include=self.include,
                  root_selection=self.root_selection,
              )
          )
          return root
  
      def get_default_fields(self, model: str) -> List[str]:
          """Returns a list of all the scalar fields of a model
  
          Raises UnknownModelError if the current model cannot be found.
          """
          try:
              return DEFAULT_FIELDS_MAPPING[model].copy()
          except KeyError as exc:
              raise UnknownModelError(model) from exc
  
      def get_relational_model(self, current_model: str, field: str) -> str:
          """Returns the model that the field is related to.
  
          Raises UnknownModelError if the current model is invalid.
          Raises UnknownRelationalFieldError if the field does not exist.
          """
          try:
              mappings = RELATIONAL_FIELD_MAPPINGS[current_model]
          except KeyError as exc:
              raise UnknownModelError(current_model) from exc
  
          try:
              return mappings[field]
          except KeyError as exc:
              raise UnknownRelationalFieldError(model=current_model, field=field) from exc
  
      def _transform_aliases(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
          """Transform dict keys to match global aliases
  
          e.g. order_by -> orderBy
          """
          transformed = dict()
          for key, value in arguments.items():
              alias = QUERY_BUILDER_ALIASES.get(key, key)
              if isinstance(value, dict):
                  transformed[alias] = self._transform_aliases(arguments=value)
              else:
                  transformed[alias] = value
          return transformed
  
  
  class AbstractNode(ABC):
      @abstractmethod
      def render(self) -> Optional[str]:
          """Render the node to a string
  
          None is returned if the node should not be rendered.
          """
          ...
  
      def should_render(self) -> bool:
          """If True, rendering of the node is skipped
  
          Useful for some nodes as they should only actually
          be rendered if they have any children.
          """
          return True
  
  
  class Node(AbstractNode):
      """Base node handling rendering of child nodes"""
      joiner: str
      indent: str
      builder: QueryBuilder
      children: List[ChildType]
  
      def __init__(
          self,
          builder: QueryBuilder,
          *,
          joiner: str = '\n',
          indent: str = '  ',
          children: Optional[List[ChildType]] = None
      ) -> None:
          self.builder = builder
          self.joiner = joiner
          self.indent = indent
          self.children = children if children is not None else []
  
      def enter(self) -> Optional[str]:
          """Get the string used to enter the node.
  
          This string will be rendered *before* the children.
          """
          return None
  
      def depart(self) -> Optional[str]:
          """Get the string used to depart the node.
  
          This string will be rendered *after* the children.
          """
          return None
  
      def render(self) -> Optional[str]:
          """Render the node and it's children and to string.
  
          Rendering a node involves 4 steps:
  
          1. Entering the node
          2. Rendering it's children
          3. Departing the node
          4. Joining the previous steps together into a single string
          """
          if not self.should_render():
              return None
  
          strings: List[str] = []
          entered = self.enter()
          if entered is not None:
              strings.append(entered)
  
          for child in self.children:
              content: Optional[str] = None
  
              if isinstance(child, str):
                  content = child
              else:
                  content = child.render()
  
              if content:
                  strings.append(indent(content, self.indent))
  
          departed = self.depart()
          if departed is not None:
              strings.append(departed)
  
          return self.joiner.join(strings)
  
      def add(self, child: ChildType) -> None:
          """Add a child"""
          self.children.append(child)
  
      def create_children(self) -> List[ChildType]:
          """Create the node's children
  
          If children are passed to the constructor, the children
          returned from this method are used to extend the already
          set children.
          """
          return []
  
      @classmethod
      def create(cls, builder: Optional[QueryBuilder] = None, **kwargs: Any) -> 'Node':
          """Create the node and its children
  
          This is useful for subclasses that add extra attributes in __init__
          """
          kwargs.setdefault('builder', builder)
          node = cls(**kwargs)
          node.children.extend(node.create_children())
          return node
  
  
  class RootNode(Node):
      """Rendered node examples:
  
      query {
          <children>
      }
  
      or
  
      mutation {
          <children>
      }
      """
  
      def enter(self) -> str:
          return f'{self.builder.operation} {{'
  
      def depart(self) -> str:
          return '}'
  
      def render(self) -> str:
          content = super().render()
          if not content:  # pragma: no cover
              # this should never happen.
              # render() is typed to return None if the node
              # should not be rendered but as this node will
              # always be rendered it should always return
              # a non-empty string.
              raise RuntimeError('Could not generate query.')
          return content
  
  
  class ResultNode(Node):
      """Rendered node examples:
  
      result: findUniqueUser
          <children>
  
      or
  
      result: executeRaw
          <children>
      """
      def __init__(self, indent: str = '', **kwargs: Any) -> None:
          super().__init__(indent=indent, **kwargs)
  
      def enter(self) -> str:
          model = self.builder.model
          if model is not None:
              return f'result: {self.builder.method}{model}'
  
          return f'result: {self.builder.method}'
  
      def depart(self) -> Optional[str]:
          return None
  
      def create_children(self) -> List[ChildType]:
          return [
              Arguments.create(
                  self.builder,
                  arguments=self.builder.arguments,
              )
          ]
  
  
  class Arguments(Node):
      """Rendered node example:
  
      (
          key1: "1"
          key2: "[\"John\",\"123\"]"
          key3: true
          key4: {
              data: true
          }
      )
      """
      arguments: Dict[str, Any]
  
      def __init__(self, arguments: Dict[str, Any], **kwargs: Any) -> None:
          super().__init__(**kwargs)
          self.arguments = arguments
  
      def should_render(self) -> bool:
          return bool(self.children)
  
      def enter(self) -> str:
          return '('
  
      def depart(self) -> str:
          return ')'
  
      def create_children(self, arguments: Optional[Dict[str, Any]] = None) -> List[ChildType]:
          children: List[ChildType] = []
  
          for arg, value in self.arguments.items():
              if value is None:
                  # ignore None values for convenience
                  continue
  
              if isinstance(value, dict):
                  children.append(
                      Key(arg, node=Data.create(self.builder, data=value))
                  )
              elif isinstance(value, (list, tuple, set)):
                  # NOTE: we have a special case for execute_raw and query_raw
                  # here as prisma expects parameters to be passed as a json string
                  # value like "[\"John\",\"123\"]", and we encode twice to ensure
                  # that only the inner quotes are escaped
                  if self.builder.method in {'queryRaw', 'executeRaw'}:
                      children.append(f'{arg}: {dumps(dumps(value))}')
                  else:
                      children.append(Key(arg, node=ListNode.create(self.builder, data=value)))
              else:
                  children.append(f'{arg}: {dumps(value)}')
  
          return children
  
  
  class Data(Node):
      """Rendered node example:
  
      {
          key1: "a"
          key2: 3
          key3: [
              "name"
          ]
      }
      """
      data: Mapping[str, Any]
  
      def __init__(
          self,
          data: Mapping[str, Any],
          **kwargs: Any
      ) -> None:
          super().__init__(**kwargs)
          self.data = data
  
      def enter(self) -> str:
          return '{'
  
      def depart(self) -> str:
          return '}'
  
      def create_children(self) -> List[ChildType]:
          children: List[ChildType] = []
  
          for key, value in self.data.items():
              if isinstance(value, dict):
                  children.append(
                      Key(key, node=Data.create(self.builder, data=value))
                  )
              elif isinstance(value, (list, tuple, set)):
                  children.append(
                      Key(key, node=ListNode.create(self.builder, data=value))
                  )
              else:
                  children.append(f'{key}: {dumps(value)}')
  
          return children
  
  
  class ListNode(Node):
      data: Iterable[Any]
  
      def __init__(self, data: Iterable[Any], joiner: str = ',\n', **kwargs: Any) -> None:
          super().__init__(joiner=joiner, **kwargs)
          self.data = data
  
      def enter(self) -> str:
          return '['
  
      def depart(self) -> str:
          return ']'
  
      def create_children(self) -> List[ChildType]:
          children: List[ChildType] = []
  
          for item in self.data:
              if isinstance(item, dict):
                  children.append(Data.create(self.builder, data=item))
              else:
                  children.append(dumps(item))
  
          return children
  
  
  class Selection(Node):
      """Represents field selections
  
      Example no include:
  
      {
          id
          name
      }
  
      Example include={'posts': True}
  
      {
          id
          name
          posts {
              id
              title
          }
      }
  
      Example include={'posts': {'where': {'title': {'contains': 'Test'}}}}
  
      {
          id
          name
          posts(
              where: {
                  title: {
                      contains: 'Test'
                  }
              }
          )
          {
              id
              title
          }
      }
      """
      model: Optional[str]
      include: Optional[Dict[str, Any]]
      root_selection: Optional[List[str]]
  
      def __init__(
          self,
          model: Optional[str] = None,
          include: Optional[Dict[str, Any]] = None,
          root_selection: Optional[List[str]] = None,
          **kwargs: Any
      ) -> None:
          super().__init__(**kwargs)
          self.model = model
          self.include = include
          self.root_selection = root_selection
  
      def should_render(self) -> bool:
          return bool(self.children)
  
      def enter(self) -> str:
          return '{'
  
      def depart(self) -> str:
          return '}'
  
      def create_children(self) -> List[ChildType]:
          model = self.model
          include = self.include
          builder = self.builder
          children: List[ChildType] = []
  
          # root_selection, if present overrides the default fields
          # for a model as it is used by methods such as count()
          # that do not support returning model fields
          root_selection = self.root_selection
          if root_selection is not None:
              children.extend(root_selection)
          elif model is not None:
              children.extend(builder.get_default_fields(model))
  
          if include is not None:
              if model is None:
                  raise ValueError('Cannot include fields when model is None.')
  
              for key, value in include.items():
                  if value is True:
                      # e.g. posts { post_fields }
                      children.append(
                          Key(
                              key,
                              sep=' ',
                              node=Selection.create(
                                  builder,
                                  include=None,
                                  model=builder.get_relational_model(
                                      current_model=model, field=key
                                  ),
                              ),
                          )
                      )
                  elif isinstance(value, dict):
                      # e.g. given {'posts': {where': {'published': True}}} return
                      # posts( where: { published: true }) { post_fields }
                      args = value.copy()
                      nested_include = args.pop('include', None)
                      children.extend(
                          [
                              Key(
                                  key,
                                  sep='',
                                  node=Arguments.create(
                                      builder, arguments=args
                                  ),
                              ),
                              Selection.create(
                                  builder,
                                  include=nested_include,
                                  model=builder.get_relational_model(
                                      current_model=model, field=key
                                  ),
                              ),
                          ]
                      )
                  elif value is False:
                      continue
                  else:
                      raise TypeError(
                          f'Expected `bool` or `dict` include value but got {type(value)} instead.'
                      )
  
          return children
  
  
  class Key(AbstractNode):
      """Node for rendering a child node with a prefixed key"""
      key: str
      sep: str
      node: Node
  
      def __init__(self, key: str, node: Node, sep: str = ': ') -> None:
          self.key = key
          self.node = node
          self.sep = sep
  
      def render(self) -> str:
          content = self.node.render()
          if content:
              return f'{self.key}{self.sep}{content}'
          return f'{self.key}{self.sep}'
  
  
  @singledispatch
  def serializer(obj: Any) -> Serializable:
      """Single dispatch generic function for serializing objects to JSON"""
      if inspect.isclass(obj):
          typ = obj
      else:
          typ = type(obj)
  
      raise TypeError(f'Type {typ} not serializable')
  
  
  @serializer.register(datetime.datetime)
  def serialize_datetime(dt: datetime.datetime) -> str:
      """Format a datetime object to an ISO8601 string with a timezone.
  
      This assumes naive datetime objects are in UTC.
      """
      if dt.tzinfo is None:
          dt = dt.replace(tzinfo=timezone.utc)
      elif dt.tzinfo != timezone.utc:
          dt = dt.astimezone(timezone.utc)
  
      return dt.isoformat()
  
  
  @serializer.register(fields.Json)
  def serialize_json(obj: fields.Json) -> str:
      """Serialize a Json wrapper to a json string.
  
      This is used as a hook to override our default behaviour when building
      queries which would treat data like {'hello': 'world'} as a Data node
      when we instead want it to be rendered as a raw json string.
  
      This should only be used for fields that are of the `Json` type.
      """
      return dumps(obj.data)
  
  
  @serializer.register(fields.Base64)
  def serialize_base64(obj: fields.Base64) -> str:
      """Serialize a Base64 wrapper object to raw binary data"""
      return str(obj)
  
  
  def dumps(obj: Any, **kwargs: Any) -> str:
      kwargs.setdefault('default', serializer)
      kwargs.setdefault('ensure_ascii', False)
      return json.dumps(obj, **kwargs)
  
  # black does not respect the fmt: off comment without this
  # fmt: on
  
  '
---
# name: test_sync[client.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Callable,
      Generic,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  from typing_extensions import TypedDict, Literal
  
  # -- template client.py.jinja --
  from types import TracebackType
  
  from . import types, models, errors, actions
  from ._types import BaseModelT
  from .engine import AbstractEngine, QueryEngine
  from .builder import QueryBuilder
  
  
  __all__ = (
      'Client',
      'load_env',
      'register',
      'get_client',
  )
  
  SCHEMA = '''
  // NOTE: modified from https://github.com/prisma/prisma/blob/master/src/packages/client/src/__tests__/integration/happy/exhaustive-schema/schema.prisma
  
  datasource db {
    provider = "postgresql"
    url      = env("DB_URL")
  }
  
  generator db {
    provider             = "prisma-client-py"
    interface            = "sync"
    recursive_type_depth = 3
    output               = "../../../.tests_cache/generation/exhaustive/__prisma_sync_output__/prisma"
  }
  
  model Post {
    id         Int      @id @default(autoincrement())
    created_at DateTime @default(now())
    title      String
    content    String?
    published  Boolean  @default(false)
    author     User     @relation(fields: [author_id], references: [id])
    author_id  Int
  }
  
  model User {
    id               Int             @id @default(autoincrement())
    email            String          @unique
    int              Int
    optional_int     Int?
    float            Float
    optional_float   Float?
    string           String
    optional_string  String?
    enum             ABeautifulEnum
    optional_enum    ABeautifulEnum?
    boolean          Boolean
    optional_boolean Boolean?
    posts            Post[]
  }
  
  model M {
    id               Int             @id @default(autoincrement())
    n                N[]
    int              Int
    optional_int     Int?
    float            Float
    optional_float   Float?
    string           String
    optional_string  String?
    enum             ABeautifulEnum
    optional_enum    ABeautifulEnum?
    boolean          Boolean
    optional_boolean Boolean?
  }
  
  model N {
    id               Int             @id @default(autoincrement())
    m                M[]
    int              Int
    optional_int     Int?
    float            Float
    optional_float   Float?
    string           String
    optional_string  String?
    json_            Json
    optional_json    Json?
    enum             ABeautifulEnum
    optional_enum    ABeautifulEnum?
    boolean          Boolean
    optional_boolean Boolean?
  }
  
  model OneOptional {
    id               Int             @id @default(autoincrement())
    many             ManyRequired[]
    int              Int
    optional_int     Int?
    float            Float
    optional_float   Float?
    string           String
    optional_string  String?
    enum             ABeautifulEnum
    optional_enum    ABeautifulEnum?
    boolean          Boolean
    optional_boolean Boolean?
  }
  
  model ManyRequired {
    id  Int          @id @default(autoincrement())
    one OneOptional? @relation(fields: [one_optional_id], references: [id])
  
    one_optional_id  Int?
    int              Int
    optional_int     Int?
    float            Float
    optional_float   Float?
    string           String
    optional_string  String?
    enum             ABeautifulEnum
    optional_enum    ABeautifulEnum?
    boolean          Boolean
    optional_boolean Boolean?
  }
  
  model Lists {
    id           String     @id @default(cuid())
    strings      String[]
    bytes        Bytes[]
    dates        DateTime[]
    bools        Boolean[]
    ints         Int[]
    floats       Float[]
    bigints      BigInt[]
    json_objects Json[]
    // TODO
    // decimals     Decimal[]
  }
  
  enum ABeautifulEnum {
    A
    B
    C
  }
  
  model A {
    email    String  @unique
    name     String?
    int      Int     @db.Integer
    sInt     Int     @db.SmallInt
    inc_int  Int     @default(autoincrement()) @db.Integer
    inc_sInt Int     @default(autoincrement()) @db.SmallInt
    bInt     BigInt  @db.BigInt
    inc_bInt BigInt  @default(autoincrement()) @db.BigInt
  
    @@unique([name, email])
  }
  
  model B {
    id      String @id @default(cuid())
    float   Float  @db.Real
    d_float Float  @db.DoublePrecision
  
    // TODO
    // decFloat Decimal @db.Decimal(2, 1)
    // numFloat Decimal @db.Decimal(10, 6)
  
    @@unique([float, d_float], name: "my_constraint")
  }
  
  model C {
    char   String @db.Char(10)
    v_char String @db.VarChar(11)
    text   String @db.Text
    bit    String @db.Bit(4)
    v_bit  String @db.VarBit(5)
    uuid   String @db.Uuid
  
    @@id([char, text], name: "my_id")
  }
  
  model D {
    id     String  @id @default(cuid())
    bool   Boolean @db.Boolean
    xml    String  @db.Xml
    json_  Json    @db.Json
    jsonb  Json    @db.JsonB
    binary Bytes   @db.ByteA
  }
  
  model E {
    id   String   @id @default(cuid())
    date DateTime @db.Date
    time DateTime @db.Time(3)
    ts   DateTime @db.Timestamp(3)
  }
  
  '''
  
  RegisteredClient = Union['Client', Callable[[], 'Client']]
  _registered_client: Optional[RegisteredClient] = None
  
  
  def load_env(*, override: bool = True, **kwargs: Any) -> None:
      """Load environemntal variables from dotenv files
  
      Loads from the following files relative to the current
      working directory:
  
      - .env
      - prisma/.env
      """
      from dotenv import load_dotenv
  
      load_dotenv('.env', override=override, **kwargs)
      load_dotenv('prisma/.env', override=override, **kwargs)
  
  
  def register(client: RegisteredClient) -> None:
      """Register a client instance to be retrieved by `get_client()`
  
      This function _must_ only be called once, preferrably as soon as possible
      to avoid any potentially confusing errors with threads or processes.
      """
      global _registered_client
  
      if _registered_client is not None:
          raise errors.ClientAlreadyRegisteredError()
  
      if not isinstance(client, Client) and not callable(client):
          raise TypeError(
              f'Expected either a {Client} instance or a function that returns a {Client} but got {client} instead.'
          )
  
      _registered_client = client
  
  
  def get_client() -> 'Client':
      """Get the registered client instance
  
      Raises errors.ClientNotRegisteredError() if no client instance has been registered.
      """
      registered = _registered_client
      if registered is None:
          raise errors.ClientNotRegisteredError() from None
  
      if isinstance(registered, Client):
          return registered
  
      client = registered()
      if not isinstance(client, Client):  # pyright: reportUnnecessaryIsInstance=false
          raise TypeError(
              f'Registered function returned {client} instead of a {Client} instance.'
          )
  
      return client
  
  
  class Client:
      post: 'actions.PostActions'
      user: 'actions.UserActions'
      m: 'actions.MActions'
      n: 'actions.NActions'
      oneoptional: 'actions.OneOptionalActions'
      manyrequired: 'actions.ManyRequiredActions'
      lists: 'actions.ListsActions'
      a: 'actions.AActions'
      b: 'actions.BActions'
      c: 'actions.CActions'
      d: 'actions.DActions'
      e: 'actions.EActions'
  
      def __init__(
          self,
          *,
          use_dotenv: bool = True,
          log_queries: bool = False,
          auto_register: bool = False,
          # no idea why this type ignore is required, pyright works correctly, mypy does not
          datasource: Optional[types.DatasourceOverride] = None,  # type: ignore[name-defined]
      ) -> None:
          self.post = actions.PostActions(self, models.Post)
          self.user = actions.UserActions(self, models.User)
          self.m = actions.MActions(self, models.M)
          self.n = actions.NActions(self, models.N)
          self.oneoptional = actions.OneOptionalActions(self, models.OneOptional)
          self.manyrequired = actions.ManyRequiredActions(self, models.ManyRequired)
          self.lists = actions.ListsActions(self, models.Lists)
          self.a = actions.AActions(self, models.A)
          self.b = actions.BActions(self, models.B)
          self.c = actions.CActions(self, models.C)
          self.d = actions.DActions(self, models.D)
          self.e = actions.EActions(self, models.E)
          self.__engine: Optional[AbstractEngine] = None
          self._active_provider = 'postgresql'
          self._log_queries = log_queries
          self._datasource = datasource
  
          if use_dotenv:
              load_env()
  
          if auto_register:
              register(self)
  
      def __del__(self) -> None:
          if self.__engine is not None:
              self.__engine.stop()
              self.__engine = None
  
      def __enter__(self) -> 'Client':
          self.connect()
          return self
  
      def __exit__(
          self,
          exc_type: Optional[Type[BaseException]],
          exc: Optional[BaseException],
          exc_tb: Optional[TracebackType],
      ) -> None:
          if self.is_connected():
              self.disconnect()
  
      def is_connected(self) -> bool:
          """Returns True if the client is connected to the query engine, False otherwise."""
          return self.__engine is not None
  
      def connect(self, timeout: int = 10) -> None:
          """Connect to the Prisma query engine.
  
          It is required to call this before accessing data.
          """
          if self.__engine is None:
              self.__engine = self._engine_class(dml=SCHEMA, log_queries=self._log_queries)
  
          datasources: Optional[List[types.DatasourceOverride]] = None
          if self._datasource is not None:
              ds = self._datasource.copy()
              ds.setdefault('name', 'db')
              datasources = [ds]
  
          self.__engine.connect(
              timeout=timeout,
              datasources=datasources,
          )
  
      def disconnect(self) -> None:
          """Disconnect the Prisma query engine."""
          if self.__engine is not None:
              self.__engine.stop()
              self.__engine = None
  
      def execute_raw(self, query: str, *args: Any) -> int:
          resp = self._execute(
              operation='mutation',
              method='executeRaw',
              arguments={
                  'query': query,
                  'parameters': args,
              }
          )
          return int(resp['data']['result'])
  
      @overload
      def query_first(self, query: str, *args: Any) -> Any:
          ...
  
      @overload
      def query_first(self, query: str, *args: Any, model: Type[BaseModelT]) -> Optional[BaseModelT]:
          ...
  
      def query_first(
          self, query: str, *args: Any, model: Optional[Type[BaseModelT]] = None
      ) -> Union[Optional[BaseModelT], Any]:
          if model is not None:
              results = self.query_raw(query, *args, model=model)
          else:
              results = self.query_raw(query, *args)
  
          if not results:
              return None
  
          return results[0]
  
      @overload
      def query_raw(self, query: str, *args: Any) -> Any:
          ...
  
      @overload
      def query_raw(self, query: str, *args: Any, model: Type[BaseModelT]) -> List[BaseModelT]:
          ...
  
      def query_raw(
          self, query: str, *args: Any, model: Optional[Type[BaseModelT]] = None
      ) -> Union[List[BaseModelT], Any]:
          resp = self._execute(
              operation='mutation',
              method='queryRaw',
              arguments={
                  'query': query,
                  'parameters': args,
              }
          )
          result = resp['data']['result']
          if model is not None:
              return [model.parse_obj(r) for r in result]
          return result
  
      def batch_(self) -> 'Batch':
          """Returns a context manager for grouping write queries into a single transaction."""
          return Batch(client=self)
  
      # TODO: don't return Any
      def _execute(
          self,
          method: str,
          operation: str,
          arguments: Dict[str, Any],
          model: Optional[str] = None,
          root_selection: Optional[List[str]] = None
      ) -> Any:
          builder = QueryBuilder(
              operation=operation,
              method=method,
              model=model,
              arguments=arguments,
              root_selection=root_selection,
          )
          return self._engine.query(builder.build())
  
      @property
      def _engine(self) -> AbstractEngine:
          engine = self.__engine
          if engine is None:
              raise errors.ClientNotConnectedError()
          return engine
  
      @property
      def _engine_class(self) -> Type[AbstractEngine]:
          return QueryEngine
  
  
  # TODO: this should return the results as well
  # TODO: don't require copy-pasting arguments between actions and batch actions
  class Batch:
      post: 'PostBatchActions'
      user: 'UserBatchActions'
      m: 'MBatchActions'
      n: 'NBatchActions'
      oneoptional: 'OneOptionalBatchActions'
      manyrequired: 'ManyRequiredBatchActions'
      lists: 'ListsBatchActions'
      a: 'ABatchActions'
      b: 'BBatchActions'
      c: 'CBatchActions'
      d: 'DBatchActions'
      e: 'EBatchActions'
  
      def __init__(self, client: Client) -> None:
          self.__client = client
          self.__queries: List[str] = []
          self._active_provider = client._active_provider
          self.post = PostBatchActions(self)
          self.user = UserBatchActions(self)
          self.m = MBatchActions(self)
          self.n = NBatchActions(self)
          self.oneoptional = OneOptionalBatchActions(self)
          self.manyrequired = ManyRequiredBatchActions(self)
          self.lists = ListsBatchActions(self)
          self.a = ABatchActions(self)
          self.b = BBatchActions(self)
          self.c = CBatchActions(self)
          self.d = DBatchActions(self)
          self.e = EBatchActions(self)
  
      def _add(self, **kwargs: Any) -> None:
          builder = QueryBuilder(**kwargs)
          self.__queries.append(builder.build_query())
  
      def commit(self) -> None:
          """Execute the queries"""
          # TODO: normalise this, we should still call client._execute
          from .builder import dumps
  
          queries = self.__queries
          self.__queries = []
  
          payload = {
              'batch': [
                  {
                      'query': query,
                      'variables': {},
                  }
                  for query in queries
              ],
              'transaction': True,
          }
          self.__client._engine.query(dumps(payload))
  
      def __enter__(self) -> 'Batch':
          return self
  
      def __exit__(
          self,
          exc_type: Optional[Type[BaseException]],
          exc: Optional[BaseException],
          exc_tb: Optional[TracebackType],
      ) -> None:
          if exc is None:
              self.commit()
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class PostBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.PostCreateInput,
          include: Optional[types.PostInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='Post',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.PostCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='Post',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.PostWhereUniqueInput,
          include: Optional[types.PostInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='Post',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.PostUpdateInput,
          where: types.PostWhereUniqueInput,
          include: Optional[types.PostInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='Post',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.PostWhereUniqueInput,
          data: types.PostUpsertInput,
          include: Optional[types.PostInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='Post',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.PostUpdateManyMutationInput,
          where: types.PostWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='Post',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.PostWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='Post',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class UserBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.UserCreateInput,
          include: Optional[types.UserInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='User',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.UserCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='User',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.UserWhereUniqueInput,
          include: Optional[types.UserInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='User',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.UserUpdateInput,
          where: types.UserWhereUniqueInput,
          include: Optional[types.UserInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='User',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.UserWhereUniqueInput,
          data: types.UserUpsertInput,
          include: Optional[types.UserInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='User',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.UserUpdateManyMutationInput,
          where: types.UserWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='User',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.UserWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='User',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class MBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.MCreateInput,
          include: Optional[types.MInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='M',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.MCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='M',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.MWhereUniqueInput,
          include: Optional[types.MInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='M',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.MUpdateInput,
          where: types.MWhereUniqueInput,
          include: Optional[types.MInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='M',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.MWhereUniqueInput,
          data: types.MUpsertInput,
          include: Optional[types.MInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='M',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.MUpdateManyMutationInput,
          where: types.MWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='M',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.MWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='M',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class NBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.NCreateInput,
          include: Optional[types.NInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='N',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.NCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='N',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.NWhereUniqueInput,
          include: Optional[types.NInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='N',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.NUpdateInput,
          where: types.NWhereUniqueInput,
          include: Optional[types.NInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='N',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.NWhereUniqueInput,
          data: types.NUpsertInput,
          include: Optional[types.NInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='N',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.NUpdateManyMutationInput,
          where: types.NWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='N',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.NWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='N',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class OneOptionalBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.OneOptionalCreateInput,
          include: Optional[types.OneOptionalInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='OneOptional',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.OneOptionalCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='OneOptional',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.OneOptionalWhereUniqueInput,
          include: Optional[types.OneOptionalInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='OneOptional',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.OneOptionalUpdateInput,
          where: types.OneOptionalWhereUniqueInput,
          include: Optional[types.OneOptionalInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='OneOptional',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.OneOptionalWhereUniqueInput,
          data: types.OneOptionalUpsertInput,
          include: Optional[types.OneOptionalInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='OneOptional',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.OneOptionalUpdateManyMutationInput,
          where: types.OneOptionalWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='OneOptional',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.OneOptionalWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='OneOptional',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class ManyRequiredBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.ManyRequiredCreateInput,
          include: Optional[types.ManyRequiredInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='ManyRequired',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.ManyRequiredCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='ManyRequired',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.ManyRequiredWhereUniqueInput,
          include: Optional[types.ManyRequiredInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='ManyRequired',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.ManyRequiredUpdateInput,
          where: types.ManyRequiredWhereUniqueInput,
          include: Optional[types.ManyRequiredInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='ManyRequired',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.ManyRequiredWhereUniqueInput,
          data: types.ManyRequiredUpsertInput,
          include: Optional[types.ManyRequiredInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='ManyRequired',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.ManyRequiredUpdateManyMutationInput,
          where: types.ManyRequiredWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='ManyRequired',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.ManyRequiredWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='ManyRequired',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class ListsBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.ListsCreateInput,
          include: Optional[types.ListsInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='Lists',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.ListsCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='Lists',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.ListsWhereUniqueInput,
          include: Optional[types.ListsInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='Lists',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.ListsUpdateInput,
          where: types.ListsWhereUniqueInput,
          include: Optional[types.ListsInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='Lists',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.ListsWhereUniqueInput,
          data: types.ListsUpsertInput,
          include: Optional[types.ListsInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='Lists',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.ListsUpdateManyMutationInput,
          where: types.ListsWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='Lists',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.ListsWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='Lists',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class ABatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.ACreateInput,
          include: Optional[types.AInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='A',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.ACreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='A',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.AWhereUniqueInput,
          include: Optional[types.AInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='A',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.AUpdateInput,
          where: types.AWhereUniqueInput,
          include: Optional[types.AInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='A',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.AWhereUniqueInput,
          data: types.AUpsertInput,
          include: Optional[types.AInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='A',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.AUpdateManyMutationInput,
          where: types.AWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='A',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.AWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='A',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class BBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.BCreateInput,
          include: Optional[types.BInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='B',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.BCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='B',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.BWhereUniqueInput,
          include: Optional[types.BInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='B',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.BUpdateInput,
          where: types.BWhereUniqueInput,
          include: Optional[types.BInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='B',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.BWhereUniqueInput,
          data: types.BUpsertInput,
          include: Optional[types.BInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='B',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.BUpdateManyMutationInput,
          where: types.BWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='B',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.BWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='B',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class CBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.CCreateInput,
          include: Optional[types.CInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='C',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.CCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='C',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.CWhereUniqueInput,
          include: Optional[types.CInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='C',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.CUpdateInput,
          where: types.CWhereUniqueInput,
          include: Optional[types.CInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='C',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.CWhereUniqueInput,
          data: types.CUpsertInput,
          include: Optional[types.CInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='C',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.CUpdateManyMutationInput,
          where: types.CWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='C',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.CWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='C',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class DBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.DCreateInput,
          include: Optional[types.DInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='D',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.DCreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='D',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.DWhereUniqueInput,
          include: Optional[types.DInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='D',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.DUpdateInput,
          where: types.DWhereUniqueInput,
          include: Optional[types.DInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='D',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.DWhereUniqueInput,
          data: types.DUpsertInput,
          include: Optional[types.DInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='D',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.DUpdateManyMutationInput,
          where: types.DWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='D',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.DWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='D',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  # NOTE: some arguments are meaningless in this context but are included
  # for completeness sake
  class EBatchActions:
      def __init__(self, batcher: Batch) -> None:
          self._batcher = batcher
  
      def create(
          self,
          data: types.ECreateInput,
          include: Optional[types.EInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='createOne',
              model='E',
              arguments={
                  'data': data,
                  'include': include,
              },
          )
  
      def create_many(
          self,
          data: List[types.ECreateWithoutRelationsInput],
          *,
          skip_duplicates: Optional[bool] = None,
      ) -> None:
          if self._batcher._active_provider == 'sqlite':
              raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')
  
          self._batcher._add(
              operation='mutation',
              method='createMany',
              model='E',
              arguments={
                  'data': data,
                  'skipDuplicates': skip_duplicates,
              },
              root_selection=['count'],
          )
  
      def delete(
          self,
          where: types.EWhereUniqueInput,
          include: Optional[types.EInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteOne',
              model='E',
              arguments={
                  'where': where,
                  'include': include,
              },
          )
  
      def update(
          self,
          data: types.EUpdateInput,
          where: types.EWhereUniqueInput,
          include: Optional[types.EInclude] = None
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateOne',
              model='E',
              arguments={
                  'data': data,
                  'where': where,
                  'include': include,
              },
          )
  
      def upsert(
          self,
          where: types.EWhereUniqueInput,
          data: types.EUpsertInput,
          include: Optional[types.EInclude] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='upsertOne',
              model='E',
              arguments={
                  'where': where,
                  'include': include,
                  'create': data.get('create'),
                  'update': data.get('update'),
              },
          )
  
      def update_many(
          self,
          data: types.EUpdateManyMutationInput,
          where: types.EWhereInput,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='updateMany',
              model='E',
              arguments={'data': data, 'where': where,},
              root_selection=['count'],
          )
  
      def delete_many(
          self,
          where: Optional[types.EWhereInput] = None,
      ) -> None:
          self._batcher._add(
              operation='mutation',
              method='deleteMany',
              model='E',
              arguments={'where': where},
              root_selection=['count'],
          )
  
  
  
  '
---
# name: test_sync[engine/abstract.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Callable,
      Generic,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  from typing_extensions import TypedDict, Literal
  
  # -- template engine/abstract.py.jinja --
  from abc import ABC, abstractmethod
  from ..types import DatasourceOverride
  from .._compat import get_running_loop
  
  __all__ = (
      'AbstractEngine',
  )
  
  class AbstractEngine(ABC):
      dml: str
  
      @abstractmethod
      def __init__(self, *, dml: str, log_queries: bool = False) -> None:
          ...
  
      def stop(self) -> None:
          """Wrapper for synchronously calling close() and aclose()"""
          self.close()
          try:
              loop = get_running_loop()
          except RuntimeError:
              # no event loop in the current thread, we cannot cleanup asynchronously
              return
          else:
              if not loop.is_closed():
                  loop.create_task(self.aclose())
  
      @abstractmethod
      def close(self) -> None:
          """Synchronous method for closing the engine, useful if the underlying engine uses a subprocess"""
          ...
  
      @abstractmethod
      async def aclose(self) -> None:
          """Asynchronous method for closing the engine, only used if an
          asynchronous client is generated.
          """
          ...
  
      @abstractmethod
      def connect(
          self,
          timeout: int = 10,
          datasources: Optional[List[DatasourceOverride]] = None,
      ) -> None:
          """Connect to the engine"""
          ...
  
      @abstractmethod
      def query(self, content: str) -> Any:
          """Execute a GraphQL query.
  
          This method expects a JSON object matching this structure:
  
          {
              'variables': {},
              'operation_name': str,
              'query': str,
          }
          """
          ...
  '
---
# name: test_sync[engine/query.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Callable,
      Generic,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  from typing_extensions import TypedDict, Literal
  
  # -- template engine/query.py.jinja --
  
  import os
  import time
  import atexit
  import signal
  import asyncio
  import logging
  import subprocess
  from pathlib import Path
  
  from . import utils, errors
  from .abstract import AbstractEngine
  from ..http import HTTP
  from ..utils import DEBUG
  from .._types import Method
  from ..binaries import platform
  from ..utils import time_since, _env_bool
  from ..types import DatasourceOverride
  from ..builder import dumps
  
  
  __all__ = ('QueryEngine',)
  
  log: logging.Logger = logging.getLogger(__name__)
  
  
  class QueryEngine(AbstractEngine):
      dml: str
      session: HTTP
  
      def __init__(self, *, dml: str, log_queries: bool = False):
          self.dml = dml
          self.session = HTTP()
          self._log_queries = log_queries
          self.url = None  # type: Optional[str]
          self.process = None  # type: Optional[subprocess.Popen[bytes]]
          self.file = None  # type: Optional[Path]
  
          # ensure the query engine process is terminated when we are
          atexit.register(self.stop)
  
      def __del__(self) -> None:
          self.stop()
  
      def close(self) -> None:
          log.debug('Disconnecting query engine...')
  
          if self.process is not None:
              if platform.name() == 'windows':
                  self.process.kill()
              else:
                  self.process.send_signal(signal.SIGINT)
  
              self.process.wait()
              self.process = None
  
          self._close_session()
          log.debug('Disconnected query engine')
  
      async def aclose(self) -> None:
          self.close()
          self._close_session()
  
      def _close_session(self) -> None:
          if self.session and not self.session.closed:
              self.session.close()
  
      def connect(
          self,
          timeout: int = 10,
          datasources: Optional[List[DatasourceOverride]] = None,
      ) -> None:
          log.debug('Connecting to query engine')
          if self.process is not None:
              raise errors.AlreadyConnectedError('Already connected to the query engine')
  
          start = time.monotonic()
          self.file = file = utils.ensure()
  
          try:
              self.spawn(file, timeout=timeout, datasources=datasources)
          except Exception:
              self.close()
              raise
  
          log.debug('Connecting to query engine took %s', time_since(start))
  
      def spawn(
          self,
          file: Path,
          timeout: int = 10,
          datasources: Optional[List[DatasourceOverride]] = None,
      ) -> None:
          port = utils.get_open_port()
          log.debug('Running query engine on port %i', port)
  
          self.url = f'http://localhost:{port}'
  
          env = os.environ.copy()
          env.update(
              PRISMA_DML=self.dml,
              RUST_LOG='error',
              RUST_LOG_FORMAT='json',
              PRISMA_CLIENT_ENGINE_TYPE='binary',
          )
  
          if DEBUG:
              env.update(RUST_LOG='info')
  
          if datasources is not None:
              env.update(OVERWRITE_DATASOURCES=dumps(datasources))
  
          # TODO: remove the noise from these query logs
          if self._log_queries:
              env.update(LOG_QUERIES='y')
  
          args: List[str] = [str(file.absolute()), '-p', str(port), '--enable-raw-queries']
          if _env_bool('__PRISMA_PY_PLAYGROUND'):
              env.update(RUST_LOG='info')
              args.append('--enable-playground')
  
          log.debug('Starting query engine...')
          self.process = subprocess.Popen(
              args,
              env=env,
              stdout=sys.stdout,
              stderr=sys.stderr,
          )
  
          last_exc = None
          for _ in range(int(timeout / 0.1)):
              try:
                  data = self.request('GET', '/status')
              except Exception as exc:  # pylint: disable=broad-except
                  last_exc = exc
                  log.debug(
                      'Could not connect to query engine due to %s; retrying...',
                      type(exc).__name__,
                  )
                  time.sleep(0.1)
  
                  continue
  
              if data.get('Errors') is not None:
                  log.debug('Could not connect due to gql errors; retrying...')
                  time.sleep(0.1)
  
                  continue
  
              break
          else:
              raise errors.EngineConnectionError(
                  'Could not connect to the query engine'
              ) from last_exc
  
      def query(self, content: str) -> Any:
          return self.request('POST', '/', content=content)
  
      def request(self, method: Method, path: str, *, content: Any = None) -> Any:
          if self.url is None:
              raise errors.NotConnectedError('Not connected to the query engine')
  
          kwargs = {
              'headers': {
                  'Content-Type': 'application/json',
                  'Accept': 'application/json',
              }
          }
  
          if content is not None:
              kwargs['content'] = content
  
          url = self.url + path
          log.debug('Sending %s request to %s with content: %s', method, url, content)
  
          resp = self.session.request(method, url, **kwargs)
  
          if 300 > resp.status >= 200:
              response = resp.json()
              log.debug('%s %s returned %s', method, url, response)
  
              errors_data = response.get('errors')
              if errors_data:
                  return utils.handle_response_errors(resp, errors_data)
  
              return response
  
          if resp.status == 422:
              raise errors.UnprocessableEntityError(resp)
  
          # TODO: handle errors better
          raise errors.EngineRequestError(resp, resp.text())
  
  
  # black does not respect the fmt: off comment without this
  # fmt: on
  
  '
---
# name: test_sync[enums.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Callable,
      Generic,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  from typing_extensions import TypedDict, Literal
  
  # -- template enums.py.jinja --
  from enum import Enum
  
  
  class ABeautifulEnum(str, Enum):
      A = 'A'
      B = 'B'
      C = 'C'
  
  
  '
---
# name: test_sync[fields.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Callable,
      Generic,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  from typing_extensions import TypedDict, Literal
  
  # -- template fields.py.jinja --
  import base64
  from pydantic import Json as _PydanticJson
  
  
  __all__ = (
      'Json',
      'Base64',
  )
  
  
  _JsonKeys = Union[
      None,
      bool,
      float,
      int,
      str,
  ]
  
  # Base64 data should only be valid ascii, we limit our encoding to ascii so that
  # any erroneous data is caught as early on as possible.
  BASE64_ENCODING = 'ascii'
  
  
  # inherit from _PydanticJson so that pydantic will automatically
  # transform the json string into python objects.
  class Json(_PydanticJson):
      data: 'Serializable'
  
      def __init__(self, data: 'Serializable') -> None:
          self.data = data
          super().__init__()
  
      @classmethod
      def keys(cls, **data: 'Serializable') -> 'Json':
          return cls(data)
  
      if TYPE_CHECKING:
          # Fields that are of the `Json` type are automatically
          # de-serialized from json to the corresponding python type
          # when the model is created, e.g.
          #
          # User(json_obj='{"foo": null}') -> User(json_obj={'foo': None})
          #
          # As we don't know what the type will actually be at runtime
          # we add methods here for convenience so that naive access
          # to the field is still allowed, e.g.
          #
          # user.json_obj['foo']
          # user.json_obj[1]
          # user.json_obj[1:5]
          #
          # It should be noted that users will still have
          # to validate / cast fields to the type they are expecting
          # for any strict type binding or nested index calls to work, e.g.
          #
          # isinstance(user.json_obj, dict)
          # cast(Dict[str, Any], user.json_obj)
          # prisma.validate(ExpectedType, user.json_obj)  # NOTE: not implemented yet
          @overload  # type: ignore
          def __getitem__(self, i: slice) -> List['Serializable']:
              ...
  
          @overload
          def __getitem__(self, i: '_JsonKeys') -> 'Serializable':  # pyright: reportIncompatibleMethodOverride=false
              ...
  
          def __getitem__(self, i: Union['_JsonKeys', slice]) -> 'Serializable':
              ...
  
  
  class Base64:
      def __init__(self, raw: bytes) -> None:
          self._raw = raw
  
      @classmethod
      def encode(cls, value: bytes) -> 'Base64':
          """Encode bytes into valid Base64"""
          return cls(base64.b64encode(value))
  
      def decode(self, encoding: str = BASE64_ENCODING) -> bytes:
          """Decode from Base64 to the original bytes object"""
          return base64.b64decode(self._raw)
  
      # NOTE: we explicitly use a different encoding here as we are decoding
      # to the original data provided by the user, this data does not have
      # the limitation of being ascii only that the raw Base64 data does
      def decode_str(self, encoding: str = 'utf-8') -> str:
          """Decode from Base64 to the original string
  
          This decodes using the `utf-8` encoding by default,
          you can customise the encoding like so:
  
          ```py
          value = b64.decode_str('ascii')
          ```
          """
          return self.decode().decode(encoding)
  
      def __str__(self) -> str:
          return self._raw.decode(BASE64_ENCODING)
  
      def __repr__(self) -> str:
          return f'{self.__class__.__name__}({self._raw})'  # type: ignore[str-bytes-safe]
  
      def __eq__(self, other: Any) -> bool:
          if isinstance(other, Base64):
              return self._raw == other._raw
  
          return False
  
      @classmethod
      def _internal_from_prisma(
          cls,
          value: Union[str, 'Base64', List[Union[str, 'Base64']]]
      ) -> Union['Base64', List['Base64']]:
          if isinstance(value, Base64):
              return value
  
          if isinstance(value, list):
              return [
                  item
                  if isinstance(item, Base64)
                  else
                  cls(bytes(item, BASE64_ENCODING))
                  for item in value
              ]
  
          return cls(bytes(value, BASE64_ENCODING))
  
  
  from .types import Serializable
  '
---
# name: test_sync[http.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Callable,
      Generic,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  from typing_extensions import TypedDict, Literal
  
  # -- template http.py.jinja --
  from ._sync_http import (
      HTTP as HTTP,
      Response as Response,
      client as client,
  )
  
  '
---
# name: test_sync[models.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Callable,
      Generic,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  from typing_extensions import TypedDict, Literal
  
  # -- template models.py.jinja --
  import os
  from pydantic import BaseConfig, BaseModel, Field, validator
  
  from . import types, enums, errors, fields
  from ._types import BaseModelT
  from .builder import serialize_base64
  from .generator import partial_models_ctx, PartialModelField
  
  
  class Config(BaseConfig):
      use_enum_values: bool = True
      arbitrary_types_allowed: bool = True
      allow_population_by_field_name: bool = True
      json_encoders: Dict[Type[Any], Any] = {
          fields.Base64: serialize_base64,
      }
  
  
  _created_partial_types: Set[str] = set()
  
  
  class Post(BaseModel):
      id: int
      created_at: datetime.datetime
      title: str
      content: Optional[str]
      published: bool
      author: Optional['models.User']
      author_id: int
  
      Config = Config
  
      @classmethod
      def prisma(cls) -> 'actions.PostActions':
          from .client import get_client
  
          return actions.PostActions(get_client(), cls)
  
      def __init_subclass__(cls, *args: Any, **kwargs: Any) -> None:
          raise RuntimeError(
              'Prisma models cannot be subclassed with pseudo-recursive types;\n'
              'This is because mypy does not work well with this pattern;\n'
              'See the documentation for how to generate fully recursive types: \n'
              'https://prisma-client-py.readthedocs.io/en/stable/reference/config/#recursive'
          )
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.PostKeys']] = None,
          exclude: Optional[Iterable['types.PostKeys']] = None,
          required: Optional[Iterable['types.PostKeys']] = None,
          optional: Optional[Iterable['types.PostKeys']] = None,
          relations: Optional[Mapping['types.PostRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.PostKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _Post_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _Post_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _Post_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _Post_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  for field, type_ in relations.items():
                      if field not in _Post_relational_fields:
                          raise errors.UnknownRelationalFieldError('Post', field)
  
                      # TODO: this method of validating types is not ideal
                      # as it means we cannot two create partial types that
                      # reference each other
                      if type_ not in _created_partial_types:
                          raise ValueError(
                              f'Unknown partial type: "{type_}". '
                              f'Did you remember to generate the {type_} type before this one?'
                          )
  
                      # TODO: support non prisma.partials models
                      info = fields[field]
                      if info['is_list']:
                          info['type'] = f'List[\'partials.{type_}\']'
                      else:
                          info['type'] = f'\'partials.{type_}\''
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid Post / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class User(BaseModel):
      id: int
      email: str
      int: int
      optional_int: Optional[int]
      float: float
      optional_float: Optional[float]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
      posts: Optional[List['models.Post']]
  
      Config = Config
  
      @classmethod
      def prisma(cls) -> 'actions.UserActions':
          from .client import get_client
  
          return actions.UserActions(get_client(), cls)
  
      def __init_subclass__(cls, *args: Any, **kwargs: Any) -> None:
          raise RuntimeError(
              'Prisma models cannot be subclassed with pseudo-recursive types;\n'
              'This is because mypy does not work well with this pattern;\n'
              'See the documentation for how to generate fully recursive types: \n'
              'https://prisma-client-py.readthedocs.io/en/stable/reference/config/#recursive'
          )
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.UserKeys']] = None,
          exclude: Optional[Iterable['types.UserKeys']] = None,
          required: Optional[Iterable['types.UserKeys']] = None,
          optional: Optional[Iterable['types.UserKeys']] = None,
          relations: Optional[Mapping['types.UserRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.UserKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _User_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _User_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _User_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _User_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  for field, type_ in relations.items():
                      if field not in _User_relational_fields:
                          raise errors.UnknownRelationalFieldError('User', field)
  
                      # TODO: this method of validating types is not ideal
                      # as it means we cannot two create partial types that
                      # reference each other
                      if type_ not in _created_partial_types:
                          raise ValueError(
                              f'Unknown partial type: "{type_}". '
                              f'Did you remember to generate the {type_} type before this one?'
                          )
  
                      # TODO: support non prisma.partials models
                      info = fields[field]
                      if info['is_list']:
                          info['type'] = f'List[\'partials.{type_}\']'
                      else:
                          info['type'] = f'\'partials.{type_}\''
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid User / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class M(BaseModel):
      id: int
      n: Optional[List['models.N']]
      int: int
      optional_int: Optional[int]
      float: float
      optional_float: Optional[float]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
      Config = Config
  
      @classmethod
      def prisma(cls) -> 'actions.MActions':
          from .client import get_client
  
          return actions.MActions(get_client(), cls)
  
      def __init_subclass__(cls, *args: Any, **kwargs: Any) -> None:
          raise RuntimeError(
              'Prisma models cannot be subclassed with pseudo-recursive types;\n'
              'This is because mypy does not work well with this pattern;\n'
              'See the documentation for how to generate fully recursive types: \n'
              'https://prisma-client-py.readthedocs.io/en/stable/reference/config/#recursive'
          )
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.MKeys']] = None,
          exclude: Optional[Iterable['types.MKeys']] = None,
          required: Optional[Iterable['types.MKeys']] = None,
          optional: Optional[Iterable['types.MKeys']] = None,
          relations: Optional[Mapping['types.MRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.MKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _M_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _M_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _M_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _M_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  for field, type_ in relations.items():
                      if field not in _M_relational_fields:
                          raise errors.UnknownRelationalFieldError('M', field)
  
                      # TODO: this method of validating types is not ideal
                      # as it means we cannot two create partial types that
                      # reference each other
                      if type_ not in _created_partial_types:
                          raise ValueError(
                              f'Unknown partial type: "{type_}". '
                              f'Did you remember to generate the {type_} type before this one?'
                          )
  
                      # TODO: support non prisma.partials models
                      info = fields[field]
                      if info['is_list']:
                          info['type'] = f'List[\'partials.{type_}\']'
                      else:
                          info['type'] = f'\'partials.{type_}\''
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid M / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class N(BaseModel):
      id: int
      m: Optional[List['models.M']]
      int: int
      optional_int: Optional[int]
      float: float
      optional_float: Optional[float]
      string: str
      optional_string: Optional[str]
      json_: 'fields.Json'
      optional_json: Optional['fields.Json']
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
      Config = Config
  
      @classmethod
      def prisma(cls) -> 'actions.NActions':
          from .client import get_client
  
          return actions.NActions(get_client(), cls)
  
      def __init_subclass__(cls, *args: Any, **kwargs: Any) -> None:
          raise RuntimeError(
              'Prisma models cannot be subclassed with pseudo-recursive types;\n'
              'This is because mypy does not work well with this pattern;\n'
              'See the documentation for how to generate fully recursive types: \n'
              'https://prisma-client-py.readthedocs.io/en/stable/reference/config/#recursive'
          )
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.NKeys']] = None,
          exclude: Optional[Iterable['types.NKeys']] = None,
          required: Optional[Iterable['types.NKeys']] = None,
          optional: Optional[Iterable['types.NKeys']] = None,
          relations: Optional[Mapping['types.NRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.NKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _N_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _N_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _N_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _N_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  for field, type_ in relations.items():
                      if field not in _N_relational_fields:
                          raise errors.UnknownRelationalFieldError('N', field)
  
                      # TODO: this method of validating types is not ideal
                      # as it means we cannot two create partial types that
                      # reference each other
                      if type_ not in _created_partial_types:
                          raise ValueError(
                              f'Unknown partial type: "{type_}". '
                              f'Did you remember to generate the {type_} type before this one?'
                          )
  
                      # TODO: support non prisma.partials models
                      info = fields[field]
                      if info['is_list']:
                          info['type'] = f'List[\'partials.{type_}\']'
                      else:
                          info['type'] = f'\'partials.{type_}\''
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid N / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class OneOptional(BaseModel):
      id: int
      many: Optional[List['models.ManyRequired']]
      int: int
      optional_int: Optional[int]
      float: float
      optional_float: Optional[float]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
      Config = Config
  
      @classmethod
      def prisma(cls) -> 'actions.OneOptionalActions':
          from .client import get_client
  
          return actions.OneOptionalActions(get_client(), cls)
  
      def __init_subclass__(cls, *args: Any, **kwargs: Any) -> None:
          raise RuntimeError(
              'Prisma models cannot be subclassed with pseudo-recursive types;\n'
              'This is because mypy does not work well with this pattern;\n'
              'See the documentation for how to generate fully recursive types: \n'
              'https://prisma-client-py.readthedocs.io/en/stable/reference/config/#recursive'
          )
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.OneOptionalKeys']] = None,
          exclude: Optional[Iterable['types.OneOptionalKeys']] = None,
          required: Optional[Iterable['types.OneOptionalKeys']] = None,
          optional: Optional[Iterable['types.OneOptionalKeys']] = None,
          relations: Optional[Mapping['types.OneOptionalRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.OneOptionalKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _OneOptional_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _OneOptional_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _OneOptional_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _OneOptional_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  for field, type_ in relations.items():
                      if field not in _OneOptional_relational_fields:
                          raise errors.UnknownRelationalFieldError('OneOptional', field)
  
                      # TODO: this method of validating types is not ideal
                      # as it means we cannot two create partial types that
                      # reference each other
                      if type_ not in _created_partial_types:
                          raise ValueError(
                              f'Unknown partial type: "{type_}". '
                              f'Did you remember to generate the {type_} type before this one?'
                          )
  
                      # TODO: support non prisma.partials models
                      info = fields[field]
                      if info['is_list']:
                          info['type'] = f'List[\'partials.{type_}\']'
                      else:
                          info['type'] = f'\'partials.{type_}\''
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid OneOptional / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class ManyRequired(BaseModel):
      id: int
      one: Optional['models.OneOptional']
      one_optional_id: Optional[int]
      int: int
      optional_int: Optional[int]
      float: float
      optional_float: Optional[float]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
      Config = Config
  
      @classmethod
      def prisma(cls) -> 'actions.ManyRequiredActions':
          from .client import get_client
  
          return actions.ManyRequiredActions(get_client(), cls)
  
      def __init_subclass__(cls, *args: Any, **kwargs: Any) -> None:
          raise RuntimeError(
              'Prisma models cannot be subclassed with pseudo-recursive types;\n'
              'This is because mypy does not work well with this pattern;\n'
              'See the documentation for how to generate fully recursive types: \n'
              'https://prisma-client-py.readthedocs.io/en/stable/reference/config/#recursive'
          )
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.ManyRequiredKeys']] = None,
          exclude: Optional[Iterable['types.ManyRequiredKeys']] = None,
          required: Optional[Iterable['types.ManyRequiredKeys']] = None,
          optional: Optional[Iterable['types.ManyRequiredKeys']] = None,
          relations: Optional[Mapping['types.ManyRequiredRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.ManyRequiredKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _ManyRequired_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _ManyRequired_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _ManyRequired_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _ManyRequired_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  for field, type_ in relations.items():
                      if field not in _ManyRequired_relational_fields:
                          raise errors.UnknownRelationalFieldError('ManyRequired', field)
  
                      # TODO: this method of validating types is not ideal
                      # as it means we cannot two create partial types that
                      # reference each other
                      if type_ not in _created_partial_types:
                          raise ValueError(
                              f'Unknown partial type: "{type_}". '
                              f'Did you remember to generate the {type_} type before this one?'
                          )
  
                      # TODO: support non prisma.partials models
                      info = fields[field]
                      if info['is_list']:
                          info['type'] = f'List[\'partials.{type_}\']'
                      else:
                          info['type'] = f'\'partials.{type_}\''
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid ManyRequired / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class Lists(BaseModel):
      id: str
      strings: List[str]
      bytes: List['fields.Base64']
      dates: List[datetime.datetime]
      bools: List[bool]
      ints: List[int]
      floats: List[float]
      bigints: List[int]
      json_objects: List['fields.Json']
  
      Config = Config
  
      @classmethod
      def prisma(cls) -> 'actions.ListsActions':
          from .client import get_client
  
          return actions.ListsActions(get_client(), cls)
  
      def __init_subclass__(cls, *args: Any, **kwargs: Any) -> None:
          raise RuntimeError(
              'Prisma models cannot be subclassed with pseudo-recursive types;\n'
              'This is because mypy does not work well with this pattern;\n'
              'See the documentation for how to generate fully recursive types: \n'
              'https://prisma-client-py.readthedocs.io/en/stable/reference/config/#recursive'
          )
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.ListsKeys']] = None,
          exclude: Optional[Iterable['types.ListsKeys']] = None,
          required: Optional[Iterable['types.ListsKeys']] = None,
          optional: Optional[Iterable['types.ListsKeys']] = None,
          relations: Optional[Mapping['types.ListsRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.ListsKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _Lists_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _Lists_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _Lists_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _Lists_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  raise ValueError('Model: "Lists" has no relational fields.')
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid Lists / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
      @validator('bytes', pre=True, allow_reuse=True)
      @classmethod
      def _prisma_bytes_bytes_validator(cls, value: Any) -> Union[fields.Base64, List[fields.Base64]]:
          return fields.Base64._internal_from_prisma(value)
  
  class A(BaseModel):
      email: str
      name: Optional[str]
      int: int
      sInt: int
      inc_int: int
      inc_sInt: int
      bInt: int
      inc_bInt: int
  
      Config = Config
  
      @classmethod
      def prisma(cls) -> 'actions.AActions':
          from .client import get_client
  
          return actions.AActions(get_client(), cls)
  
      def __init_subclass__(cls, *args: Any, **kwargs: Any) -> None:
          raise RuntimeError(
              'Prisma models cannot be subclassed with pseudo-recursive types;\n'
              'This is because mypy does not work well with this pattern;\n'
              'See the documentation for how to generate fully recursive types: \n'
              'https://prisma-client-py.readthedocs.io/en/stable/reference/config/#recursive'
          )
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.AKeys']] = None,
          exclude: Optional[Iterable['types.AKeys']] = None,
          required: Optional[Iterable['types.AKeys']] = None,
          optional: Optional[Iterable['types.AKeys']] = None,
          relations: Optional[Mapping['types.ARelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.AKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _A_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _A_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _A_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _A_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  raise ValueError('Model: "A" has no relational fields.')
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid A / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class B(BaseModel):
      id: str
      float: float
      d_float: float
  
      Config = Config
  
      @classmethod
      def prisma(cls) -> 'actions.BActions':
          from .client import get_client
  
          return actions.BActions(get_client(), cls)
  
      def __init_subclass__(cls, *args: Any, **kwargs: Any) -> None:
          raise RuntimeError(
              'Prisma models cannot be subclassed with pseudo-recursive types;\n'
              'This is because mypy does not work well with this pattern;\n'
              'See the documentation for how to generate fully recursive types: \n'
              'https://prisma-client-py.readthedocs.io/en/stable/reference/config/#recursive'
          )
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.BKeys']] = None,
          exclude: Optional[Iterable['types.BKeys']] = None,
          required: Optional[Iterable['types.BKeys']] = None,
          optional: Optional[Iterable['types.BKeys']] = None,
          relations: Optional[Mapping['types.BRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.BKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _B_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _B_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _B_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _B_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  raise ValueError('Model: "B" has no relational fields.')
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid B / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class C(BaseModel):
      char: str
      v_char: str
      text: str
      bit: str
      v_bit: str
      uuid: str
  
      Config = Config
  
      @classmethod
      def prisma(cls) -> 'actions.CActions':
          from .client import get_client
  
          return actions.CActions(get_client(), cls)
  
      def __init_subclass__(cls, *args: Any, **kwargs: Any) -> None:
          raise RuntimeError(
              'Prisma models cannot be subclassed with pseudo-recursive types;\n'
              'This is because mypy does not work well with this pattern;\n'
              'See the documentation for how to generate fully recursive types: \n'
              'https://prisma-client-py.readthedocs.io/en/stable/reference/config/#recursive'
          )
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.CKeys']] = None,
          exclude: Optional[Iterable['types.CKeys']] = None,
          required: Optional[Iterable['types.CKeys']] = None,
          optional: Optional[Iterable['types.CKeys']] = None,
          relations: Optional[Mapping['types.CRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.CKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _C_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _C_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _C_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _C_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  raise ValueError('Model: "C" has no relational fields.')
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid C / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  class D(BaseModel):
      id: str
      bool: bool
      xml: str
      json_: 'fields.Json'
      jsonb: 'fields.Json'
      binary: 'fields.Base64'
  
      Config = Config
  
      @classmethod
      def prisma(cls) -> 'actions.DActions':
          from .client import get_client
  
          return actions.DActions(get_client(), cls)
  
      def __init_subclass__(cls, *args: Any, **kwargs: Any) -> None:
          raise RuntimeError(
              'Prisma models cannot be subclassed with pseudo-recursive types;\n'
              'This is because mypy does not work well with this pattern;\n'
              'See the documentation for how to generate fully recursive types: \n'
              'https://prisma-client-py.readthedocs.io/en/stable/reference/config/#recursive'
          )
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.DKeys']] = None,
          exclude: Optional[Iterable['types.DKeys']] = None,
          required: Optional[Iterable['types.DKeys']] = None,
          optional: Optional[Iterable['types.DKeys']] = None,
          relations: Optional[Mapping['types.DRelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.DKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _D_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _D_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _D_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _D_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  raise ValueError('Model: "D" has no relational fields.')
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid D / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
      @validator('binary', pre=True, allow_reuse=True)
      @classmethod
      def _prisma_binary_bytes_validator(cls, value: Any) -> Union[fields.Base64, List[fields.Base64]]:
          return fields.Base64._internal_from_prisma(value)
  
  class E(BaseModel):
      id: str
      date: datetime.datetime
      time: datetime.datetime
      ts: datetime.datetime
  
      Config = Config
  
      @classmethod
      def prisma(cls) -> 'actions.EActions':
          from .client import get_client
  
          return actions.EActions(get_client(), cls)
  
      def __init_subclass__(cls, *args: Any, **kwargs: Any) -> None:
          raise RuntimeError(
              'Prisma models cannot be subclassed with pseudo-recursive types;\n'
              'This is because mypy does not work well with this pattern;\n'
              'See the documentation for how to generate fully recursive types: \n'
              'https://prisma-client-py.readthedocs.io/en/stable/reference/config/#recursive'
          )
  
      @staticmethod
      def create_partial(
          name: str,
          include: Optional[Iterable['types.EKeys']] = None,
          exclude: Optional[Iterable['types.EKeys']] = None,
          required: Optional[Iterable['types.EKeys']] = None,
          optional: Optional[Iterable['types.EKeys']] = None,
          relations: Optional[Mapping['types.ERelationalFieldKeys', str]] = None,
      ) -> None:
          if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
              raise RuntimeError(
                  'Attempted to create a partial type outside of client generation.'
              )
  
          if name in _created_partial_types:
              raise ValueError(f'Partial type "{name}" has already been created.')
  
          if include is not None and exclude is not None:
              raise TypeError(f'Exclude and include are mutually exclusive.')
  
          if required and optional:
              shared = set(required) & set(optional)
              if shared:
                  raise ValueError(f'Cannot make the same field(s) required and optional {shared}')
  
          fields: Dict['types.EKeys', PartialModelField] = {}
  
          try:
              if include:
                  for field in include:
                      fields[field] = _E_fields[field]
              elif exclude:
                  for field in exclude:
                      if field not in _E_fields:
                          raise KeyError(field)
  
                  fields = {
                      key: data
                      for key, data in _E_fields.items()
                      if key not in exclude
                  }
              else:
                  fields = _E_fields.copy()
  
              if required:
                  for field in required:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = False
  
              if optional:
                  for field in optional:
                      fields[field] = fields[field].copy()
                      fields[field]['optional'] = True
  
              if relations:
                  raise ValueError('Model: "E" has no relational fields.')
          except KeyError as exc:
              raise ValueError(
                  f'{exc.args[0]} is not a valid E / {name} field.'
              ) from None
  
          models = partial_models_ctx.get()
  
          # mypy does not like this as we are assigning a
          # Dict[Literal[str]] to a Dict[str] but this is fine
          models[name] = fields  # type: ignore[assignment]
          partial_models_ctx.set(models)
          _created_partial_types.add(name)
  
  
  
  _Post_relational_fields: Set[str] = {
          'author',
      }
  _Post_fields: Dict['types.PostKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'created_at': {
          'name': 'created_at',
          'is_list': False,
          'optional': False,
          'type': 'datetime.datetime',
      },
      'title': {
          'name': 'title',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'content': {
          'name': 'content',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'published': {
          'name': 'published',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'author': {
          'name': 'author',
          'is_list': False,
          'optional': True,
          'type': 'models.User',
      },
      'author_id': {
          'name': 'author_id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
  }
  
  _User_relational_fields: Set[str] = {
          'posts',
      }
  _User_fields: Dict['types.UserKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'email': {
          'name': 'email',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'int': {
          'name': 'int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'optional_int': {
          'name': 'optional_int',
          'is_list': False,
          'optional': True,
          'type': 'int',
      },
      'float': {
          'name': 'float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
      'optional_float': {
          'name': 'optional_float',
          'is_list': False,
          'optional': True,
          'type': 'float',
      },
      'string': {
          'name': 'string',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'optional_string': {
          'name': 'optional_string',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'enum': {
          'name': 'enum',
          'is_list': False,
          'optional': False,
          'type': 'enums.ABeautifulEnum',
      },
      'optional_enum': {
          'name': 'optional_enum',
          'is_list': False,
          'optional': True,
          'type': 'enums.ABeautifulEnum',
      },
      'boolean': {
          'name': 'boolean',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'optional_boolean': {
          'name': 'optional_boolean',
          'is_list': False,
          'optional': True,
          'type': 'bool',
      },
      'posts': {
          'name': 'posts',
          'is_list': True,
          'optional': True,
          'type': 'List[\'models.Post\']',
      },
  }
  
  _M_relational_fields: Set[str] = {
          'n',
      }
  _M_fields: Dict['types.MKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'n': {
          'name': 'n',
          'is_list': True,
          'optional': True,
          'type': 'List[\'models.N\']',
      },
      'int': {
          'name': 'int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'optional_int': {
          'name': 'optional_int',
          'is_list': False,
          'optional': True,
          'type': 'int',
      },
      'float': {
          'name': 'float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
      'optional_float': {
          'name': 'optional_float',
          'is_list': False,
          'optional': True,
          'type': 'float',
      },
      'string': {
          'name': 'string',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'optional_string': {
          'name': 'optional_string',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'enum': {
          'name': 'enum',
          'is_list': False,
          'optional': False,
          'type': 'enums.ABeautifulEnum',
      },
      'optional_enum': {
          'name': 'optional_enum',
          'is_list': False,
          'optional': True,
          'type': 'enums.ABeautifulEnum',
      },
      'boolean': {
          'name': 'boolean',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'optional_boolean': {
          'name': 'optional_boolean',
          'is_list': False,
          'optional': True,
          'type': 'bool',
      },
  }
  
  _N_relational_fields: Set[str] = {
          'm',
      }
  _N_fields: Dict['types.NKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'm': {
          'name': 'm',
          'is_list': True,
          'optional': True,
          'type': 'List[\'models.M\']',
      },
      'int': {
          'name': 'int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'optional_int': {
          'name': 'optional_int',
          'is_list': False,
          'optional': True,
          'type': 'int',
      },
      'float': {
          'name': 'float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
      'optional_float': {
          'name': 'optional_float',
          'is_list': False,
          'optional': True,
          'type': 'float',
      },
      'string': {
          'name': 'string',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'optional_string': {
          'name': 'optional_string',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'json_': {
          'name': 'json_',
          'is_list': False,
          'optional': False,
          'type': 'fields.Json',
      },
      'optional_json': {
          'name': 'optional_json',
          'is_list': False,
          'optional': True,
          'type': 'fields.Json',
      },
      'enum': {
          'name': 'enum',
          'is_list': False,
          'optional': False,
          'type': 'enums.ABeautifulEnum',
      },
      'optional_enum': {
          'name': 'optional_enum',
          'is_list': False,
          'optional': True,
          'type': 'enums.ABeautifulEnum',
      },
      'boolean': {
          'name': 'boolean',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'optional_boolean': {
          'name': 'optional_boolean',
          'is_list': False,
          'optional': True,
          'type': 'bool',
      },
  }
  
  _OneOptional_relational_fields: Set[str] = {
          'many',
      }
  _OneOptional_fields: Dict['types.OneOptionalKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'many': {
          'name': 'many',
          'is_list': True,
          'optional': True,
          'type': 'List[\'models.ManyRequired\']',
      },
      'int': {
          'name': 'int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'optional_int': {
          'name': 'optional_int',
          'is_list': False,
          'optional': True,
          'type': 'int',
      },
      'float': {
          'name': 'float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
      'optional_float': {
          'name': 'optional_float',
          'is_list': False,
          'optional': True,
          'type': 'float',
      },
      'string': {
          'name': 'string',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'optional_string': {
          'name': 'optional_string',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'enum': {
          'name': 'enum',
          'is_list': False,
          'optional': False,
          'type': 'enums.ABeautifulEnum',
      },
      'optional_enum': {
          'name': 'optional_enum',
          'is_list': False,
          'optional': True,
          'type': 'enums.ABeautifulEnum',
      },
      'boolean': {
          'name': 'boolean',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'optional_boolean': {
          'name': 'optional_boolean',
          'is_list': False,
          'optional': True,
          'type': 'bool',
      },
  }
  
  _ManyRequired_relational_fields: Set[str] = {
          'one',
      }
  _ManyRequired_fields: Dict['types.ManyRequiredKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'one': {
          'name': 'one',
          'is_list': False,
          'optional': True,
          'type': 'models.OneOptional',
      },
      'one_optional_id': {
          'name': 'one_optional_id',
          'is_list': False,
          'optional': True,
          'type': 'int',
      },
      'int': {
          'name': 'int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'optional_int': {
          'name': 'optional_int',
          'is_list': False,
          'optional': True,
          'type': 'int',
      },
      'float': {
          'name': 'float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
      'optional_float': {
          'name': 'optional_float',
          'is_list': False,
          'optional': True,
          'type': 'float',
      },
      'string': {
          'name': 'string',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'optional_string': {
          'name': 'optional_string',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'enum': {
          'name': 'enum',
          'is_list': False,
          'optional': False,
          'type': 'enums.ABeautifulEnum',
      },
      'optional_enum': {
          'name': 'optional_enum',
          'is_list': False,
          'optional': True,
          'type': 'enums.ABeautifulEnum',
      },
      'boolean': {
          'name': 'boolean',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'optional_boolean': {
          'name': 'optional_boolean',
          'is_list': False,
          'optional': True,
          'type': 'bool',
      },
  }
  
  _Lists_relational_fields: Set[str] = set()  # pyright: reportUnusedVariable=false
  _Lists_fields: Dict['types.ListsKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'strings': {
          'name': 'strings',
          'is_list': True,
          'optional': False,
          'type': 'List[str]',
      },
      'bytes': {
          'name': 'bytes',
          'is_list': True,
          'optional': False,
          'type': 'List[\'fields.Base64\']',
      },
      'dates': {
          'name': 'dates',
          'is_list': True,
          'optional': False,
          'type': 'List[datetime.datetime]',
      },
      'bools': {
          'name': 'bools',
          'is_list': True,
          'optional': False,
          'type': 'List[bool]',
      },
      'ints': {
          'name': 'ints',
          'is_list': True,
          'optional': False,
          'type': 'List[int]',
      },
      'floats': {
          'name': 'floats',
          'is_list': True,
          'optional': False,
          'type': 'List[float]',
      },
      'bigints': {
          'name': 'bigints',
          'is_list': True,
          'optional': False,
          'type': 'List[int]',
      },
      'json_objects': {
          'name': 'json_objects',
          'is_list': True,
          'optional': False,
          'type': 'List[\'fields.Json\']',
      },
  }
  
  _A_relational_fields: Set[str] = set()  # pyright: reportUnusedVariable=false
  _A_fields: Dict['types.AKeys', PartialModelField] = {
      'email': {
          'name': 'email',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'name': {
          'name': 'name',
          'is_list': False,
          'optional': True,
          'type': 'str',
      },
      'int': {
          'name': 'int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'sInt': {
          'name': 'sInt',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'inc_int': {
          'name': 'inc_int',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'inc_sInt': {
          'name': 'inc_sInt',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'bInt': {
          'name': 'bInt',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
      'inc_bInt': {
          'name': 'inc_bInt',
          'is_list': False,
          'optional': False,
          'type': 'int',
      },
  }
  
  _B_relational_fields: Set[str] = set()  # pyright: reportUnusedVariable=false
  _B_fields: Dict['types.BKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'float': {
          'name': 'float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
      'd_float': {
          'name': 'd_float',
          'is_list': False,
          'optional': False,
          'type': 'float',
      },
  }
  
  _C_relational_fields: Set[str] = set()  # pyright: reportUnusedVariable=false
  _C_fields: Dict['types.CKeys', PartialModelField] = {
      'char': {
          'name': 'char',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'v_char': {
          'name': 'v_char',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'text': {
          'name': 'text',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'bit': {
          'name': 'bit',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'v_bit': {
          'name': 'v_bit',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'uuid': {
          'name': 'uuid',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
  }
  
  _D_relational_fields: Set[str] = set()  # pyright: reportUnusedVariable=false
  _D_fields: Dict['types.DKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'bool': {
          'name': 'bool',
          'is_list': False,
          'optional': False,
          'type': 'bool',
      },
      'xml': {
          'name': 'xml',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'json_': {
          'name': 'json_',
          'is_list': False,
          'optional': False,
          'type': 'fields.Json',
      },
      'jsonb': {
          'name': 'jsonb',
          'is_list': False,
          'optional': False,
          'type': 'fields.Json',
      },
      'binary': {
          'name': 'binary',
          'is_list': False,
          'optional': False,
          'type': 'fields.Base64',
      },
  }
  
  _E_relational_fields: Set[str] = set()  # pyright: reportUnusedVariable=false
  _E_fields: Dict['types.EKeys', PartialModelField] = {
      'id': {
          'name': 'id',
          'is_list': False,
          'optional': False,
          'type': 'str',
      },
      'date': {
          'name': 'date',
          'is_list': False,
          'optional': False,
          'type': 'datetime.datetime',
      },
      'time': {
          'name': 'time',
          'is_list': False,
          'optional': False,
          'type': 'datetime.datetime',
      },
      'ts': {
          'name': 'ts',
          'is_list': False,
          'optional': False,
          'type': 'datetime.datetime',
      },
  }
  
  
  
  # we have to import ourselves as relation types are namespaced to models
  # e.g. models.Post
  from . import models, actions
  
  # required to support relationships between models
  Post.update_forward_refs()
  User.update_forward_refs()
  M.update_forward_refs()
  N.update_forward_refs()
  OneOptional.update_forward_refs()
  ManyRequired.update_forward_refs()
  Lists.update_forward_refs()
  A.update_forward_refs()
  B.update_forward_refs()
  C.update_forward_refs()
  D.update_forward_refs()
  E.update_forward_refs()
  
  '
---
# name: test_sync[partials.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Callable,
      Generic,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  from typing_extensions import TypedDict, Literal
  
  # -- template partials.py.jinja --
  from pydantic import BaseModel, Field, validator
  from . import types, models, fields, enums
  
  
  
  # users can modify relational types which are then namespaced to partials.
  # so we have to import ourselves in order to resolve forward references
  from . import partials
  
  
  # fmt: on
  
  '
---
# name: test_sync[types.py]
  '
  # -*- coding: utf-8 -*-
  # code generated by Prisma. DO NOT EDIT.
  # pylint: disable=all
  # pyright: reportUnusedImport=false
  # fmt: off
  
  # global imports for type checking
  import sys
  import datetime
  from typing import (
      TYPE_CHECKING,
      Optional,
      Iterable,
      Iterator,
      Callable,
      Generic,
      Mapping,
      Tuple,
      Union,
      List,
      Dict,
      Type,
      Any,
      Set,
      overload,
      cast,
  )
  from typing_extensions import TypedDict, Literal
  
  # -- template types.py.jinja --
  from .utils import _NoneType
  
  
  
  # TODO: cleanup whitespace control
  # TODO: add an argument to signify that the last iteration should be skipped
  
  
  SortMode = Literal['default', 'insensitive']
  SortOrder = Literal['asc', 'desc']
  
  
  class _DatasourceOverrideOptional(TypedDict, total=False):
      env: str
      name: str
  
  
  class DatasourceOverride(_DatasourceOverrideOptional):
      url: str
  
  
  # types that can be serialized to json by our query builder
  Serializable = Union[
      None,
      bool,
      float,
      int,
      str,
      datetime.datetime,
      List[Any],
      Dict[None, Any],
      Dict[bool, Any],
      Dict[float, Any],
      Dict[int, Any],
      Dict[str, Any],
  ]
  
  
      
  
  StringFilter = TypedDict(
      'StringFilter',
      {
          'equals': str,
          'not_in': List[str],
          'lt': str,
          'lte': str,
          'gt': str,
          'gte': str,
          'contains': str,
          'startswith': str,
          'endswith': str,
          'in': List[str],
          'not': Union[str, 'StringFilterRecursive1'],
          'mode': SortMode,
      },
      total=False,
  )
  
  
  StringFilterRecursive1 = TypedDict(
      'StringFilterRecursive1',
      {
          'equals': str,
          'not_in': List[str],
          'lt': str,
          'lte': str,
          'gt': str,
          'gte': str,
          'contains': str,
          'startswith': str,
          'endswith': str,
          'in': List[str],
          'not': Union[str, 'StringFilterRecursive2'],
          'mode': SortMode,
      },
      total=False,
  )
  
  
  StringFilterRecursive2 = TypedDict(
      'StringFilterRecursive2',
      {
          'equals': str,
          'not_in': List[str],
          'lt': str,
          'lte': str,
          'gt': str,
          'gte': str,
          'contains': str,
          'startswith': str,
          'endswith': str,
          'in': List[str],
                  'mode': SortMode,
      },
      total=False,
  )
  
      
  
  DateTimeFilter = TypedDict(
      'DateTimeFilter',
      {
          'equals': datetime.datetime,
          'not_in': List[datetime.datetime],
          'lt': datetime.datetime,
          'lte': datetime.datetime,
          'gt': datetime.datetime,
          'gte': datetime.datetime,
          'in': List[datetime.datetime],
          'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
      },
      total=False,
  )
  
  
  DateTimeFilterRecursive1 = TypedDict(
      'DateTimeFilterRecursive1',
      {
          'equals': datetime.datetime,
          'not_in': List[datetime.datetime],
          'lt': datetime.datetime,
          'lte': datetime.datetime,
          'gt': datetime.datetime,
          'gte': datetime.datetime,
          'in': List[datetime.datetime],
          'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
      },
      total=False,
  )
  
  
  DateTimeFilterRecursive2 = TypedDict(
      'DateTimeFilterRecursive2',
      {
          'equals': datetime.datetime,
          'not_in': List[datetime.datetime],
          'lt': datetime.datetime,
          'lte': datetime.datetime,
          'gt': datetime.datetime,
          'gte': datetime.datetime,
          'in': List[datetime.datetime],
              },
      total=False,
  )
  
  
      
  
  BooleanFilter = TypedDict(
      'BooleanFilter',
      {
          'equals': bool,
          'not': Union[bool, 'BooleanFilterRecursive1'],
      },
      total=False,
  )
  
  
  BooleanFilterRecursive1 = TypedDict(
      'BooleanFilterRecursive1',
      {
          'equals': bool,
          'not': Union[bool, 'BooleanFilterRecursive2'],
      },
      total=False,
  )
  
  
  BooleanFilterRecursive2 = TypedDict(
      'BooleanFilterRecursive2',
      {
          'equals': bool,
              },
      total=False,
  )
  
  
      
  
  IntFilter = TypedDict(
      'IntFilter',
      {
          'equals': int,
          'not_in': List[int],
          'lt': int,
          'lte': int,
          'gt': int,
          'gte': int,
          'in': List[int],
          'not': Union[int, 'IntFilterRecursive1'],
      },
      total=False,
  )
  
  
  IntFilterRecursive1 = TypedDict(
      'IntFilterRecursive1',
      {
          'equals': int,
          'not_in': List[int],
          'lt': int,
          'lte': int,
          'gt': int,
          'gte': int,
          'in': List[int],
          'not': Union[int, 'IntFilterRecursive2'],
      },
      total=False,
  )
  
  
  IntFilterRecursive2 = TypedDict(
      'IntFilterRecursive2',
      {
          'equals': int,
          'not_in': List[int],
          'lt': int,
          'lte': int,
          'gt': int,
          'gte': int,
          'in': List[int],
              },
      total=False,
  )
  
  
  BigIntFilter = IntFilter
      
  
  FloatFilter = TypedDict(
      'FloatFilter',
      {
          'equals': float,
          'not_in': List[float],
          'lt': float,
          'lte': float,
          'gt': float,
          'gte': float,
          'in': List[float],
          'not': Union[float, 'FloatFilterRecursive1'],
      },
      total=False,
  )
  
  
  FloatFilterRecursive1 = TypedDict(
      'FloatFilterRecursive1',
      {
          'equals': float,
          'not_in': List[float],
          'lt': float,
          'lte': float,
          'gt': float,
          'gte': float,
          'in': List[float],
          'not': Union[float, 'FloatFilterRecursive2'],
      },
      total=False,
  )
  
  
  FloatFilterRecursive2 = TypedDict(
      'FloatFilterRecursive2',
      {
          'equals': float,
          'not_in': List[float],
          'lt': float,
          'lte': float,
          'gt': float,
          'gte': float,
          'in': List[float],
              },
      total=False,
  )
  
      
  
  BytesFilter = TypedDict(
      'BytesFilter',
      {
          'equals': 'fields.Base64',
          'not': Union['fields.Base64', 'BytesFilterRecursive1'],
      },
      total=False,
  )
  
  
  BytesFilterRecursive1 = TypedDict(
      'BytesFilterRecursive1',
      {
          'equals': 'fields.Base64',
          'not': Union['fields.Base64', 'BytesFilterRecursive2'],
      },
      total=False,
  )
  
  
  BytesFilterRecursive2 = TypedDict(
      'BytesFilterRecursive2',
      {
          'equals': 'fields.Base64',
              },
      total=False,
  )
  
  # TODO: preview feature for improving JSON filtering
  JsonFilter = TypedDict(
      'JsonFilter',
      {
          'equals': 'fields.Json',
          'not': 'fields.Json',
      },
      total=False,
  )
  
  
  class _FloatSetInput(TypedDict):
      set: float
  
  
  class _FloatDivideInput(TypedDict):
      divide: float
  
  
  class _FloatMultiplyInput(TypedDict):
      multiply: float
  
  
  class _FloatIncrementInput(TypedDict):
      increment: float
  
  
  class _FloatDecrementInput(TypedDict):
      decrement: float
  
  
  class _IntSetInput(TypedDict):
      set: int
  
  
  class _IntDivideInput(TypedDict):
      divide: int
  
  
  class _IntMultiplyInput(TypedDict):
      multiply: int
  
  
  class _IntIncrementInput(TypedDict):
      increment: int
  
  
  class _IntDecrementInput(TypedDict):
      decrement: int
  
  
  AtomicFloatInput = Union[
      _FloatSetInput,
      _FloatDivideInput,
      _FloatMultiplyInput,
      _FloatIncrementInput,
      _FloatDecrementInput,
  ]
  AtomicIntInput = Union[
      _IntSetInput,
      _IntDivideInput,
      _IntMultiplyInput,
      _IntIncrementInput,
      _IntDecrementInput,
  ]
  AtomicBigIntInput = AtomicIntInput
  
  class _StringListFilterEqualsInput(TypedDict):
      equals: Optional[List[str]]
  
  
  class _StringListFilterHasInput(TypedDict):
      has: str
  
  
  class _StringListFilterHasEveryInput(TypedDict):
      has_every: List[str]
  
  
  class _StringListFilterHasSomeInput(TypedDict):
      has_some: List[str]
  
  
  class _StringListFilterIsEmptyInput(TypedDict):
      is_empty: bool
  
  
  StringListFilter = Union[
      _StringListFilterHasInput,
      _StringListFilterEqualsInput,
      _StringListFilterHasSomeInput,
      _StringListFilterIsEmptyInput,
      _StringListFilterHasEveryInput,
  ]
  
  
  class _StringListUpdateSet(TypedDict):
      set: List[str]
  
  
  class _StringListUpdatePush(TypedDict):
      push: List[str]
  
  
  StringListUpdate = Union[
      List[str],
      _StringListUpdateSet,
      _StringListUpdatePush,
  ]
  
  class _BytesListFilterEqualsInput(TypedDict):
      equals: Optional[List['fields.Base64']]
  
  
  class _BytesListFilterHasInput(TypedDict):
      has: 'fields.Base64'
  
  
  class _BytesListFilterHasEveryInput(TypedDict):
      has_every: List['fields.Base64']
  
  
  class _BytesListFilterHasSomeInput(TypedDict):
      has_some: List['fields.Base64']
  
  
  class _BytesListFilterIsEmptyInput(TypedDict):
      is_empty: bool
  
  
  BytesListFilter = Union[
      _BytesListFilterHasInput,
      _BytesListFilterEqualsInput,
      _BytesListFilterHasSomeInput,
      _BytesListFilterIsEmptyInput,
      _BytesListFilterHasEveryInput,
  ]
  
  
  class _BytesListUpdateSet(TypedDict):
      set: List['fields.Base64']
  
  
  class _BytesListUpdatePush(TypedDict):
      push: List['fields.Base64']
  
  
  BytesListUpdate = Union[
      List['fields.Base64'],
      _BytesListUpdateSet,
      _BytesListUpdatePush,
  ]
  
  class _DateTimeListFilterEqualsInput(TypedDict):
      equals: Optional[List[datetime.datetime]]
  
  
  class _DateTimeListFilterHasInput(TypedDict):
      has: datetime.datetime
  
  
  class _DateTimeListFilterHasEveryInput(TypedDict):
      has_every: List[datetime.datetime]
  
  
  class _DateTimeListFilterHasSomeInput(TypedDict):
      has_some: List[datetime.datetime]
  
  
  class _DateTimeListFilterIsEmptyInput(TypedDict):
      is_empty: bool
  
  
  DateTimeListFilter = Union[
      _DateTimeListFilterHasInput,
      _DateTimeListFilterEqualsInput,
      _DateTimeListFilterHasSomeInput,
      _DateTimeListFilterIsEmptyInput,
      _DateTimeListFilterHasEveryInput,
  ]
  
  
  class _DateTimeListUpdateSet(TypedDict):
      set: List[datetime.datetime]
  
  
  class _DateTimeListUpdatePush(TypedDict):
      push: List[datetime.datetime]
  
  
  DateTimeListUpdate = Union[
      List[datetime.datetime],
      _DateTimeListUpdateSet,
      _DateTimeListUpdatePush,
  ]
  
  class _BooleanListFilterEqualsInput(TypedDict):
      equals: Optional[List[bool]]
  
  
  class _BooleanListFilterHasInput(TypedDict):
      has: bool
  
  
  class _BooleanListFilterHasEveryInput(TypedDict):
      has_every: List[bool]
  
  
  class _BooleanListFilterHasSomeInput(TypedDict):
      has_some: List[bool]
  
  
  class _BooleanListFilterIsEmptyInput(TypedDict):
      is_empty: bool
  
  
  BooleanListFilter = Union[
      _BooleanListFilterHasInput,
      _BooleanListFilterEqualsInput,
      _BooleanListFilterHasSomeInput,
      _BooleanListFilterIsEmptyInput,
      _BooleanListFilterHasEveryInput,
  ]
  
  
  class _BooleanListUpdateSet(TypedDict):
      set: List[bool]
  
  
  class _BooleanListUpdatePush(TypedDict):
      push: List[bool]
  
  
  BooleanListUpdate = Union[
      List[bool],
      _BooleanListUpdateSet,
      _BooleanListUpdatePush,
  ]
  
  class _IntListFilterEqualsInput(TypedDict):
      equals: Optional[List[int]]
  
  
  class _IntListFilterHasInput(TypedDict):
      has: int
  
  
  class _IntListFilterHasEveryInput(TypedDict):
      has_every: List[int]
  
  
  class _IntListFilterHasSomeInput(TypedDict):
      has_some: List[int]
  
  
  class _IntListFilterIsEmptyInput(TypedDict):
      is_empty: bool
  
  
  IntListFilter = Union[
      _IntListFilterHasInput,
      _IntListFilterEqualsInput,
      _IntListFilterHasSomeInput,
      _IntListFilterIsEmptyInput,
      _IntListFilterHasEveryInput,
  ]
  
  
  class _IntListUpdateSet(TypedDict):
      set: List[int]
  
  
  class _IntListUpdatePush(TypedDict):
      push: List[int]
  
  
  IntListUpdate = Union[
      List[int],
      _IntListUpdateSet,
      _IntListUpdatePush,
  ]
  
  class _BigIntListFilterEqualsInput(TypedDict):
      equals: Optional[List[int]]
  
  
  class _BigIntListFilterHasInput(TypedDict):
      has: int
  
  
  class _BigIntListFilterHasEveryInput(TypedDict):
      has_every: List[int]
  
  
  class _BigIntListFilterHasSomeInput(TypedDict):
      has_some: List[int]
  
  
  class _BigIntListFilterIsEmptyInput(TypedDict):
      is_empty: bool
  
  
  BigIntListFilter = Union[
      _BigIntListFilterHasInput,
      _BigIntListFilterEqualsInput,
      _BigIntListFilterHasSomeInput,
      _BigIntListFilterIsEmptyInput,
      _BigIntListFilterHasEveryInput,
  ]
  
  
  class _BigIntListUpdateSet(TypedDict):
      set: List[int]
  
  
  class _BigIntListUpdatePush(TypedDict):
      push: List[int]
  
  
  BigIntListUpdate = Union[
      List[int],
      _BigIntListUpdateSet,
      _BigIntListUpdatePush,
  ]
  
  class _FloatListFilterEqualsInput(TypedDict):
      equals: Optional[List[float]]
  
  
  class _FloatListFilterHasInput(TypedDict):
      has: float
  
  
  class _FloatListFilterHasEveryInput(TypedDict):
      has_every: List[float]
  
  
  class _FloatListFilterHasSomeInput(TypedDict):
      has_some: List[float]
  
  
  class _FloatListFilterIsEmptyInput(TypedDict):
      is_empty: bool
  
  
  FloatListFilter = Union[
      _FloatListFilterHasInput,
      _FloatListFilterEqualsInput,
      _FloatListFilterHasSomeInput,
      _FloatListFilterIsEmptyInput,
      _FloatListFilterHasEveryInput,
  ]
  
  
  class _FloatListUpdateSet(TypedDict):
      set: List[float]
  
  
  class _FloatListUpdatePush(TypedDict):
      push: List[float]
  
  
  FloatListUpdate = Union[
      List[float],
      _FloatListUpdateSet,
      _FloatListUpdatePush,
  ]
  
  class _JsonListFilterEqualsInput(TypedDict):
      equals: Optional[List['fields.Json']]
  
  
  class _JsonListFilterHasInput(TypedDict):
      has: 'fields.Json'
  
  
  class _JsonListFilterHasEveryInput(TypedDict):
      has_every: List['fields.Json']
  
  
  class _JsonListFilterHasSomeInput(TypedDict):
      has_some: List['fields.Json']
  
  
  class _JsonListFilterIsEmptyInput(TypedDict):
      is_empty: bool
  
  
  JsonListFilter = Union[
      _JsonListFilterHasInput,
      _JsonListFilterEqualsInput,
      _JsonListFilterHasSomeInput,
      _JsonListFilterIsEmptyInput,
      _JsonListFilterHasEveryInput,
  ]
  
  
  class _JsonListUpdateSet(TypedDict):
      set: List['fields.Json']
  
  
  class _JsonListUpdatePush(TypedDict):
      push: List['fields.Json']
  
  
  JsonListUpdate = Union[
      List['fields.Json'],
      _JsonListUpdateSet,
      _JsonListUpdatePush,
  ]
  
  class _ABeautifulEnumListFilterEqualsInput(TypedDict):
      equals: Optional[List['enums.ABeautifulEnum']]
  
  
  class _ABeautifulEnumListFilterHasInput(TypedDict):
      has: 'enums.ABeautifulEnum'
  
  
  class _ABeautifulEnumListFilterHasEveryInput(TypedDict):
      has_every: List['enums.ABeautifulEnum']
  
  
  class _ABeautifulEnumListFilterHasSomeInput(TypedDict):
      has_some: List['enums.ABeautifulEnum']
  
  
  class _ABeautifulEnumListFilterIsEmptyInput(TypedDict):
      is_empty: bool
  
  
  ABeautifulEnumListFilter = Union[
      _ABeautifulEnumListFilterHasInput,
      _ABeautifulEnumListFilterEqualsInput,
      _ABeautifulEnumListFilterHasSomeInput,
      _ABeautifulEnumListFilterIsEmptyInput,
      _ABeautifulEnumListFilterHasEveryInput,
  ]
  
  
  class _ABeautifulEnumListUpdateSet(TypedDict):
      set: List['enums.ABeautifulEnum']
  
  
  class _ABeautifulEnumListUpdatePush(TypedDict):
      push: List['enums.ABeautifulEnum']
  
  
  ABeautifulEnumListUpdate = Union[
      List['enums.ABeautifulEnum'],
      _ABeautifulEnumListUpdateSet,
      _ABeautifulEnumListUpdatePush,
  ]
  
  
  # Post types
  
  class PostOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the Post create method"""
      id: int
      created_at: datetime.datetime
      content: Optional[str]
      published: bool
      author: 'UserCreateNestedWithoutRelationsInput'
  
  
  class PostCreateInput(PostOptionalCreateInput):
      """Required arguments to the Post create method"""
      title: str
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class PostOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the Post create method, without relations"""
      id: int
      created_at: datetime.datetime
      content: Optional[str]
      published: bool
  
  
  class PostCreateWithoutRelationsInput(PostOptionalCreateWithoutRelationsInput):
      """Required arguments to the Post create method, without relations"""
      title: str
  
  
  class PostCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'PostCreateWithoutRelationsInput'
      connect: 'PostWhereUniqueInput'
  
  
  class PostCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['PostCreateWithoutRelationsInput', List['PostCreateWithoutRelationsInput']]
      connect: Union['PostWhereUniqueInput', List['PostWhereUniqueInput']]
  
  
  
  _PostWhereUnique_id_Input = TypedDict(
      '_PostWhereUnique_id_Input',
      {
          'id': 'int',
      },
      total=True
  )
  
  PostWhereUniqueInput = _PostWhereUnique_id_Input
  
  
  class PostUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      created_at: datetime.datetime
      title: str
      content: Optional[str]
      published: bool
      author: 'UserUpdateOneWithoutRelationsInput'
  
  
  class PostUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: Union[AtomicIntInput, int]
      created_at: datetime.datetime
      title: str
      content: Optional[str]
      published: bool
      author: 'UserUpdateOneWithoutRelationsInput'
  
  
  class PostUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['PostCreateWithoutRelationsInput']
      connect: List['PostWhereUniqueInput']
      set: List['PostWhereUniqueInput']
      disconnect: List['PostWhereUniqueInput']
      delete: List['PostWhereUniqueInput']
  
      # TODO
      # update: List['PostUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['PostUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['PostScalarWhereInput']
      # upsert: List['PostUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['PostCreateOrConnectWithoutRelationsInput']
  
  
  class PostUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'PostCreateWithoutRelationsInput'
      connect: 'PostWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'PostUpdateInput'
      # upsert: 'PostUpsertWithoutRelationsInput'
      # connectOrCreate: 'PostCreateOrConnectWithoutRelationsInput'
  
  
  class PostUpsertInput(TypedDict):
      create: 'PostCreateInput'
      update: 'PostUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class PostOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      created_at: 'SortOrder'
      title: 'SortOrder'
      content: 'SortOrder'
      published: 'SortOrder'
      author_id: 'SortOrder'
  
  
  # recursive Post types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/
  
  PostRelationFilter = TypedDict(
      'PostRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class PostListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class PostInclude(TypedDict, total=False):
      """Post relational arguments"""
      author: Union[bool, 'UserArgsFromPost']
  
  
      
  
  class PostIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
      author: Union[bool, 'UserArgsFromPostRecursive1']
  
  
  class PostIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
      author: Union[bool, 'UserArgsFromPostRecursive2']
  
  
  class PostIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class PostArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyPostArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
      posts: Union[bool, 'FindManyPostArgsFromPostRecursive1']
  
  
  class UserIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
      posts: Union[bool, 'FindManyPostArgsFromPostRecursive2']
  
  
  class UserIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class UserArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyUserArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
      n: Union[bool, 'FindManyNArgsFromPostRecursive1']
  
  
  class MIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
      n: Union[bool, 'FindManyNArgsFromPostRecursive2']
  
  
  class MIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class MArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyMArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
      m: Union[bool, 'FindManyMArgsFromPostRecursive1']
  
  
  class NIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
      m: Union[bool, 'FindManyMArgsFromPostRecursive2']
  
  
  class NIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class NArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyNArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
      many: Union[bool, 'FindManyManyRequiredArgsFromPostRecursive1']
  
  
  class OneOptionalIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
      many: Union[bool, 'FindManyManyRequiredArgsFromPostRecursive2']
  
  
  class OneOptionalIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class OneOptionalArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyOneOptionalArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
      one: Union[bool, 'OneOptionalArgsFromPostRecursive1']
  
  
  class ManyRequiredIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
      one: Union[bool, 'OneOptionalArgsFromPostRecursive2']
  
  
  class ManyRequiredIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class ManyRequiredArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyManyRequiredArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class ListsIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class ListsIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class ListsIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class ListsArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class ListsArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class ListsArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyListsArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class FindManyListsArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class FindManyListsArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      
      
  
  class AIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class AIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class AIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class AArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyAArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class BIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class BIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class BArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyBArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class CIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class CIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class CArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyCArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class DIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class DIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class DArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyDArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromPost(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class EIncludeFromPostRecursive1(TypedDict, total=False):
      """Relational arguments for Post"""
  
  
  class EIncludeFromPostRecursive2(TypedDict, total=False):
      """Relational arguments for Post"""
  
      
  
  class EArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      
      
  
  class FindManyEArgsFromPost(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromPostRecursive1(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromPostRecursive2(TypedDict, total=False):
      """Arguments for Post"""
      take: int
      skip: int
      order_by: Union['PostOrderByInput', List['PostOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyPostArgs = FindManyPostArgsFromPost
  FindFirstPostArgs = FindManyPostArgsFromPost
  
  
      
  
  class PostWhereInput(TypedDict, total=False):
      """Post arguments for searching"""
      id: Union[int, 'types.IntFilter']
      created_at: Union[datetime.datetime, 'types.DateTimeFilter']
      title: Union[str, 'types.StringFilter']
      content: Union[str, 'types.StringFilter']
      published: Union[bool, 'types.BooleanFilter']
      author: 'UserRelationFilter'
      author_id: Union[int, 'types.IntFilter']
  
      # should be noted that AND and NOT should be Union['PostWhereInputRecursive1', List['PostWhereInputRecursive1']]
      # but this causes mypy to hang :/
      AND: List['PostWhereInputRecursive1']
      OR: List['PostWhereInputRecursive1']
      NOT: List['PostWhereInputRecursive1']
  
  
  class PostWhereInputRecursive1(TypedDict, total=False):
      """Post arguments for searching"""
      id: Union[int, 'types.IntFilter']
      created_at: Union[datetime.datetime, 'types.DateTimeFilter']
      title: Union[str, 'types.StringFilter']
      content: Union[str, 'types.StringFilter']
      published: Union[bool, 'types.BooleanFilter']
      author: 'UserRelationFilter'
      author_id: Union[int, 'types.IntFilter']
  
      # should be noted that AND and NOT should be Union['PostWhereInputRecursive2', List['PostWhereInputRecursive2']]
      # but this causes mypy to hang :/
      AND: List['PostWhereInputRecursive2']
      OR: List['PostWhereInputRecursive2']
      NOT: List['PostWhereInputRecursive2']
  
  
  class PostWhereInputRecursive2(TypedDict, total=False):
      """Post arguments for searching"""
      id: Union[int, 'types.IntFilter']
      created_at: Union[datetime.datetime, 'types.DateTimeFilter']
      title: Union[str, 'types.StringFilter']
      content: Union[str, 'types.StringFilter']
      published: Union[bool, 'types.BooleanFilter']
      author: 'UserRelationFilter'
      author_id: Union[int, 'types.IntFilter']
  
  
  
  PostCountAggregateInput = TypedDict(
      'PostCountAggregateInput',
      {
          'id': bool,
          'created_at': bool,
          'title': bool,
          'content': bool,
          'published': bool,
          'author_id': bool,
          '_all': bool,
      },
      total=False,
  )
  
  PostCountAggregateOutput = TypedDict(
      'PostCountAggregateOutput',
      {
          'id': int,
          'created_at': int,
          'title': int,
          'content': int,
          'published': int,
          'author_id': int,
          '_all': int,
      },
      total=False,
  )
  
  
  PostKeys = Literal[
      'id',
      'created_at',
      'title',
      'content',
      'published',
      'author',
      'author_id',
  ]
  
  PostRelationalFieldKeys = Literal[
          'author',
      ]
  
  # User types
  
  class UserOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the User create method"""
      id: int
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
      posts: 'PostCreateManyNestedWithoutRelationsInput'
  
  
  class UserCreateInput(UserOptionalCreateInput):
      """Required arguments to the User create method"""
      email: str
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class UserOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the User create method, without relations"""
      id: int
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class UserCreateWithoutRelationsInput(UserOptionalCreateWithoutRelationsInput):
      """Required arguments to the User create method, without relations"""
      email: str
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  class UserCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'UserCreateWithoutRelationsInput'
      connect: 'UserWhereUniqueInput'
  
  
  class UserCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['UserCreateWithoutRelationsInput', List['UserCreateWithoutRelationsInput']]
      connect: Union['UserWhereUniqueInput', List['UserWhereUniqueInput']]
  
  
  
  _UserWhereUnique_id_Input = TypedDict(
      '_UserWhereUnique_id_Input',
      {
          'id': 'int',
      },
      total=True
  )
  
  _UserWhereUnique_email_Input = TypedDict(
      '_UserWhereUnique_email_Input',
      {
          'email': 'str',
      },
      total=True
  )
  
  UserWhereUniqueInput = Union[
      '_UserWhereUnique_id_Input',
      '_UserWhereUnique_email_Input',
  ]
  
  
  class UserUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
      posts: 'PostUpdateManyWithoutRelationsInput'
  
  
  class UserUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: Union[AtomicIntInput, int]
      email: str
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
      posts: 'PostUpdateManyWithoutRelationsInput'
  
  
  class UserUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['UserCreateWithoutRelationsInput']
      connect: List['UserWhereUniqueInput']
      set: List['UserWhereUniqueInput']
      disconnect: List['UserWhereUniqueInput']
      delete: List['UserWhereUniqueInput']
  
      # TODO
      # update: List['UserUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['UserUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['UserScalarWhereInput']
      # upsert: List['UserUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['UserCreateOrConnectWithoutRelationsInput']
  
  
  class UserUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'UserCreateWithoutRelationsInput'
      connect: 'UserWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'UserUpdateInput'
      # upsert: 'UserUpsertWithoutRelationsInput'
      # connectOrCreate: 'UserCreateOrConnectWithoutRelationsInput'
  
  
  class UserUpsertInput(TypedDict):
      create: 'UserCreateInput'
      update: 'UserUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class UserOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      email: 'SortOrder'
      int: 'SortOrder'
      optional_int: 'SortOrder'
      float: 'SortOrder'
      optional_float: 'SortOrder'
      string: 'SortOrder'
      optional_string: 'SortOrder'
      enum: 'SortOrder'
      optional_enum: 'SortOrder'
      boolean: 'SortOrder'
      optional_boolean: 'SortOrder'
  
  
  # recursive User types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/
  
  UserRelationFilter = TypedDict(
      'UserRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class UserListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class UserInclude(TypedDict, total=False):
      """User relational arguments"""
      posts: Union[bool, 'FindManyPostArgsFromUser']
  
  
      
  
  class PostIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
      author: Union[bool, 'UserArgsFromUserRecursive1']
  
  
  class PostIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
      author: Union[bool, 'UserArgsFromUserRecursive2']
  
  
  class PostIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class PostArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyPostArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
      posts: Union[bool, 'FindManyPostArgsFromUserRecursive1']
  
  
  class UserIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
      posts: Union[bool, 'FindManyPostArgsFromUserRecursive2']
  
  
  class UserIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class UserArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyUserArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
      n: Union[bool, 'FindManyNArgsFromUserRecursive1']
  
  
  class MIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
      n: Union[bool, 'FindManyNArgsFromUserRecursive2']
  
  
  class MIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class MArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyMArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
      m: Union[bool, 'FindManyMArgsFromUserRecursive1']
  
  
  class NIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
      m: Union[bool, 'FindManyMArgsFromUserRecursive2']
  
  
  class NIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class NArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyNArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
      many: Union[bool, 'FindManyManyRequiredArgsFromUserRecursive1']
  
  
  class OneOptionalIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
      many: Union[bool, 'FindManyManyRequiredArgsFromUserRecursive2']
  
  
  class OneOptionalIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class OneOptionalArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyOneOptionalArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
      one: Union[bool, 'OneOptionalArgsFromUserRecursive1']
  
  
  class ManyRequiredIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
      one: Union[bool, 'OneOptionalArgsFromUserRecursive2']
  
  
  class ManyRequiredIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class ManyRequiredArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyManyRequiredArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class ListsIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class ListsIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class ListsIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class ListsArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class ListsArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class ListsArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyListsArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class FindManyListsArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class FindManyListsArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      
      
  
  class AIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class AIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class AIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class AArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyAArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class BIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class BIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class BArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyBArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class CIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class CIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class CArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyCArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class DIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class DIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class DArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyDArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromUser(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class EIncludeFromUserRecursive1(TypedDict, total=False):
      """Relational arguments for User"""
  
  
  class EIncludeFromUserRecursive2(TypedDict, total=False):
      """Relational arguments for User"""
  
      
  
  class EArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      
      
  
  class FindManyEArgsFromUser(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromUserRecursive1(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromUserRecursive2(TypedDict, total=False):
      """Arguments for User"""
      take: int
      skip: int
      order_by: Union['UserOrderByInput', List['UserOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyUserArgs = FindManyUserArgsFromUser
  FindFirstUserArgs = FindManyUserArgsFromUser
  
  
      
  
  class UserWhereInput(TypedDict, total=False):
      """User arguments for searching"""
      id: Union[int, 'types.IntFilter']
      email: Union[str, 'types.StringFilter']
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
      posts: 'PostListRelationFilter'
  
      # should be noted that AND and NOT should be Union['UserWhereInputRecursive1', List['UserWhereInputRecursive1']]
      # but this causes mypy to hang :/
      AND: List['UserWhereInputRecursive1']
      OR: List['UserWhereInputRecursive1']
      NOT: List['UserWhereInputRecursive1']
  
  
  class UserWhereInputRecursive1(TypedDict, total=False):
      """User arguments for searching"""
      id: Union[int, 'types.IntFilter']
      email: Union[str, 'types.StringFilter']
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
      posts: 'PostListRelationFilter'
  
      # should be noted that AND and NOT should be Union['UserWhereInputRecursive2', List['UserWhereInputRecursive2']]
      # but this causes mypy to hang :/
      AND: List['UserWhereInputRecursive2']
      OR: List['UserWhereInputRecursive2']
      NOT: List['UserWhereInputRecursive2']
  
  
  class UserWhereInputRecursive2(TypedDict, total=False):
      """User arguments for searching"""
      id: Union[int, 'types.IntFilter']
      email: Union[str, 'types.StringFilter']
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
      posts: 'PostListRelationFilter'
  
  
  
  UserCountAggregateInput = TypedDict(
      'UserCountAggregateInput',
      {
          'id': bool,
          'email': bool,
          'int': bool,
          'optional_int': bool,
          'float': bool,
          'optional_float': bool,
          'string': bool,
          'optional_string': bool,
          'enum': bool,
          'optional_enum': bool,
          'boolean': bool,
          'optional_boolean': bool,
          '_all': bool,
      },
      total=False,
  )
  
  UserCountAggregateOutput = TypedDict(
      'UserCountAggregateOutput',
      {
          'id': int,
          'email': int,
          'int': int,
          'optional_int': int,
          'float': int,
          'optional_float': int,
          'string': int,
          'optional_string': int,
          'enum': int,
          'optional_enum': int,
          'boolean': int,
          'optional_boolean': int,
          '_all': int,
      },
      total=False,
  )
  
  
  UserKeys = Literal[
      'id',
      'email',
      'int',
      'optional_int',
      'float',
      'optional_float',
      'string',
      'optional_string',
      'enum',
      'optional_enum',
      'boolean',
      'optional_boolean',
      'posts',
  ]
  
  UserRelationalFieldKeys = Literal[
          'posts',
      ]
  
  # M types
  
  class MOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the M create method"""
      id: int
      n: 'NCreateManyNestedWithoutRelationsInput'
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class MCreateInput(MOptionalCreateInput):
      """Required arguments to the M create method"""
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class MOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the M create method, without relations"""
      id: int
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class MCreateWithoutRelationsInput(MOptionalCreateWithoutRelationsInput):
      """Required arguments to the M create method, without relations"""
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  class MCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'MCreateWithoutRelationsInput'
      connect: 'MWhereUniqueInput'
  
  
  class MCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['MCreateWithoutRelationsInput', List['MCreateWithoutRelationsInput']]
      connect: Union['MWhereUniqueInput', List['MWhereUniqueInput']]
  
  
  
  _MWhereUnique_id_Input = TypedDict(
      '_MWhereUnique_id_Input',
      {
          'id': 'int',
      },
      total=True
  )
  
  MWhereUniqueInput = _MWhereUnique_id_Input
  
  
  class MUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      n: 'NUpdateManyWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class MUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: Union[AtomicIntInput, int]
      n: 'NUpdateManyWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class MUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['MCreateWithoutRelationsInput']
      connect: List['MWhereUniqueInput']
      set: List['MWhereUniqueInput']
      disconnect: List['MWhereUniqueInput']
      delete: List['MWhereUniqueInput']
  
      # TODO
      # update: List['MUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['MUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['MScalarWhereInput']
      # upsert: List['MUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['MCreateOrConnectWithoutRelationsInput']
  
  
  class MUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'MCreateWithoutRelationsInput'
      connect: 'MWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'MUpdateInput'
      # upsert: 'MUpsertWithoutRelationsInput'
      # connectOrCreate: 'MCreateOrConnectWithoutRelationsInput'
  
  
  class MUpsertInput(TypedDict):
      create: 'MCreateInput'
      update: 'MUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class MOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      int: 'SortOrder'
      optional_int: 'SortOrder'
      float: 'SortOrder'
      optional_float: 'SortOrder'
      string: 'SortOrder'
      optional_string: 'SortOrder'
      enum: 'SortOrder'
      optional_enum: 'SortOrder'
      boolean: 'SortOrder'
      optional_boolean: 'SortOrder'
  
  
  # recursive M types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/
  
  MRelationFilter = TypedDict(
      'MRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class MListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class MInclude(TypedDict, total=False):
      """M relational arguments"""
      n: Union[bool, 'FindManyNArgsFromM']
  
  
      
  
  class PostIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
      author: Union[bool, 'UserArgsFromMRecursive1']
  
  
  class PostIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
      author: Union[bool, 'UserArgsFromMRecursive2']
  
  
  class PostIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class PostArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyPostArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
      posts: Union[bool, 'FindManyPostArgsFromMRecursive1']
  
  
  class UserIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
      posts: Union[bool, 'FindManyPostArgsFromMRecursive2']
  
  
  class UserIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class UserArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyUserArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
      n: Union[bool, 'FindManyNArgsFromMRecursive1']
  
  
  class MIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
      n: Union[bool, 'FindManyNArgsFromMRecursive2']
  
  
  class MIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class MArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyMArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
      m: Union[bool, 'FindManyMArgsFromMRecursive1']
  
  
  class NIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
      m: Union[bool, 'FindManyMArgsFromMRecursive2']
  
  
  class NIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class NArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyNArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
      many: Union[bool, 'FindManyManyRequiredArgsFromMRecursive1']
  
  
  class OneOptionalIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
      many: Union[bool, 'FindManyManyRequiredArgsFromMRecursive2']
  
  
  class OneOptionalIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class OneOptionalArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyOneOptionalArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
      one: Union[bool, 'OneOptionalArgsFromMRecursive1']
  
  
  class ManyRequiredIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
      one: Union[bool, 'OneOptionalArgsFromMRecursive2']
  
  
  class ManyRequiredIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class ManyRequiredArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyManyRequiredArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class ListsIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class ListsIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class ListsIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class ListsArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class ListsArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class ListsArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyListsArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class FindManyListsArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class FindManyListsArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      
      
  
  class AIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class AIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class AIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class AArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyAArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class BIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class BIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class BArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyBArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class CIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class CIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class CArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyCArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class DIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class DIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class DArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyDArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromM(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class EIncludeFromMRecursive1(TypedDict, total=False):
      """Relational arguments for M"""
  
  
  class EIncludeFromMRecursive2(TypedDict, total=False):
      """Relational arguments for M"""
  
      
  
  class EArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      
      
  
  class FindManyEArgsFromM(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromMRecursive1(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromMRecursive2(TypedDict, total=False):
      """Arguments for M"""
      take: int
      skip: int
      order_by: Union['MOrderByInput', List['MOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyMArgs = FindManyMArgsFromM
  FindFirstMArgs = FindManyMArgsFromM
  
  
      
  
  class MWhereInput(TypedDict, total=False):
      """M arguments for searching"""
      id: Union[int, 'types.IntFilter']
      n: 'NListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['MWhereInputRecursive1', List['MWhereInputRecursive1']]
      # but this causes mypy to hang :/
      AND: List['MWhereInputRecursive1']
      OR: List['MWhereInputRecursive1']
      NOT: List['MWhereInputRecursive1']
  
  
  class MWhereInputRecursive1(TypedDict, total=False):
      """M arguments for searching"""
      id: Union[int, 'types.IntFilter']
      n: 'NListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['MWhereInputRecursive2', List['MWhereInputRecursive2']]
      # but this causes mypy to hang :/
      AND: List['MWhereInputRecursive2']
      OR: List['MWhereInputRecursive2']
      NOT: List['MWhereInputRecursive2']
  
  
  class MWhereInputRecursive2(TypedDict, total=False):
      """M arguments for searching"""
      id: Union[int, 'types.IntFilter']
      n: 'NListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
  
  
  MCountAggregateInput = TypedDict(
      'MCountAggregateInput',
      {
          'id': bool,
          'int': bool,
          'optional_int': bool,
          'float': bool,
          'optional_float': bool,
          'string': bool,
          'optional_string': bool,
          'enum': bool,
          'optional_enum': bool,
          'boolean': bool,
          'optional_boolean': bool,
          '_all': bool,
      },
      total=False,
  )
  
  MCountAggregateOutput = TypedDict(
      'MCountAggregateOutput',
      {
          'id': int,
          'int': int,
          'optional_int': int,
          'float': int,
          'optional_float': int,
          'string': int,
          'optional_string': int,
          'enum': int,
          'optional_enum': int,
          'boolean': int,
          'optional_boolean': int,
          '_all': int,
      },
      total=False,
  )
  
  
  MKeys = Literal[
      'id',
      'n',
      'int',
      'optional_int',
      'float',
      'optional_float',
      'string',
      'optional_string',
      'enum',
      'optional_enum',
      'boolean',
      'optional_boolean',
  ]
  
  MRelationalFieldKeys = Literal[
          'n',
      ]
  
  # N types
  
  class NOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the N create method"""
      id: int
      m: 'MCreateManyNestedWithoutRelationsInput'
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_json: Optional['fields.Json']
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class NCreateInput(NOptionalCreateInput):
      """Required arguments to the N create method"""
      int: int
      float: float
      string: str
      json_: 'fields.Json'
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class NOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the N create method, without relations"""
      id: int
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_json: Optional['fields.Json']
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class NCreateWithoutRelationsInput(NOptionalCreateWithoutRelationsInput):
      """Required arguments to the N create method, without relations"""
      int: int
      float: float
      string: str
      json_: 'fields.Json'
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  class NCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'NCreateWithoutRelationsInput'
      connect: 'NWhereUniqueInput'
  
  
  class NCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['NCreateWithoutRelationsInput', List['NCreateWithoutRelationsInput']]
      connect: Union['NWhereUniqueInput', List['NWhereUniqueInput']]
  
  
  
  _NWhereUnique_id_Input = TypedDict(
      '_NWhereUnique_id_Input',
      {
          'id': 'int',
      },
      total=True
  )
  
  NWhereUniqueInput = _NWhereUnique_id_Input
  
  
  class NUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      m: 'MUpdateManyWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      json_: 'fields.Json'
      optional_json: Optional['fields.Json']
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class NUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: Union[AtomicIntInput, int]
      m: 'MUpdateManyWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      json_: 'fields.Json'
      optional_json: Optional['fields.Json']
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class NUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['NCreateWithoutRelationsInput']
      connect: List['NWhereUniqueInput']
      set: List['NWhereUniqueInput']
      disconnect: List['NWhereUniqueInput']
      delete: List['NWhereUniqueInput']
  
      # TODO
      # update: List['NUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['NUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['NScalarWhereInput']
      # upsert: List['NUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['NCreateOrConnectWithoutRelationsInput']
  
  
  class NUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'NCreateWithoutRelationsInput'
      connect: 'NWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'NUpdateInput'
      # upsert: 'NUpsertWithoutRelationsInput'
      # connectOrCreate: 'NCreateOrConnectWithoutRelationsInput'
  
  
  class NUpsertInput(TypedDict):
      create: 'NCreateInput'
      update: 'NUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class NOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      int: 'SortOrder'
      optional_int: 'SortOrder'
      float: 'SortOrder'
      optional_float: 'SortOrder'
      string: 'SortOrder'
      optional_string: 'SortOrder'
      json_: 'SortOrder'
      optional_json: 'SortOrder'
      enum: 'SortOrder'
      optional_enum: 'SortOrder'
      boolean: 'SortOrder'
      optional_boolean: 'SortOrder'
  
  
  # recursive N types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/
  
  NRelationFilter = TypedDict(
      'NRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class NListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class NInclude(TypedDict, total=False):
      """N relational arguments"""
      m: Union[bool, 'FindManyMArgsFromN']
  
  
      
  
  class PostIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
      author: Union[bool, 'UserArgsFromNRecursive1']
  
  
  class PostIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
      author: Union[bool, 'UserArgsFromNRecursive2']
  
  
  class PostIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class PostArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyPostArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
      posts: Union[bool, 'FindManyPostArgsFromNRecursive1']
  
  
  class UserIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
      posts: Union[bool, 'FindManyPostArgsFromNRecursive2']
  
  
  class UserIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class UserArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyUserArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
      n: Union[bool, 'FindManyNArgsFromNRecursive1']
  
  
  class MIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
      n: Union[bool, 'FindManyNArgsFromNRecursive2']
  
  
  class MIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class MArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyMArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
      m: Union[bool, 'FindManyMArgsFromNRecursive1']
  
  
  class NIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
      m: Union[bool, 'FindManyMArgsFromNRecursive2']
  
  
  class NIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class NArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyNArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
      many: Union[bool, 'FindManyManyRequiredArgsFromNRecursive1']
  
  
  class OneOptionalIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
      many: Union[bool, 'FindManyManyRequiredArgsFromNRecursive2']
  
  
  class OneOptionalIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class OneOptionalArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyOneOptionalArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
      one: Union[bool, 'OneOptionalArgsFromNRecursive1']
  
  
  class ManyRequiredIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
      one: Union[bool, 'OneOptionalArgsFromNRecursive2']
  
  
  class ManyRequiredIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class ManyRequiredArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyManyRequiredArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class ListsIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class ListsIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class ListsIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class ListsArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class ListsArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class ListsArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyListsArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class FindManyListsArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class FindManyListsArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      
      
  
  class AIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class AIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class AIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class AArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyAArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class BIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class BIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class BArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyBArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class CIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class CIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class CArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyCArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class DIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class DIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class DArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyDArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromN(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class EIncludeFromNRecursive1(TypedDict, total=False):
      """Relational arguments for N"""
  
  
  class EIncludeFromNRecursive2(TypedDict, total=False):
      """Relational arguments for N"""
  
      
  
  class EArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      
      
  
  class FindManyEArgsFromN(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromNRecursive1(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromNRecursive2(TypedDict, total=False):
      """Arguments for N"""
      take: int
      skip: int
      order_by: Union['NOrderByInput', List['NOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyNArgs = FindManyNArgsFromN
  FindFirstNArgs = FindManyNArgsFromN
  
  
      
  
  class NWhereInput(TypedDict, total=False):
      """N arguments for searching"""
      id: Union[int, 'types.IntFilter']
      m: 'MListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      json_: Union['fields.Json', 'types.JsonFilter']
      optional_json: Union['fields.Json', 'types.JsonFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['NWhereInputRecursive1', List['NWhereInputRecursive1']]
      # but this causes mypy to hang :/
      AND: List['NWhereInputRecursive1']
      OR: List['NWhereInputRecursive1']
      NOT: List['NWhereInputRecursive1']
  
  
  class NWhereInputRecursive1(TypedDict, total=False):
      """N arguments for searching"""
      id: Union[int, 'types.IntFilter']
      m: 'MListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      json_: Union['fields.Json', 'types.JsonFilter']
      optional_json: Union['fields.Json', 'types.JsonFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['NWhereInputRecursive2', List['NWhereInputRecursive2']]
      # but this causes mypy to hang :/
      AND: List['NWhereInputRecursive2']
      OR: List['NWhereInputRecursive2']
      NOT: List['NWhereInputRecursive2']
  
  
  class NWhereInputRecursive2(TypedDict, total=False):
      """N arguments for searching"""
      id: Union[int, 'types.IntFilter']
      m: 'MListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      json_: Union['fields.Json', 'types.JsonFilter']
      optional_json: Union['fields.Json', 'types.JsonFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
  
  
  NCountAggregateInput = TypedDict(
      'NCountAggregateInput',
      {
          'id': bool,
          'int': bool,
          'optional_int': bool,
          'float': bool,
          'optional_float': bool,
          'string': bool,
          'optional_string': bool,
          'json_': bool,
          'optional_json': bool,
          'enum': bool,
          'optional_enum': bool,
          'boolean': bool,
          'optional_boolean': bool,
          '_all': bool,
      },
      total=False,
  )
  
  NCountAggregateOutput = TypedDict(
      'NCountAggregateOutput',
      {
          'id': int,
          'int': int,
          'optional_int': int,
          'float': int,
          'optional_float': int,
          'string': int,
          'optional_string': int,
          'json_': int,
          'optional_json': int,
          'enum': int,
          'optional_enum': int,
          'boolean': int,
          'optional_boolean': int,
          '_all': int,
      },
      total=False,
  )
  
  
  NKeys = Literal[
      'id',
      'm',
      'int',
      'optional_int',
      'float',
      'optional_float',
      'string',
      'optional_string',
      'json_',
      'optional_json',
      'enum',
      'optional_enum',
      'boolean',
      'optional_boolean',
  ]
  
  NRelationalFieldKeys = Literal[
          'm',
      ]
  
  # OneOptional types
  
  class OneOptionalOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the OneOptional create method"""
      id: int
      many: 'ManyRequiredCreateManyNestedWithoutRelationsInput'
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class OneOptionalCreateInput(OneOptionalOptionalCreateInput):
      """Required arguments to the OneOptional create method"""
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class OneOptionalOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the OneOptional create method, without relations"""
      id: int
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class OneOptionalCreateWithoutRelationsInput(OneOptionalOptionalCreateWithoutRelationsInput):
      """Required arguments to the OneOptional create method, without relations"""
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  class OneOptionalCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'OneOptionalCreateWithoutRelationsInput'
      connect: 'OneOptionalWhereUniqueInput'
  
  
  class OneOptionalCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['OneOptionalCreateWithoutRelationsInput', List['OneOptionalCreateWithoutRelationsInput']]
      connect: Union['OneOptionalWhereUniqueInput', List['OneOptionalWhereUniqueInput']]
  
  
  
  _OneOptionalWhereUnique_id_Input = TypedDict(
      '_OneOptionalWhereUnique_id_Input',
      {
          'id': 'int',
      },
      total=True
  )
  
  OneOptionalWhereUniqueInput = _OneOptionalWhereUnique_id_Input
  
  
  class OneOptionalUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      many: 'ManyRequiredUpdateManyWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class OneOptionalUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: Union[AtomicIntInput, int]
      many: 'ManyRequiredUpdateManyWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class OneOptionalUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['OneOptionalCreateWithoutRelationsInput']
      connect: List['OneOptionalWhereUniqueInput']
      set: List['OneOptionalWhereUniqueInput']
      disconnect: List['OneOptionalWhereUniqueInput']
      delete: List['OneOptionalWhereUniqueInput']
  
      # TODO
      # update: List['OneOptionalUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['OneOptionalUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['OneOptionalScalarWhereInput']
      # upsert: List['OneOptionalUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['OneOptionalCreateOrConnectWithoutRelationsInput']
  
  
  class OneOptionalUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'OneOptionalCreateWithoutRelationsInput'
      connect: 'OneOptionalWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'OneOptionalUpdateInput'
      # upsert: 'OneOptionalUpsertWithoutRelationsInput'
      # connectOrCreate: 'OneOptionalCreateOrConnectWithoutRelationsInput'
  
  
  class OneOptionalUpsertInput(TypedDict):
      create: 'OneOptionalCreateInput'
      update: 'OneOptionalUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class OneOptionalOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      int: 'SortOrder'
      optional_int: 'SortOrder'
      float: 'SortOrder'
      optional_float: 'SortOrder'
      string: 'SortOrder'
      optional_string: 'SortOrder'
      enum: 'SortOrder'
      optional_enum: 'SortOrder'
      boolean: 'SortOrder'
      optional_boolean: 'SortOrder'
  
  
  # recursive OneOptional types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/
  
  OneOptionalRelationFilter = TypedDict(
      'OneOptionalRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class OneOptionalListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class OneOptionalInclude(TypedDict, total=False):
      """OneOptional relational arguments"""
      many: Union[bool, 'FindManyManyRequiredArgsFromOneOptional']
  
  
      
  
  class PostIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      author: Union[bool, 'UserArgsFromOneOptionalRecursive1']
  
  
  class PostIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      author: Union[bool, 'UserArgsFromOneOptionalRecursive2']
  
  
  class PostIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class PostArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyPostArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      posts: Union[bool, 'FindManyPostArgsFromOneOptionalRecursive1']
  
  
  class UserIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      posts: Union[bool, 'FindManyPostArgsFromOneOptionalRecursive2']
  
  
  class UserIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class UserArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyUserArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      n: Union[bool, 'FindManyNArgsFromOneOptionalRecursive1']
  
  
  class MIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      n: Union[bool, 'FindManyNArgsFromOneOptionalRecursive2']
  
  
  class MIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class MArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyMArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      m: Union[bool, 'FindManyMArgsFromOneOptionalRecursive1']
  
  
  class NIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      m: Union[bool, 'FindManyMArgsFromOneOptionalRecursive2']
  
  
  class NIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class NArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyNArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      many: Union[bool, 'FindManyManyRequiredArgsFromOneOptionalRecursive1']
  
  
  class OneOptionalIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      many: Union[bool, 'FindManyManyRequiredArgsFromOneOptionalRecursive2']
  
  
  class OneOptionalIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class OneOptionalArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyOneOptionalArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      one: Union[bool, 'OneOptionalArgsFromOneOptionalRecursive1']
  
  
  class ManyRequiredIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
      one: Union[bool, 'OneOptionalArgsFromOneOptionalRecursive2']
  
  
  class ManyRequiredIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class ManyRequiredArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyManyRequiredArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class ListsIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class ListsIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class ListsIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class ListsArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class ListsArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class ListsArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyListsArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class FindManyListsArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class FindManyListsArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      
      
  
  class AIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class AIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class AIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class AArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyAArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class BIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class BIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class BArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyBArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class CIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class CIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class CArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyCArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class DIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class DIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class DArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyDArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromOneOptional(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class EIncludeFromOneOptionalRecursive1(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
  
  class EIncludeFromOneOptionalRecursive2(TypedDict, total=False):
      """Relational arguments for OneOptional"""
  
      
  
  class EArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      
      
  
  class FindManyEArgsFromOneOptional(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromOneOptionalRecursive1(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromOneOptionalRecursive2(TypedDict, total=False):
      """Arguments for OneOptional"""
      take: int
      skip: int
      order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyOneOptionalArgs = FindManyOneOptionalArgsFromOneOptional
  FindFirstOneOptionalArgs = FindManyOneOptionalArgsFromOneOptional
  
  
      
  
  class OneOptionalWhereInput(TypedDict, total=False):
      """OneOptional arguments for searching"""
      id: Union[int, 'types.IntFilter']
      many: 'ManyRequiredListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['OneOptionalWhereInputRecursive1', List['OneOptionalWhereInputRecursive1']]
      # but this causes mypy to hang :/
      AND: List['OneOptionalWhereInputRecursive1']
      OR: List['OneOptionalWhereInputRecursive1']
      NOT: List['OneOptionalWhereInputRecursive1']
  
  
  class OneOptionalWhereInputRecursive1(TypedDict, total=False):
      """OneOptional arguments for searching"""
      id: Union[int, 'types.IntFilter']
      many: 'ManyRequiredListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['OneOptionalWhereInputRecursive2', List['OneOptionalWhereInputRecursive2']]
      # but this causes mypy to hang :/
      AND: List['OneOptionalWhereInputRecursive2']
      OR: List['OneOptionalWhereInputRecursive2']
      NOT: List['OneOptionalWhereInputRecursive2']
  
  
  class OneOptionalWhereInputRecursive2(TypedDict, total=False):
      """OneOptional arguments for searching"""
      id: Union[int, 'types.IntFilter']
      many: 'ManyRequiredListRelationFilter'
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
  
  
  OneOptionalCountAggregateInput = TypedDict(
      'OneOptionalCountAggregateInput',
      {
          'id': bool,
          'int': bool,
          'optional_int': bool,
          'float': bool,
          'optional_float': bool,
          'string': bool,
          'optional_string': bool,
          'enum': bool,
          'optional_enum': bool,
          'boolean': bool,
          'optional_boolean': bool,
          '_all': bool,
      },
      total=False,
  )
  
  OneOptionalCountAggregateOutput = TypedDict(
      'OneOptionalCountAggregateOutput',
      {
          'id': int,
          'int': int,
          'optional_int': int,
          'float': int,
          'optional_float': int,
          'string': int,
          'optional_string': int,
          'enum': int,
          'optional_enum': int,
          'boolean': int,
          'optional_boolean': int,
          '_all': int,
      },
      total=False,
  )
  
  
  OneOptionalKeys = Literal[
      'id',
      'many',
      'int',
      'optional_int',
      'float',
      'optional_float',
      'string',
      'optional_string',
      'enum',
      'optional_enum',
      'boolean',
      'optional_boolean',
  ]
  
  OneOptionalRelationalFieldKeys = Literal[
          'many',
      ]
  
  # ManyRequired types
  
  class ManyRequiredOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the ManyRequired create method"""
      id: int
      one: 'OneOptionalCreateNestedWithoutRelationsInput'
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class ManyRequiredCreateInput(ManyRequiredOptionalCreateInput):
      """Required arguments to the ManyRequired create method"""
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class ManyRequiredOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the ManyRequired create method, without relations"""
      id: int
      optional_int: Optional[int]
      optional_float: Optional[float]
      optional_string: Optional[str]
      optional_enum: Optional['enums.ABeautifulEnum']
      optional_boolean: Optional[bool]
  
  
  class ManyRequiredCreateWithoutRelationsInput(ManyRequiredOptionalCreateWithoutRelationsInput):
      """Required arguments to the ManyRequired create method, without relations"""
      int: int
      float: float
      string: str
      enum: 'enums.ABeautifulEnum'
      boolean: bool
  
  
  class ManyRequiredCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'ManyRequiredCreateWithoutRelationsInput'
      connect: 'ManyRequiredWhereUniqueInput'
  
  
  class ManyRequiredCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['ManyRequiredCreateWithoutRelationsInput', List['ManyRequiredCreateWithoutRelationsInput']]
      connect: Union['ManyRequiredWhereUniqueInput', List['ManyRequiredWhereUniqueInput']]
  
  
  
  _ManyRequiredWhereUnique_id_Input = TypedDict(
      '_ManyRequiredWhereUnique_id_Input',
      {
          'id': 'int',
      },
      total=True
  )
  
  ManyRequiredWhereUniqueInput = _ManyRequiredWhereUnique_id_Input
  
  
  class ManyRequiredUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      one: 'OneOptionalUpdateOneWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class ManyRequiredUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: Union[AtomicIntInput, int]
      one: 'OneOptionalUpdateOneWithoutRelationsInput'
      int: Union[AtomicIntInput, int]
      optional_int: Optional[Union[AtomicIntInput, int]]
      float: Union[AtomicFloatInput, float]
      optional_float: Optional[Union[AtomicFloatInput, float]]
      string: str
      optional_string: Optional[str]
      enum: 'enums.ABeautifulEnum'
      optional_enum: Optional['enums.ABeautifulEnum']
      boolean: bool
      optional_boolean: Optional[bool]
  
  
  class ManyRequiredUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['ManyRequiredCreateWithoutRelationsInput']
      connect: List['ManyRequiredWhereUniqueInput']
      set: List['ManyRequiredWhereUniqueInput']
      disconnect: List['ManyRequiredWhereUniqueInput']
      delete: List['ManyRequiredWhereUniqueInput']
  
      # TODO
      # update: List['ManyRequiredUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['ManyRequiredUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['ManyRequiredScalarWhereInput']
      # upsert: List['ManyRequiredUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['ManyRequiredCreateOrConnectWithoutRelationsInput']
  
  
  class ManyRequiredUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'ManyRequiredCreateWithoutRelationsInput'
      connect: 'ManyRequiredWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'ManyRequiredUpdateInput'
      # upsert: 'ManyRequiredUpsertWithoutRelationsInput'
      # connectOrCreate: 'ManyRequiredCreateOrConnectWithoutRelationsInput'
  
  
  class ManyRequiredUpsertInput(TypedDict):
      create: 'ManyRequiredCreateInput'
      update: 'ManyRequiredUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class ManyRequiredOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      one_optional_id: 'SortOrder'
      int: 'SortOrder'
      optional_int: 'SortOrder'
      float: 'SortOrder'
      optional_float: 'SortOrder'
      string: 'SortOrder'
      optional_string: 'SortOrder'
      enum: 'SortOrder'
      optional_enum: 'SortOrder'
      boolean: 'SortOrder'
      optional_boolean: 'SortOrder'
  
  
  # recursive ManyRequired types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/
  
  ManyRequiredRelationFilter = TypedDict(
      'ManyRequiredRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class ManyRequiredListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class ManyRequiredInclude(TypedDict, total=False):
      """ManyRequired relational arguments"""
      one: Union[bool, 'OneOptionalArgsFromManyRequired']
  
  
      
  
  class PostIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      author: Union[bool, 'UserArgsFromManyRequiredRecursive1']
  
  
  class PostIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      author: Union[bool, 'UserArgsFromManyRequiredRecursive2']
  
  
  class PostIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class PostArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyPostArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      posts: Union[bool, 'FindManyPostArgsFromManyRequiredRecursive1']
  
  
  class UserIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      posts: Union[bool, 'FindManyPostArgsFromManyRequiredRecursive2']
  
  
  class UserIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class UserArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyUserArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      n: Union[bool, 'FindManyNArgsFromManyRequiredRecursive1']
  
  
  class MIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      n: Union[bool, 'FindManyNArgsFromManyRequiredRecursive2']
  
  
  class MIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class MArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyMArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      m: Union[bool, 'FindManyMArgsFromManyRequiredRecursive1']
  
  
  class NIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      m: Union[bool, 'FindManyMArgsFromManyRequiredRecursive2']
  
  
  class NIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class NArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyNArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      many: Union[bool, 'FindManyManyRequiredArgsFromManyRequiredRecursive1']
  
  
  class OneOptionalIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      many: Union[bool, 'FindManyManyRequiredArgsFromManyRequiredRecursive2']
  
  
  class OneOptionalIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class OneOptionalArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyOneOptionalArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      one: Union[bool, 'OneOptionalArgsFromManyRequiredRecursive1']
  
  
  class ManyRequiredIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
      one: Union[bool, 'OneOptionalArgsFromManyRequiredRecursive2']
  
  
  class ManyRequiredIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class ManyRequiredArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyManyRequiredArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class ListsIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class ListsIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class ListsIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class ListsArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class ListsArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class ListsArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyListsArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class FindManyListsArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class FindManyListsArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      
      
  
  class AIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class AIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class AIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class AArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyAArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class BIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class BIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class BArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyBArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class CIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class CIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class CArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyCArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class DIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class DIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class DArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyDArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromManyRequired(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class EIncludeFromManyRequiredRecursive1(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
  
  class EIncludeFromManyRequiredRecursive2(TypedDict, total=False):
      """Relational arguments for ManyRequired"""
  
      
  
  class EArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      
      
  
  class FindManyEArgsFromManyRequired(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromManyRequiredRecursive1(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromManyRequiredRecursive2(TypedDict, total=False):
      """Arguments for ManyRequired"""
      take: int
      skip: int
      order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyManyRequiredArgs = FindManyManyRequiredArgsFromManyRequired
  FindFirstManyRequiredArgs = FindManyManyRequiredArgsFromManyRequired
  
  
      
  
  class ManyRequiredWhereInput(TypedDict, total=False):
      """ManyRequired arguments for searching"""
      id: Union[int, 'types.IntFilter']
      one: 'OneOptionalRelationFilter'
      one_optional_id: Union[int, 'types.IntFilter']
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['ManyRequiredWhereInputRecursive1', List['ManyRequiredWhereInputRecursive1']]
      # but this causes mypy to hang :/
      AND: List['ManyRequiredWhereInputRecursive1']
      OR: List['ManyRequiredWhereInputRecursive1']
      NOT: List['ManyRequiredWhereInputRecursive1']
  
  
  class ManyRequiredWhereInputRecursive1(TypedDict, total=False):
      """ManyRequired arguments for searching"""
      id: Union[int, 'types.IntFilter']
      one: 'OneOptionalRelationFilter'
      one_optional_id: Union[int, 'types.IntFilter']
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
      # should be noted that AND and NOT should be Union['ManyRequiredWhereInputRecursive2', List['ManyRequiredWhereInputRecursive2']]
      # but this causes mypy to hang :/
      AND: List['ManyRequiredWhereInputRecursive2']
      OR: List['ManyRequiredWhereInputRecursive2']
      NOT: List['ManyRequiredWhereInputRecursive2']
  
  
  class ManyRequiredWhereInputRecursive2(TypedDict, total=False):
      """ManyRequired arguments for searching"""
      id: Union[int, 'types.IntFilter']
      one: 'OneOptionalRelationFilter'
      one_optional_id: Union[int, 'types.IntFilter']
      int: Union[int, 'types.IntFilter']
      optional_int: Union[int, 'types.IntFilter']
      float: Union[float, 'types.FloatFilter']
      optional_float: Union[float, 'types.FloatFilter']
      string: Union[str, 'types.StringFilter']
      optional_string: Union[str, 'types.StringFilter']
      enum: 'enums.ABeautifulEnum'
      optional_enum: 'enums.ABeautifulEnum'
      boolean: Union[bool, 'types.BooleanFilter']
      optional_boolean: Union[bool, 'types.BooleanFilter']
  
  
  
  ManyRequiredCountAggregateInput = TypedDict(
      'ManyRequiredCountAggregateInput',
      {
          'id': bool,
          'one_optional_id': bool,
          'int': bool,
          'optional_int': bool,
          'float': bool,
          'optional_float': bool,
          'string': bool,
          'optional_string': bool,
          'enum': bool,
          'optional_enum': bool,
          'boolean': bool,
          'optional_boolean': bool,
          '_all': bool,
      },
      total=False,
  )
  
  ManyRequiredCountAggregateOutput = TypedDict(
      'ManyRequiredCountAggregateOutput',
      {
          'id': int,
          'one_optional_id': int,
          'int': int,
          'optional_int': int,
          'float': int,
          'optional_float': int,
          'string': int,
          'optional_string': int,
          'enum': int,
          'optional_enum': int,
          'boolean': int,
          'optional_boolean': int,
          '_all': int,
      },
      total=False,
  )
  
  
  ManyRequiredKeys = Literal[
      'id',
      'one',
      'one_optional_id',
      'int',
      'optional_int',
      'float',
      'optional_float',
      'string',
      'optional_string',
      'enum',
      'optional_enum',
      'boolean',
      'optional_boolean',
  ]
  
  ManyRequiredRelationalFieldKeys = Literal[
          'one',
      ]
  
  # Lists types
  
  class ListsOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the Lists create method"""
      id: str
      strings: List[str]
      bytes: List['fields.Base64']
      dates: List[datetime.datetime]
      bools: List[bool]
      ints: List[int]
      floats: List[float]
      bigints: List[int]
      json_objects: List['fields.Json']
  
  
  class ListsCreateInput(ListsOptionalCreateInput):
      """Required arguments to the Lists create method"""
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class ListsOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the Lists create method, without relations"""
      id: str
      strings: List[str]
      bytes: List['fields.Base64']
      dates: List[datetime.datetime]
      bools: List[bool]
      ints: List[int]
      floats: List[float]
      bigints: List[int]
      json_objects: List['fields.Json']
  
  
  class ListsCreateWithoutRelationsInput(ListsOptionalCreateWithoutRelationsInput):
      """Required arguments to the Lists create method, without relations"""
  
  
  class ListsCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'ListsCreateWithoutRelationsInput'
      connect: 'ListsWhereUniqueInput'
  
  
  class ListsCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['ListsCreateWithoutRelationsInput', List['ListsCreateWithoutRelationsInput']]
      connect: Union['ListsWhereUniqueInput', List['ListsWhereUniqueInput']]
  
  
  
  _ListsWhereUnique_id_Input = TypedDict(
      '_ListsWhereUnique_id_Input',
      {
          'id': 'str',
      },
      total=True
  )
  
  ListsWhereUniqueInput = _ListsWhereUnique_id_Input
  
  
  class ListsUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      strings: 'types.StringListUpdate'
      bytes: 'types.BytesListUpdate'
      dates: 'types.DateTimeListUpdate'
      bools: 'types.BooleanListUpdate'
      ints: 'types.IntListUpdate'
      floats: 'types.FloatListUpdate'
      bigints: 'types.BigIntListUpdate'
      json_objects: 'types.JsonListUpdate'
  
  
  class ListsUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: str
      strings: 'types.StringListUpdate'
      bytes: 'types.BytesListUpdate'
      dates: 'types.DateTimeListUpdate'
      bools: 'types.BooleanListUpdate'
      ints: 'types.IntListUpdate'
      floats: 'types.FloatListUpdate'
      bigints: 'types.BigIntListUpdate'
      json_objects: 'types.JsonListUpdate'
  
  
  class ListsUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['ListsCreateWithoutRelationsInput']
      connect: List['ListsWhereUniqueInput']
      set: List['ListsWhereUniqueInput']
      disconnect: List['ListsWhereUniqueInput']
      delete: List['ListsWhereUniqueInput']
  
      # TODO
      # update: List['ListsUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['ListsUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['ListsScalarWhereInput']
      # upsert: List['ListsUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['ListsCreateOrConnectWithoutRelationsInput']
  
  
  class ListsUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'ListsCreateWithoutRelationsInput'
      connect: 'ListsWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'ListsUpdateInput'
      # upsert: 'ListsUpsertWithoutRelationsInput'
      # connectOrCreate: 'ListsCreateOrConnectWithoutRelationsInput'
  
  
  class ListsUpsertInput(TypedDict):
      create: 'ListsCreateInput'
      update: 'ListsUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class ListsOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      strings: 'SortOrder'
      bytes: 'SortOrder'
      dates: 'SortOrder'
      bools: 'SortOrder'
      ints: 'SortOrder'
      floats: 'SortOrder'
      bigints: 'SortOrder'
      json_objects: 'SortOrder'
  
  
  # recursive Lists types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/
  
  ListsRelationFilter = TypedDict(
      'ListsRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class ListsListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class ListsInclude(TypedDict, total=False):
      """Lists relational arguments"""
  
  
      
  
  class PostIncludeFromLists(TypedDict, total=False):
      """Relational arguments for Lists"""
      author: Union[bool, 'UserArgsFromListsRecursive1']
  
  
  class PostIncludeFromListsRecursive1(TypedDict, total=False):
      """Relational arguments for Lists"""
      author: Union[bool, 'UserArgsFromListsRecursive2']
  
  
  class PostIncludeFromListsRecursive2(TypedDict, total=False):
      """Relational arguments for Lists"""
  
      
  
  class PostArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      
      
  
  class FindManyPostArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromLists(TypedDict, total=False):
      """Relational arguments for Lists"""
      posts: Union[bool, 'FindManyPostArgsFromListsRecursive1']
  
  
  class UserIncludeFromListsRecursive1(TypedDict, total=False):
      """Relational arguments for Lists"""
      posts: Union[bool, 'FindManyPostArgsFromListsRecursive2']
  
  
  class UserIncludeFromListsRecursive2(TypedDict, total=False):
      """Relational arguments for Lists"""
  
      
  
  class UserArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      
      
  
  class FindManyUserArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromLists(TypedDict, total=False):
      """Relational arguments for Lists"""
      n: Union[bool, 'FindManyNArgsFromListsRecursive1']
  
  
  class MIncludeFromListsRecursive1(TypedDict, total=False):
      """Relational arguments for Lists"""
      n: Union[bool, 'FindManyNArgsFromListsRecursive2']
  
  
  class MIncludeFromListsRecursive2(TypedDict, total=False):
      """Relational arguments for Lists"""
  
      
  
  class MArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      
      
  
  class FindManyMArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromLists(TypedDict, total=False):
      """Relational arguments for Lists"""
      m: Union[bool, 'FindManyMArgsFromListsRecursive1']
  
  
  class NIncludeFromListsRecursive1(TypedDict, total=False):
      """Relational arguments for Lists"""
      m: Union[bool, 'FindManyMArgsFromListsRecursive2']
  
  
  class NIncludeFromListsRecursive2(TypedDict, total=False):
      """Relational arguments for Lists"""
  
      
  
  class NArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      
      
  
  class FindManyNArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromLists(TypedDict, total=False):
      """Relational arguments for Lists"""
      many: Union[bool, 'FindManyManyRequiredArgsFromListsRecursive1']
  
  
  class OneOptionalIncludeFromListsRecursive1(TypedDict, total=False):
      """Relational arguments for Lists"""
      many: Union[bool, 'FindManyManyRequiredArgsFromListsRecursive2']
  
  
  class OneOptionalIncludeFromListsRecursive2(TypedDict, total=False):
      """Relational arguments for Lists"""
  
      
  
  class OneOptionalArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      
      
  
  class FindManyOneOptionalArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromLists(TypedDict, total=False):
      """Relational arguments for Lists"""
      one: Union[bool, 'OneOptionalArgsFromListsRecursive1']
  
  
  class ManyRequiredIncludeFromListsRecursive1(TypedDict, total=False):
      """Relational arguments for Lists"""
      one: Union[bool, 'OneOptionalArgsFromListsRecursive2']
  
  
  class ManyRequiredIncludeFromListsRecursive2(TypedDict, total=False):
      """Relational arguments for Lists"""
  
      
  
  class ManyRequiredArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      
      
  
  class FindManyManyRequiredArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class ListsIncludeFromLists(TypedDict, total=False):
      """Relational arguments for Lists"""
  
  
  class ListsIncludeFromListsRecursive1(TypedDict, total=False):
      """Relational arguments for Lists"""
  
  
  class ListsIncludeFromListsRecursive2(TypedDict, total=False):
      """Relational arguments for Lists"""
  
      
  
  class ListsArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class ListsArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class ListsArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      
      
  
  class FindManyListsArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class FindManyListsArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class FindManyListsArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      
      
  
  class AIncludeFromLists(TypedDict, total=False):
      """Relational arguments for Lists"""
  
  
  class AIncludeFromListsRecursive1(TypedDict, total=False):
      """Relational arguments for Lists"""
  
  
  class AIncludeFromListsRecursive2(TypedDict, total=False):
      """Relational arguments for Lists"""
  
      
  
  class AArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      
      
  
  class FindManyAArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromLists(TypedDict, total=False):
      """Relational arguments for Lists"""
  
  
  class BIncludeFromListsRecursive1(TypedDict, total=False):
      """Relational arguments for Lists"""
  
  
  class BIncludeFromListsRecursive2(TypedDict, total=False):
      """Relational arguments for Lists"""
  
      
  
  class BArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      
      
  
  class FindManyBArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromLists(TypedDict, total=False):
      """Relational arguments for Lists"""
  
  
  class CIncludeFromListsRecursive1(TypedDict, total=False):
      """Relational arguments for Lists"""
  
  
  class CIncludeFromListsRecursive2(TypedDict, total=False):
      """Relational arguments for Lists"""
  
      
  
  class CArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      
      
  
  class FindManyCArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromLists(TypedDict, total=False):
      """Relational arguments for Lists"""
  
  
  class DIncludeFromListsRecursive1(TypedDict, total=False):
      """Relational arguments for Lists"""
  
  
  class DIncludeFromListsRecursive2(TypedDict, total=False):
      """Relational arguments for Lists"""
  
      
  
  class DArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      
      
  
  class FindManyDArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromLists(TypedDict, total=False):
      """Relational arguments for Lists"""
  
  
  class EIncludeFromListsRecursive1(TypedDict, total=False):
      """Relational arguments for Lists"""
  
  
  class EIncludeFromListsRecursive2(TypedDict, total=False):
      """Relational arguments for Lists"""
  
      
  
  class EArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      
      
  
  class FindManyEArgsFromLists(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromListsRecursive1(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromListsRecursive2(TypedDict, total=False):
      """Arguments for Lists"""
      take: int
      skip: int
      order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyListsArgs = FindManyListsArgsFromLists
  FindFirstListsArgs = FindManyListsArgsFromLists
  
  
      
  
  class ListsWhereInput(TypedDict, total=False):
      """Lists arguments for searching"""
      id: Union[str, 'types.StringFilter']
      strings: 'types.StringListFilter'
      bytes: 'types.BytesListFilter'
      dates: 'types.DateTimeListFilter'
      bools: 'types.BooleanListFilter'
      ints: 'types.IntListFilter'
      floats: 'types.FloatListFilter'
      bigints: 'types.BigIntListFilter'
      json_objects: 'types.JsonListFilter'
  
      # should be noted that AND and NOT should be Union['ListsWhereInputRecursive1', List['ListsWhereInputRecursive1']]
      # but this causes mypy to hang :/
      AND: List['ListsWhereInputRecursive1']
      OR: List['ListsWhereInputRecursive1']
      NOT: List['ListsWhereInputRecursive1']
  
  
  class ListsWhereInputRecursive1(TypedDict, total=False):
      """Lists arguments for searching"""
      id: Union[str, 'types.StringFilter']
      strings: 'types.StringListFilter'
      bytes: 'types.BytesListFilter'
      dates: 'types.DateTimeListFilter'
      bools: 'types.BooleanListFilter'
      ints: 'types.IntListFilter'
      floats: 'types.FloatListFilter'
      bigints: 'types.BigIntListFilter'
      json_objects: 'types.JsonListFilter'
  
      # should be noted that AND and NOT should be Union['ListsWhereInputRecursive2', List['ListsWhereInputRecursive2']]
      # but this causes mypy to hang :/
      AND: List['ListsWhereInputRecursive2']
      OR: List['ListsWhereInputRecursive2']
      NOT: List['ListsWhereInputRecursive2']
  
  
  class ListsWhereInputRecursive2(TypedDict, total=False):
      """Lists arguments for searching"""
      id: Union[str, 'types.StringFilter']
      strings: 'types.StringListFilter'
      bytes: 'types.BytesListFilter'
      dates: 'types.DateTimeListFilter'
      bools: 'types.BooleanListFilter'
      ints: 'types.IntListFilter'
      floats: 'types.FloatListFilter'
      bigints: 'types.BigIntListFilter'
      json_objects: 'types.JsonListFilter'
  
  
  
  ListsCountAggregateInput = TypedDict(
      'ListsCountAggregateInput',
      {
          'id': bool,
          'strings': bool,
          'bytes': bool,
          'dates': bool,
          'bools': bool,
          'ints': bool,
          'floats': bool,
          'bigints': bool,
          'json_objects': bool,
          '_all': bool,
      },
      total=False,
  )
  
  ListsCountAggregateOutput = TypedDict(
      'ListsCountAggregateOutput',
      {
          'id': int,
          'strings': int,
          'bytes': int,
          'dates': int,
          'bools': int,
          'ints': int,
          'floats': int,
          'bigints': int,
          'json_objects': int,
          '_all': int,
      },
      total=False,
  )
  
  
  ListsKeys = Literal[
      'id',
      'strings',
      'bytes',
      'dates',
      'bools',
      'ints',
      'floats',
      'bigints',
      'json_objects',
  ]
  
  ListsRelationalFieldKeys = _NoneType
  
  # A types
  
  class AOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the A create method"""
      name: Optional[str]
      inc_int: int
      inc_sInt: int
      inc_bInt: int
  
  
  class ACreateInput(AOptionalCreateInput):
      """Required arguments to the A create method"""
      email: str
      int: int
      sInt: int
      bInt: int
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class AOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the A create method, without relations"""
      name: Optional[str]
      inc_int: int
      inc_sInt: int
      inc_bInt: int
  
  
  class ACreateWithoutRelationsInput(AOptionalCreateWithoutRelationsInput):
      """Required arguments to the A create method, without relations"""
      email: str
      int: int
      sInt: int
      bInt: int
  
  
  class ACreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'ACreateWithoutRelationsInput'
      connect: 'AWhereUniqueInput'
  
  
  class ACreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['ACreateWithoutRelationsInput', List['ACreateWithoutRelationsInput']]
      connect: Union['AWhereUniqueInput', List['AWhereUniqueInput']]
  
  
  
  _AWhereUnique_email_Input = TypedDict(
      '_AWhereUnique_email_Input',
      {
          'email': 'str',
      },
      total=True
  )
  
  _ACompoundname_emailKeyInner = TypedDict(
      '_ACompoundname_emailKeyInner',
      {
          'name': 'str',
          'email': 'str',
      },
      total=True
  )
  
  _ACompoundname_emailKey = TypedDict(
      '_ACompoundname_emailKey',
      {
          'name_email': '_ACompoundname_emailKeyInner',
      },
      total=True
  )
  
  AWhereUniqueInput = Union[
      '_AWhereUnique_email_Input',
      '_ACompoundname_emailKey',
  ]
  
  
  class AUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      name: Optional[str]
      int: Union[AtomicIntInput, int]
      sInt: Union[AtomicIntInput, int]
      inc_int: Union[AtomicIntInput, int]
      inc_sInt: Union[AtomicIntInput, int]
      bInt: Union[AtomicBigIntInput, int]
      inc_bInt: Union[AtomicBigIntInput, int]
  
  
  class AUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      email: str
      name: Optional[str]
      int: Union[AtomicIntInput, int]
      sInt: Union[AtomicIntInput, int]
      inc_int: Union[AtomicIntInput, int]
      inc_sInt: Union[AtomicIntInput, int]
      bInt: Union[AtomicBigIntInput, int]
      inc_bInt: Union[AtomicBigIntInput, int]
  
  
  class AUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['ACreateWithoutRelationsInput']
      connect: List['AWhereUniqueInput']
      set: List['AWhereUniqueInput']
      disconnect: List['AWhereUniqueInput']
      delete: List['AWhereUniqueInput']
  
      # TODO
      # update: List['AUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['AUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['AScalarWhereInput']
      # upsert: List['AUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['ACreateOrConnectWithoutRelationsInput']
  
  
  class AUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'ACreateWithoutRelationsInput'
      connect: 'AWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'AUpdateInput'
      # upsert: 'AUpsertWithoutRelationsInput'
      # connectOrCreate: 'ACreateOrConnectWithoutRelationsInput'
  
  
  class AUpsertInput(TypedDict):
      create: 'ACreateInput'
      update: 'AUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class AOrderByInput(TypedDict, total=False):
      email: 'SortOrder'
      name: 'SortOrder'
      int: 'SortOrder'
      sInt: 'SortOrder'
      inc_int: 'SortOrder'
      inc_sInt: 'SortOrder'
      bInt: 'SortOrder'
      inc_bInt: 'SortOrder'
  
  
  # recursive A types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/
  
  ARelationFilter = TypedDict(
      'ARelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class AListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class AInclude(TypedDict, total=False):
      """A relational arguments"""
  
  
      
  
  class PostIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
      author: Union[bool, 'UserArgsFromARecursive1']
  
  
  class PostIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
      author: Union[bool, 'UserArgsFromARecursive2']
  
  
  class PostIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class PostArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyPostArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
      posts: Union[bool, 'FindManyPostArgsFromARecursive1']
  
  
  class UserIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
      posts: Union[bool, 'FindManyPostArgsFromARecursive2']
  
  
  class UserIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class UserArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyUserArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
      n: Union[bool, 'FindManyNArgsFromARecursive1']
  
  
  class MIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
      n: Union[bool, 'FindManyNArgsFromARecursive2']
  
  
  class MIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class MArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyMArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
      m: Union[bool, 'FindManyMArgsFromARecursive1']
  
  
  class NIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
      m: Union[bool, 'FindManyMArgsFromARecursive2']
  
  
  class NIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class NArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyNArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
      many: Union[bool, 'FindManyManyRequiredArgsFromARecursive1']
  
  
  class OneOptionalIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
      many: Union[bool, 'FindManyManyRequiredArgsFromARecursive2']
  
  
  class OneOptionalIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class OneOptionalArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyOneOptionalArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
      one: Union[bool, 'OneOptionalArgsFromARecursive1']
  
  
  class ManyRequiredIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
      one: Union[bool, 'OneOptionalArgsFromARecursive2']
  
  
  class ManyRequiredIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class ManyRequiredArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyManyRequiredArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class ListsIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class ListsIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class ListsIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class ListsArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class ListsArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class ListsArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyListsArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class FindManyListsArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class FindManyListsArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      
      
  
  class AIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class AIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class AIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class AArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyAArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class BIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class BIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class BArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyBArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class CIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class CIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class CArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyCArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class DIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class DIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class DArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyDArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromA(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class EIncludeFromARecursive1(TypedDict, total=False):
      """Relational arguments for A"""
  
  
  class EIncludeFromARecursive2(TypedDict, total=False):
      """Relational arguments for A"""
  
      
  
  class EArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      
      
  
  class FindManyEArgsFromA(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromARecursive1(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromARecursive2(TypedDict, total=False):
      """Arguments for A"""
      take: int
      skip: int
      order_by: Union['AOrderByInput', List['AOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyAArgs = FindManyAArgsFromA
  FindFirstAArgs = FindManyAArgsFromA
  
  
      
  
  class AWhereInput(TypedDict, total=False):
      """A arguments for searching"""
      email: Union[str, 'types.StringFilter']
      name: Union[str, 'types.StringFilter']
      int: Union[int, 'types.IntFilter']
      sInt: Union[int, 'types.IntFilter']
      inc_int: Union[int, 'types.IntFilter']
      inc_sInt: Union[int, 'types.IntFilter']
      bInt: Union[int, 'types.BigIntFilter']
      inc_bInt: Union[int, 'types.BigIntFilter']
  
      # should be noted that AND and NOT should be Union['AWhereInputRecursive1', List['AWhereInputRecursive1']]
      # but this causes mypy to hang :/
      AND: List['AWhereInputRecursive1']
      OR: List['AWhereInputRecursive1']
      NOT: List['AWhereInputRecursive1']
  
  
  class AWhereInputRecursive1(TypedDict, total=False):
      """A arguments for searching"""
      email: Union[str, 'types.StringFilter']
      name: Union[str, 'types.StringFilter']
      int: Union[int, 'types.IntFilter']
      sInt: Union[int, 'types.IntFilter']
      inc_int: Union[int, 'types.IntFilter']
      inc_sInt: Union[int, 'types.IntFilter']
      bInt: Union[int, 'types.BigIntFilter']
      inc_bInt: Union[int, 'types.BigIntFilter']
  
      # should be noted that AND and NOT should be Union['AWhereInputRecursive2', List['AWhereInputRecursive2']]
      # but this causes mypy to hang :/
      AND: List['AWhereInputRecursive2']
      OR: List['AWhereInputRecursive2']
      NOT: List['AWhereInputRecursive2']
  
  
  class AWhereInputRecursive2(TypedDict, total=False):
      """A arguments for searching"""
      email: Union[str, 'types.StringFilter']
      name: Union[str, 'types.StringFilter']
      int: Union[int, 'types.IntFilter']
      sInt: Union[int, 'types.IntFilter']
      inc_int: Union[int, 'types.IntFilter']
      inc_sInt: Union[int, 'types.IntFilter']
      bInt: Union[int, 'types.BigIntFilter']
      inc_bInt: Union[int, 'types.BigIntFilter']
  
  
  
  ACountAggregateInput = TypedDict(
      'ACountAggregateInput',
      {
          'email': bool,
          'name': bool,
          'int': bool,
          'sInt': bool,
          'inc_int': bool,
          'inc_sInt': bool,
          'bInt': bool,
          'inc_bInt': bool,
          '_all': bool,
      },
      total=False,
  )
  
  ACountAggregateOutput = TypedDict(
      'ACountAggregateOutput',
      {
          'email': int,
          'name': int,
          'int': int,
          'sInt': int,
          'inc_int': int,
          'inc_sInt': int,
          'bInt': int,
          'inc_bInt': int,
          '_all': int,
      },
      total=False,
  )
  
  
  AKeys = Literal[
      'email',
      'name',
      'int',
      'sInt',
      'inc_int',
      'inc_sInt',
      'bInt',
      'inc_bInt',
  ]
  
  ARelationalFieldKeys = _NoneType
  
  # B types
  
  class BOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the B create method"""
      id: str
  
  
  class BCreateInput(BOptionalCreateInput):
      """Required arguments to the B create method"""
      float: float
      d_float: float
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class BOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the B create method, without relations"""
      id: str
  
  
  class BCreateWithoutRelationsInput(BOptionalCreateWithoutRelationsInput):
      """Required arguments to the B create method, without relations"""
      float: float
      d_float: float
  
  
  class BCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'BCreateWithoutRelationsInput'
      connect: 'BWhereUniqueInput'
  
  
  class BCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['BCreateWithoutRelationsInput', List['BCreateWithoutRelationsInput']]
      connect: Union['BWhereUniqueInput', List['BWhereUniqueInput']]
  
  
  
  _BWhereUnique_id_Input = TypedDict(
      '_BWhereUnique_id_Input',
      {
          'id': 'str',
      },
      total=True
  )
  
  _BCompoundmy_constraintKeyInner = TypedDict(
      '_BCompoundmy_constraintKeyInner',
      {
          'float': 'float',
          'd_float': 'float',
      },
      total=True
  )
  
  _BCompoundmy_constraintKey = TypedDict(
      '_BCompoundmy_constraintKey',
      {
          'my_constraint': '_BCompoundmy_constraintKeyInner',
      },
      total=True
  )
  
  BWhereUniqueInput = Union[
      '_BWhereUnique_id_Input',
      '_BCompoundmy_constraintKey',
  ]
  
  
  class BUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      float: Union[AtomicFloatInput, float]
      d_float: Union[AtomicFloatInput, float]
  
  
  class BUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: str
      float: Union[AtomicFloatInput, float]
      d_float: Union[AtomicFloatInput, float]
  
  
  class BUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['BCreateWithoutRelationsInput']
      connect: List['BWhereUniqueInput']
      set: List['BWhereUniqueInput']
      disconnect: List['BWhereUniqueInput']
      delete: List['BWhereUniqueInput']
  
      # TODO
      # update: List['BUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['BUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['BScalarWhereInput']
      # upsert: List['BUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['BCreateOrConnectWithoutRelationsInput']
  
  
  class BUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'BCreateWithoutRelationsInput'
      connect: 'BWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'BUpdateInput'
      # upsert: 'BUpsertWithoutRelationsInput'
      # connectOrCreate: 'BCreateOrConnectWithoutRelationsInput'
  
  
  class BUpsertInput(TypedDict):
      create: 'BCreateInput'
      update: 'BUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class BOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      float: 'SortOrder'
      d_float: 'SortOrder'
  
  
  # recursive B types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/
  
  BRelationFilter = TypedDict(
      'BRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class BListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class BInclude(TypedDict, total=False):
      """B relational arguments"""
  
  
      
  
  class PostIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
      author: Union[bool, 'UserArgsFromBRecursive1']
  
  
  class PostIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
      author: Union[bool, 'UserArgsFromBRecursive2']
  
  
  class PostIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class PostArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyPostArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
      posts: Union[bool, 'FindManyPostArgsFromBRecursive1']
  
  
  class UserIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
      posts: Union[bool, 'FindManyPostArgsFromBRecursive2']
  
  
  class UserIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class UserArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyUserArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
      n: Union[bool, 'FindManyNArgsFromBRecursive1']
  
  
  class MIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
      n: Union[bool, 'FindManyNArgsFromBRecursive2']
  
  
  class MIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class MArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyMArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
      m: Union[bool, 'FindManyMArgsFromBRecursive1']
  
  
  class NIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
      m: Union[bool, 'FindManyMArgsFromBRecursive2']
  
  
  class NIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class NArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyNArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
      many: Union[bool, 'FindManyManyRequiredArgsFromBRecursive1']
  
  
  class OneOptionalIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
      many: Union[bool, 'FindManyManyRequiredArgsFromBRecursive2']
  
  
  class OneOptionalIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class OneOptionalArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyOneOptionalArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
      one: Union[bool, 'OneOptionalArgsFromBRecursive1']
  
  
  class ManyRequiredIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
      one: Union[bool, 'OneOptionalArgsFromBRecursive2']
  
  
  class ManyRequiredIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class ManyRequiredArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyManyRequiredArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class ListsIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class ListsIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class ListsIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class ListsArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class ListsArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class ListsArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyListsArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class FindManyListsArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class FindManyListsArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      
      
  
  class AIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class AIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class AIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class AArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyAArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class BIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class BIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class BArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyBArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class CIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class CIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class CArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyCArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class DIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class DIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class DArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyDArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromB(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class EIncludeFromBRecursive1(TypedDict, total=False):
      """Relational arguments for B"""
  
  
  class EIncludeFromBRecursive2(TypedDict, total=False):
      """Relational arguments for B"""
  
      
  
  class EArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      
      
  
  class FindManyEArgsFromB(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromBRecursive1(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromBRecursive2(TypedDict, total=False):
      """Arguments for B"""
      take: int
      skip: int
      order_by: Union['BOrderByInput', List['BOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyBArgs = FindManyBArgsFromB
  FindFirstBArgs = FindManyBArgsFromB
  
  
      
  
  class BWhereInput(TypedDict, total=False):
      """B arguments for searching"""
      id: Union[str, 'types.StringFilter']
      float: Union[float, 'types.FloatFilter']
      d_float: Union[float, 'types.FloatFilter']
  
      # should be noted that AND and NOT should be Union['BWhereInputRecursive1', List['BWhereInputRecursive1']]
      # but this causes mypy to hang :/
      AND: List['BWhereInputRecursive1']
      OR: List['BWhereInputRecursive1']
      NOT: List['BWhereInputRecursive1']
  
  
  class BWhereInputRecursive1(TypedDict, total=False):
      """B arguments for searching"""
      id: Union[str, 'types.StringFilter']
      float: Union[float, 'types.FloatFilter']
      d_float: Union[float, 'types.FloatFilter']
  
      # should be noted that AND and NOT should be Union['BWhereInputRecursive2', List['BWhereInputRecursive2']]
      # but this causes mypy to hang :/
      AND: List['BWhereInputRecursive2']
      OR: List['BWhereInputRecursive2']
      NOT: List['BWhereInputRecursive2']
  
  
  class BWhereInputRecursive2(TypedDict, total=False):
      """B arguments for searching"""
      id: Union[str, 'types.StringFilter']
      float: Union[float, 'types.FloatFilter']
      d_float: Union[float, 'types.FloatFilter']
  
  
  
  BCountAggregateInput = TypedDict(
      'BCountAggregateInput',
      {
          'id': bool,
          'float': bool,
          'd_float': bool,
          '_all': bool,
      },
      total=False,
  )
  
  BCountAggregateOutput = TypedDict(
      'BCountAggregateOutput',
      {
          'id': int,
          'float': int,
          'd_float': int,
          '_all': int,
      },
      total=False,
  )
  
  
  BKeys = Literal[
      'id',
      'float',
      'd_float',
  ]
  
  BRelationalFieldKeys = _NoneType
  
  # C types
  
  class COptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the C create method"""
  
  
  class CCreateInput(COptionalCreateInput):
      """Required arguments to the C create method"""
      char: str
      v_char: str
      text: str
      bit: str
      v_bit: str
      uuid: str
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class COptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the C create method, without relations"""
  
  
  class CCreateWithoutRelationsInput(COptionalCreateWithoutRelationsInput):
      """Required arguments to the C create method, without relations"""
      char: str
      v_char: str
      text: str
      bit: str
      v_bit: str
      uuid: str
  
  
  class CCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'CCreateWithoutRelationsInput'
      connect: 'CWhereUniqueInput'
  
  
  class CCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['CCreateWithoutRelationsInput', List['CCreateWithoutRelationsInput']]
      connect: Union['CWhereUniqueInput', List['CWhereUniqueInput']]
  
  
  
  _CCompoundPrimaryKeyInner = TypedDict(
      '_CCompoundPrimaryKeyInner',
      {
          'char': 'str',
          'text': 'str',
      },
      total=True
  )
  
  _CCompoundPrimaryKey = TypedDict(
      '_CCompoundPrimaryKey',
      {
          'my_id': '_CCompoundPrimaryKeyInner',
      },
      total=True
  )
  
  CWhereUniqueInput = _CCompoundPrimaryKey
  
  
  class CUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      char: str
      v_char: str
      text: str
      bit: str
      v_bit: str
      uuid: str
  
  
  class CUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      char: str
      v_char: str
      text: str
      bit: str
      v_bit: str
      uuid: str
  
  
  class CUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['CCreateWithoutRelationsInput']
      connect: List['CWhereUniqueInput']
      set: List['CWhereUniqueInput']
      disconnect: List['CWhereUniqueInput']
      delete: List['CWhereUniqueInput']
  
      # TODO
      # update: List['CUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['CUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['CScalarWhereInput']
      # upsert: List['CUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['CCreateOrConnectWithoutRelationsInput']
  
  
  class CUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'CCreateWithoutRelationsInput'
      connect: 'CWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'CUpdateInput'
      # upsert: 'CUpsertWithoutRelationsInput'
      # connectOrCreate: 'CCreateOrConnectWithoutRelationsInput'
  
  
  class CUpsertInput(TypedDict):
      create: 'CCreateInput'
      update: 'CUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class COrderByInput(TypedDict, total=False):
      char: 'SortOrder'
      v_char: 'SortOrder'
      text: 'SortOrder'
      bit: 'SortOrder'
      v_bit: 'SortOrder'
      uuid: 'SortOrder'
  
  
  # recursive C types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/
  
  CRelationFilter = TypedDict(
      'CRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class CListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class CInclude(TypedDict, total=False):
      """C relational arguments"""
  
  
      
  
  class PostIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
      author: Union[bool, 'UserArgsFromCRecursive1']
  
  
  class PostIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
      author: Union[bool, 'UserArgsFromCRecursive2']
  
  
  class PostIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class PostArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyPostArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
      posts: Union[bool, 'FindManyPostArgsFromCRecursive1']
  
  
  class UserIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
      posts: Union[bool, 'FindManyPostArgsFromCRecursive2']
  
  
  class UserIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class UserArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyUserArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
      n: Union[bool, 'FindManyNArgsFromCRecursive1']
  
  
  class MIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
      n: Union[bool, 'FindManyNArgsFromCRecursive2']
  
  
  class MIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class MArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyMArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
      m: Union[bool, 'FindManyMArgsFromCRecursive1']
  
  
  class NIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
      m: Union[bool, 'FindManyMArgsFromCRecursive2']
  
  
  class NIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class NArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyNArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
      many: Union[bool, 'FindManyManyRequiredArgsFromCRecursive1']
  
  
  class OneOptionalIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
      many: Union[bool, 'FindManyManyRequiredArgsFromCRecursive2']
  
  
  class OneOptionalIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class OneOptionalArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyOneOptionalArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
      one: Union[bool, 'OneOptionalArgsFromCRecursive1']
  
  
  class ManyRequiredIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
      one: Union[bool, 'OneOptionalArgsFromCRecursive2']
  
  
  class ManyRequiredIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class ManyRequiredArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyManyRequiredArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class ListsIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class ListsIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class ListsIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class ListsArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class ListsArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class ListsArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyListsArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class FindManyListsArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class FindManyListsArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      
      
  
  class AIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class AIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class AIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class AArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyAArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class BIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class BIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class BArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyBArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class CIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class CIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class CArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyCArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class DIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class DIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class DArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyDArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromC(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class EIncludeFromCRecursive1(TypedDict, total=False):
      """Relational arguments for C"""
  
  
  class EIncludeFromCRecursive2(TypedDict, total=False):
      """Relational arguments for C"""
  
      
  
  class EArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      
      
  
  class FindManyEArgsFromC(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromCRecursive1(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromCRecursive2(TypedDict, total=False):
      """Arguments for C"""
      take: int
      skip: int
      order_by: Union['COrderByInput', List['COrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyCArgs = FindManyCArgsFromC
  FindFirstCArgs = FindManyCArgsFromC
  
  
      
  
  class CWhereInput(TypedDict, total=False):
      """C arguments for searching"""
      char: Union[str, 'types.StringFilter']
      v_char: Union[str, 'types.StringFilter']
      text: Union[str, 'types.StringFilter']
      bit: Union[str, 'types.StringFilter']
      v_bit: Union[str, 'types.StringFilter']
      uuid: Union[str, 'types.StringFilter']
  
      # should be noted that AND and NOT should be Union['CWhereInputRecursive1', List['CWhereInputRecursive1']]
      # but this causes mypy to hang :/
      AND: List['CWhereInputRecursive1']
      OR: List['CWhereInputRecursive1']
      NOT: List['CWhereInputRecursive1']
  
  
  class CWhereInputRecursive1(TypedDict, total=False):
      """C arguments for searching"""
      char: Union[str, 'types.StringFilter']
      v_char: Union[str, 'types.StringFilter']
      text: Union[str, 'types.StringFilter']
      bit: Union[str, 'types.StringFilter']
      v_bit: Union[str, 'types.StringFilter']
      uuid: Union[str, 'types.StringFilter']
  
      # should be noted that AND and NOT should be Union['CWhereInputRecursive2', List['CWhereInputRecursive2']]
      # but this causes mypy to hang :/
      AND: List['CWhereInputRecursive2']
      OR: List['CWhereInputRecursive2']
      NOT: List['CWhereInputRecursive2']
  
  
  class CWhereInputRecursive2(TypedDict, total=False):
      """C arguments for searching"""
      char: Union[str, 'types.StringFilter']
      v_char: Union[str, 'types.StringFilter']
      text: Union[str, 'types.StringFilter']
      bit: Union[str, 'types.StringFilter']
      v_bit: Union[str, 'types.StringFilter']
      uuid: Union[str, 'types.StringFilter']
  
  
  
  CCountAggregateInput = TypedDict(
      'CCountAggregateInput',
      {
          'char': bool,
          'v_char': bool,
          'text': bool,
          'bit': bool,
          'v_bit': bool,
          'uuid': bool,
          '_all': bool,
      },
      total=False,
  )
  
  CCountAggregateOutput = TypedDict(
      'CCountAggregateOutput',
      {
          'char': int,
          'v_char': int,
          'text': int,
          'bit': int,
          'v_bit': int,
          'uuid': int,
          '_all': int,
      },
      total=False,
  )
  
  
  CKeys = Literal[
      'char',
      'v_char',
      'text',
      'bit',
      'v_bit',
      'uuid',
  ]
  
  CRelationalFieldKeys = _NoneType
  
  # D types
  
  class DOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the D create method"""
      id: str
  
  
  class DCreateInput(DOptionalCreateInput):
      """Required arguments to the D create method"""
      bool: bool
      xml: str
      json_: 'fields.Json'
      jsonb: 'fields.Json'
      binary: 'fields.Base64'
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class DOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the D create method, without relations"""
      id: str
  
  
  class DCreateWithoutRelationsInput(DOptionalCreateWithoutRelationsInput):
      """Required arguments to the D create method, without relations"""
      bool: bool
      xml: str
      json_: 'fields.Json'
      jsonb: 'fields.Json'
      binary: 'fields.Base64'
  
  
  class DCreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'DCreateWithoutRelationsInput'
      connect: 'DWhereUniqueInput'
  
  
  class DCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['DCreateWithoutRelationsInput', List['DCreateWithoutRelationsInput']]
      connect: Union['DWhereUniqueInput', List['DWhereUniqueInput']]
  
  
  
  _DWhereUnique_id_Input = TypedDict(
      '_DWhereUnique_id_Input',
      {
          'id': 'str',
      },
      total=True
  )
  
  DWhereUniqueInput = _DWhereUnique_id_Input
  
  
  class DUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      bool: bool
      xml: str
      json_: 'fields.Json'
      jsonb: 'fields.Json'
      binary: 'fields.Base64'
  
  
  class DUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: str
      bool: bool
      xml: str
      json_: 'fields.Json'
      jsonb: 'fields.Json'
      binary: 'fields.Base64'
  
  
  class DUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['DCreateWithoutRelationsInput']
      connect: List['DWhereUniqueInput']
      set: List['DWhereUniqueInput']
      disconnect: List['DWhereUniqueInput']
      delete: List['DWhereUniqueInput']
  
      # TODO
      # update: List['DUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['DUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['DScalarWhereInput']
      # upsert: List['DUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['DCreateOrConnectWithoutRelationsInput']
  
  
  class DUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'DCreateWithoutRelationsInput'
      connect: 'DWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'DUpdateInput'
      # upsert: 'DUpsertWithoutRelationsInput'
      # connectOrCreate: 'DCreateOrConnectWithoutRelationsInput'
  
  
  class DUpsertInput(TypedDict):
      create: 'DCreateInput'
      update: 'DUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class DOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      bool: 'SortOrder'
      xml: 'SortOrder'
      json_: 'SortOrder'
      jsonb: 'SortOrder'
      binary: 'SortOrder'
  
  
  # recursive D types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/
  
  DRelationFilter = TypedDict(
      'DRelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class DListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class DInclude(TypedDict, total=False):
      """D relational arguments"""
  
  
      
  
  class PostIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
      author: Union[bool, 'UserArgsFromDRecursive1']
  
  
  class PostIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
      author: Union[bool, 'UserArgsFromDRecursive2']
  
  
  class PostIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class PostArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyPostArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
      posts: Union[bool, 'FindManyPostArgsFromDRecursive1']
  
  
  class UserIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
      posts: Union[bool, 'FindManyPostArgsFromDRecursive2']
  
  
  class UserIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class UserArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyUserArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
      n: Union[bool, 'FindManyNArgsFromDRecursive1']
  
  
  class MIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
      n: Union[bool, 'FindManyNArgsFromDRecursive2']
  
  
  class MIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class MArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyMArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
      m: Union[bool, 'FindManyMArgsFromDRecursive1']
  
  
  class NIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
      m: Union[bool, 'FindManyMArgsFromDRecursive2']
  
  
  class NIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class NArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyNArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
      many: Union[bool, 'FindManyManyRequiredArgsFromDRecursive1']
  
  
  class OneOptionalIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
      many: Union[bool, 'FindManyManyRequiredArgsFromDRecursive2']
  
  
  class OneOptionalIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class OneOptionalArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyOneOptionalArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
      one: Union[bool, 'OneOptionalArgsFromDRecursive1']
  
  
  class ManyRequiredIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
      one: Union[bool, 'OneOptionalArgsFromDRecursive2']
  
  
  class ManyRequiredIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class ManyRequiredArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyManyRequiredArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class ListsIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class ListsIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class ListsIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class ListsArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class ListsArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class ListsArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyListsArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class FindManyListsArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class FindManyListsArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      
      
  
  class AIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class AIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class AIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class AArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyAArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class BIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class BIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class BArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyBArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class CIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class CIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class CArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyCArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class DIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class DIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class DArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyDArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromD(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class EIncludeFromDRecursive1(TypedDict, total=False):
      """Relational arguments for D"""
  
  
  class EIncludeFromDRecursive2(TypedDict, total=False):
      """Relational arguments for D"""
  
      
  
  class EArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      
      
  
  class FindManyEArgsFromD(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromDRecursive1(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromDRecursive2(TypedDict, total=False):
      """Arguments for D"""
      take: int
      skip: int
      order_by: Union['DOrderByInput', List['DOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyDArgs = FindManyDArgsFromD
  FindFirstDArgs = FindManyDArgsFromD
  
  
      
  
  class DWhereInput(TypedDict, total=False):
      """D arguments for searching"""
      id: Union[str, 'types.StringFilter']
      bool: Union[bool, 'types.BooleanFilter']
      xml: Union[str, 'types.StringFilter']
      json_: Union['fields.Json', 'types.JsonFilter']
      jsonb: Union['fields.Json', 'types.JsonFilter']
      binary: Union['fields.Base64', 'types.BytesFilter']
  
      # should be noted that AND and NOT should be Union['DWhereInputRecursive1', List['DWhereInputRecursive1']]
      # but this causes mypy to hang :/
      AND: List['DWhereInputRecursive1']
      OR: List['DWhereInputRecursive1']
      NOT: List['DWhereInputRecursive1']
  
  
  class DWhereInputRecursive1(TypedDict, total=False):
      """D arguments for searching"""
      id: Union[str, 'types.StringFilter']
      bool: Union[bool, 'types.BooleanFilter']
      xml: Union[str, 'types.StringFilter']
      json_: Union['fields.Json', 'types.JsonFilter']
      jsonb: Union['fields.Json', 'types.JsonFilter']
      binary: Union['fields.Base64', 'types.BytesFilter']
  
      # should be noted that AND and NOT should be Union['DWhereInputRecursive2', List['DWhereInputRecursive2']]
      # but this causes mypy to hang :/
      AND: List['DWhereInputRecursive2']
      OR: List['DWhereInputRecursive2']
      NOT: List['DWhereInputRecursive2']
  
  
  class DWhereInputRecursive2(TypedDict, total=False):
      """D arguments for searching"""
      id: Union[str, 'types.StringFilter']
      bool: Union[bool, 'types.BooleanFilter']
      xml: Union[str, 'types.StringFilter']
      json_: Union['fields.Json', 'types.JsonFilter']
      jsonb: Union['fields.Json', 'types.JsonFilter']
      binary: Union['fields.Base64', 'types.BytesFilter']
  
  
  
  DCountAggregateInput = TypedDict(
      'DCountAggregateInput',
      {
          'id': bool,
          'bool': bool,
          'xml': bool,
          'json_': bool,
          'jsonb': bool,
          'binary': bool,
          '_all': bool,
      },
      total=False,
  )
  
  DCountAggregateOutput = TypedDict(
      'DCountAggregateOutput',
      {
          'id': int,
          'bool': int,
          'xml': int,
          'json_': int,
          'jsonb': int,
          'binary': int,
          '_all': int,
      },
      total=False,
  )
  
  
  DKeys = Literal[
      'id',
      'bool',
      'xml',
      'json_',
      'jsonb',
      'binary',
  ]
  
  DRelationalFieldKeys = _NoneType
  
  # E types
  
  class EOptionalCreateInput(TypedDict, total=False):
      """Optional arguments to the E create method"""
      id: str
  
  
  class ECreateInput(EOptionalCreateInput):
      """Required arguments to the E create method"""
      date: datetime.datetime
      time: datetime.datetime
      ts: datetime.datetime
  
  
  # TODO: remove this in favour of without explicit relations
  # e.g. PostCreateWithoutAuthorInput
  
  class EOptionalCreateWithoutRelationsInput(TypedDict, total=False):
      """Optional arguments to the E create method, without relations"""
      id: str
  
  
  class ECreateWithoutRelationsInput(EOptionalCreateWithoutRelationsInput):
      """Required arguments to the E create method, without relations"""
      date: datetime.datetime
      time: datetime.datetime
      ts: datetime.datetime
  
  
  class ECreateNestedWithoutRelationsInput(TypedDict, total=False):
      create: 'ECreateWithoutRelationsInput'
      connect: 'EWhereUniqueInput'
  
  
  class ECreateManyNestedWithoutRelationsInput(TypedDict, total=False):
      create: Union['ECreateWithoutRelationsInput', List['ECreateWithoutRelationsInput']]
      connect: Union['EWhereUniqueInput', List['EWhereUniqueInput']]
  
  
  
  _EWhereUnique_id_Input = TypedDict(
      '_EWhereUnique_id_Input',
      {
          'id': 'str',
      },
      total=True
  )
  
  EWhereUniqueInput = _EWhereUnique_id_Input
  
  
  class EUpdateInput(TypedDict, total=False):
      """Optional arguments for updating a record"""
      date: datetime.datetime
      time: datetime.datetime
      ts: datetime.datetime
  
  
  class EUpdateManyMutationInput(TypedDict, total=False):
      """Arguments for updating many records"""
      id: str
      date: datetime.datetime
      time: datetime.datetime
      ts: datetime.datetime
  
  
  class EUpdateManyWithoutRelationsInput(TypedDict, total=False):
      create: List['ECreateWithoutRelationsInput']
      connect: List['EWhereUniqueInput']
      set: List['EWhereUniqueInput']
      disconnect: List['EWhereUniqueInput']
      delete: List['EWhereUniqueInput']
  
      # TODO
      # update: List['EUpdateWithWhereUniqueWithoutRelationsInput']
      # updateMany: List['EUpdateManyWithWhereUniqueWithoutRelationsInput']
      # deleteMany: List['EScalarWhereInput']
      # upsert: List['EUpserteWithWhereUniqueWithoutRelationsInput']
      # connectOrCreate: List['ECreateOrConnectWithoutRelationsInput']
  
  
  class EUpdateOneWithoutRelationsInput(TypedDict, total=False):
      create: 'ECreateWithoutRelationsInput'
      connect: 'EWhereUniqueInput'
      disconnect: bool
      delete: bool
  
      # TODO
      # update: 'EUpdateInput'
      # upsert: 'EUpsertWithoutRelationsInput'
      # connectOrCreate: 'ECreateOrConnectWithoutRelationsInput'
  
  
  class EUpsertInput(TypedDict):
      create: 'ECreateInput'
      update: 'EUpdateInput'  # pyright: reportIncompatibleMethodOverride=false
  
  
  class EOrderByInput(TypedDict, total=False):
      id: 'SortOrder'
      date: 'SortOrder'
      time: 'SortOrder'
      ts: 'SortOrder'
  
  
  # recursive E types
  # TODO: cleanup these types
  
  
  # Dict[str, Any] is a mypy limitation
  # see https://github.com/RobertCraigie/prisma-client-py/issues/45
  # switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/
  
  ERelationFilter = TypedDict(
      'ERelationFilter',
      {
          'is': 'Dict[str, Any]',
          'is_not': 'Dict[str, Any]',
      },
      total=False,
  )
  
  
  class EListRelationFilter(TypedDict, total=False):
      some: 'Dict[str, Any]'
      none: 'Dict[str, Any]'
      every: 'Dict[str, Any]'
  
  
  class EInclude(TypedDict, total=False):
      """E relational arguments"""
  
  
      
  
  class PostIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
      author: Union[bool, 'UserArgsFromERecursive1']
  
  
  class PostIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
      author: Union[bool, 'UserArgsFromERecursive2']
  
  
  class PostIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class PostArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'PostIncludeFromPostRecursive1'
  
  
  class PostArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'PostIncludeFromPostRecursive2'
  
  
  class PostArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyPostArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive1'
  
  
  class FindManyPostArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      include: 'PostIncludeFromPostRecursive2'
  
  
  class FindManyPostArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'PostWhereInput'
      cursor: 'PostWhereUniqueInput'
      
      
  
  class UserIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
      posts: Union[bool, 'FindManyPostArgsFromERecursive1']
  
  
  class UserIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
      posts: Union[bool, 'FindManyPostArgsFromERecursive2']
  
  
  class UserIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class UserArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'UserIncludeFromUserRecursive1'
  
  
  class UserArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'UserIncludeFromUserRecursive2'
  
  
  class UserArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyUserArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive1'
  
  
  class FindManyUserArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      include: 'UserIncludeFromUserRecursive2'
  
  
  class FindManyUserArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'UserWhereInput'
      cursor: 'UserWhereUniqueInput'
      
      
  
  class MIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
      n: Union[bool, 'FindManyNArgsFromERecursive1']
  
  
  class MIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
      n: Union[bool, 'FindManyNArgsFromERecursive2']
  
  
  class MIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class MArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'MIncludeFromMRecursive1'
  
  
  class MArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'MIncludeFromMRecursive2'
  
  
  class MArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyMArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive1'
  
  
  class FindManyMArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      include: 'MIncludeFromMRecursive2'
  
  
  class FindManyMArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'MWhereInput'
      cursor: 'MWhereUniqueInput'
      
      
  
  class NIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
      m: Union[bool, 'FindManyMArgsFromERecursive1']
  
  
  class NIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
      m: Union[bool, 'FindManyMArgsFromERecursive2']
  
  
  class NIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class NArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'NIncludeFromNRecursive1'
  
  
  class NArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'NIncludeFromNRecursive2'
  
  
  class NArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyNArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive1'
  
  
  class FindManyNArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      include: 'NIncludeFromNRecursive2'
  
  
  class FindManyNArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'NWhereInput'
      cursor: 'NWhereUniqueInput'
      
      
  
  class OneOptionalIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
      many: Union[bool, 'FindManyManyRequiredArgsFromERecursive1']
  
  
  class OneOptionalIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
      many: Union[bool, 'FindManyManyRequiredArgsFromERecursive2']
  
  
  class OneOptionalIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class OneOptionalArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class OneOptionalArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class OneOptionalArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyOneOptionalArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive1'
  
  
  class FindManyOneOptionalArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      include: 'OneOptionalIncludeFromOneOptionalRecursive2'
  
  
  class FindManyOneOptionalArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'OneOptionalWhereInput'
      cursor: 'OneOptionalWhereUniqueInput'
      
      
  
  class ManyRequiredIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
      one: Union[bool, 'OneOptionalArgsFromERecursive1']
  
  
  class ManyRequiredIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
      one: Union[bool, 'OneOptionalArgsFromERecursive2']
  
  
  class ManyRequiredIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class ManyRequiredArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class ManyRequiredArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class ManyRequiredArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyManyRequiredArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive1'
  
  
  class FindManyManyRequiredArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      include: 'ManyRequiredIncludeFromManyRequiredRecursive2'
  
  
  class FindManyManyRequiredArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'ManyRequiredWhereInput'
      cursor: 'ManyRequiredWhereUniqueInput'
      
      
  
  class ListsIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class ListsIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class ListsIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class ListsArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class ListsArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class ListsArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyListsArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive1'
  
  
  class FindManyListsArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      include: 'ListsIncludeFromListsRecursive2'
  
  
  class FindManyListsArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'ListsWhereInput'
      cursor: 'ListsWhereUniqueInput'
      
      
  
  class AIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class AIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class AIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class AArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'AIncludeFromARecursive1'
  
  
  class AArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'AIncludeFromARecursive2'
  
  
  class AArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyAArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive1'
  
  
  class FindManyAArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      include: 'AIncludeFromARecursive2'
  
  
  class FindManyAArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'AWhereInput'
      cursor: 'AWhereUniqueInput'
      
      
  
  class BIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class BIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class BIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class BArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'BIncludeFromBRecursive1'
  
  
  class BArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'BIncludeFromBRecursive2'
  
  
  class BArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyBArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive1'
  
  
  class FindManyBArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      include: 'BIncludeFromBRecursive2'
  
  
  class FindManyBArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'BWhereInput'
      cursor: 'BWhereUniqueInput'
      
      
  
  class CIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class CIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class CIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class CArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'CIncludeFromCRecursive1'
  
  
  class CArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'CIncludeFromCRecursive2'
  
  
  class CArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyCArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive1'
  
  
  class FindManyCArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      include: 'CIncludeFromCRecursive2'
  
  
  class FindManyCArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'CWhereInput'
      cursor: 'CWhereUniqueInput'
      
      
  
  class DIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class DIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class DIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class DArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'DIncludeFromDRecursive1'
  
  
  class DArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'DIncludeFromDRecursive2'
  
  
  class DArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyDArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive1'
  
  
  class FindManyDArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      include: 'DIncludeFromDRecursive2'
  
  
  class FindManyDArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'DWhereInput'
      cursor: 'DWhereUniqueInput'
      
      
  
  class EIncludeFromE(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class EIncludeFromERecursive1(TypedDict, total=False):
      """Relational arguments for E"""
  
  
  class EIncludeFromERecursive2(TypedDict, total=False):
      """Relational arguments for E"""
  
      
  
  class EArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      include: 'EIncludeFromERecursive1'
  
  
  class EArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      include: 'EIncludeFromERecursive2'
  
  
  class EArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      
      
  
  class FindManyEArgsFromE(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive1'
  
  
  class FindManyEArgsFromERecursive1(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      include: 'EIncludeFromERecursive2'
  
  
  class FindManyEArgsFromERecursive2(TypedDict, total=False):
      """Arguments for E"""
      take: int
      skip: int
      order_by: Union['EOrderByInput', List['EOrderByInput']]
      where: 'EWhereInput'
      cursor: 'EWhereUniqueInput'
      
  
  
  FindManyEArgs = FindManyEArgsFromE
  FindFirstEArgs = FindManyEArgsFromE
  
  
      
  
  class EWhereInput(TypedDict, total=False):
      """E arguments for searching"""
      id: Union[str, 'types.StringFilter']
      date: Union[datetime.datetime, 'types.DateTimeFilter']
      time: Union[datetime.datetime, 'types.DateTimeFilter']
      ts: Union[datetime.datetime, 'types.DateTimeFilter']
  
      # should be noted that AND and NOT should be Union['EWhereInputRecursive1', List['EWhereInputRecursive1']]
      # but this causes mypy to hang :/
      AND: List['EWhereInputRecursive1']
      OR: List['EWhereInputRecursive1']
      NOT: List['EWhereInputRecursive1']
  
  
  class EWhereInputRecursive1(TypedDict, total=False):
      """E arguments for searching"""
      id: Union[str, 'types.StringFilter']
      date: Union[datetime.datetime, 'types.DateTimeFilter']
      time: Union[datetime.datetime, 'types.DateTimeFilter']
      ts: Union[datetime.datetime, 'types.DateTimeFilter']
  
      # should be noted that AND and NOT should be Union['EWhereInputRecursive2', List['EWhereInputRecursive2']]
      # but this causes mypy to hang :/
      AND: List['EWhereInputRecursive2']
      OR: List['EWhereInputRecursive2']
      NOT: List['EWhereInputRecursive2']
  
  
  class EWhereInputRecursive2(TypedDict, total=False):
      """E arguments for searching"""
      id: Union[str, 'types.StringFilter']
      date: Union[datetime.datetime, 'types.DateTimeFilter']
      time: Union[datetime.datetime, 'types.DateTimeFilter']
      ts: Union[datetime.datetime, 'types.DateTimeFilter']
  
  
  
  ECountAggregateInput = TypedDict(
      'ECountAggregateInput',
      {
          'id': bool,
          'date': bool,
          'time': bool,
          'ts': bool,
          '_all': bool,
      },
      total=False,
  )
  
  ECountAggregateOutput = TypedDict(
      'ECountAggregateOutput',
      {
          'id': int,
          'date': int,
          'time': int,
          'ts': int,
          '_all': int,
      },
      total=False,
  )
  
  
  EKeys = Literal[
      'id',
      'date',
      'time',
      'ts',
  ]
  
  ERelationalFieldKeys = _NoneType
  
  
  
  # we have to import ourselves as types can be namespaced to types
  from . import types, enums, models, fields
  '
---
