'''
# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List[Any],
    Dict[None, Any],
    Dict[bool, Any],
    Dict[float, Any],
    Dict[int, Any],
    Dict[str, Any],
]


    

StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive1'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive1 = TypedDict(
    'StringFilterRecursive1',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive2'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive2 = TypedDict(
    'StringFilterRecursive2',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
                'mode': SortMode,
        'search': str,
    },
    total=False,
)


class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


    

DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
    },
    total=False,
)


DateTimeFilterRecursive1 = TypedDict(
    'DateTimeFilterRecursive1',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
    },
    total=False,
)


DateTimeFilterRecursive2 = TypedDict(
    'DateTimeFilterRecursive2',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
            },
    total=False,
)


class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


    

BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive1'],
    },
    total=False,
)


BooleanFilterRecursive1 = TypedDict(
    'BooleanFilterRecursive1',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive2'],
    },
    total=False,
)


BooleanFilterRecursive2 = TypedDict(
    'BooleanFilterRecursive2',
    {
        'equals': bool,
            },
    total=False,
)


class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


    

IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive1'],
    },
    total=False,
)


IntFilterRecursive1 = TypedDict(
    'IntFilterRecursive1',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive2'],
    },
    total=False,
)


IntFilterRecursive2 = TypedDict(
    'IntFilterRecursive2',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
            },
    total=False,
)


class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
    

FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive1'],
    },
    total=False,
)


FloatFilterRecursive1 = TypedDict(
    'FloatFilterRecursive1',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive2'],
    },
    total=False,
)


FloatFilterRecursive2 = TypedDict(
    'FloatFilterRecursive2',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
            },
    total=False,
)


class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


    

BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive1'],
    },
    total=False,
)


BytesFilterRecursive1 = TypedDict(
    'BytesFilterRecursive1',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive2'],
    },
    total=False,
)


BytesFilterRecursive2 = TypedDict(
    'BytesFilterRecursive2',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
            },
    total=False,
)


class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


    

DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive1'],
    },
    total=False,
)


DecimalFilterRecursive1 = TypedDict(
    'DecimalFilterRecursive1',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive2'],
    },
    total=False,
)


DecimalFilterRecursive2 = TypedDict(
    'DecimalFilterRecursive2',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
            },
    total=False,
)


class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]

class _ABeautifulEnumListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.ABeautifulEnum']]


class _ABeautifulEnumListFilterHasInput(TypedDict):
    has: 'enums.ABeautifulEnum'


class _ABeautifulEnumListFilterHasEveryInput(TypedDict):
    has_every: List['enums.ABeautifulEnum']


class _ABeautifulEnumListFilterHasSomeInput(TypedDict):
    has_some: List['enums.ABeautifulEnum']


class _ABeautifulEnumListFilterIsEmptyInput(TypedDict):
    is_empty: bool


ABeautifulEnumListFilter = Union[
    _ABeautifulEnumListFilterHasInput,
    _ABeautifulEnumListFilterEqualsInput,
    _ABeautifulEnumListFilterHasSomeInput,
    _ABeautifulEnumListFilterIsEmptyInput,
    _ABeautifulEnumListFilterHasEveryInput,
]


class _ABeautifulEnumListUpdateSet(TypedDict):
    set: List['enums.ABeautifulEnum']


class _ABeautifulEnumListUpdatePush(TypedDict):
    push: List['enums.ABeautifulEnum']


ABeautifulEnumListUpdate = Union[
    List['enums.ABeautifulEnum'],
    _ABeautifulEnumListUpdateSet,
    _ABeautifulEnumListUpdatePush,
]


# Post types

class PostOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Post create method"""
    id: _int
    created_at: datetime.datetime
    content: Optional[_str]
    published: _bool
    author: 'UserCreateNestedWithoutRelationsInput'
    author_id: _int


class PostCreateInput(PostOptionalCreateInput):
    """Required arguments to the Post create method"""
    title: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class PostOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Post create method, without relations"""
    id: _int
    created_at: datetime.datetime
    content: Optional[_str]
    published: _bool
    author_id: _int


class PostCreateWithoutRelationsInput(PostOptionalCreateWithoutRelationsInput):
    """Required arguments to the Post create method, without relations"""
    title: _str

class PostConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'PostCreateWithoutRelationsInput'
    where: 'PostWhereUniqueInput'

class PostCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'PostCreateWithoutRelationsInput'
    connect: 'PostWhereUniqueInput'
    connect_or_create: 'PostConnectOrCreateWithoutRelationsInput'


class PostCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['PostCreateWithoutRelationsInput', List['PostCreateWithoutRelationsInput']]
    connect: Union['PostWhereUniqueInput', List['PostWhereUniqueInput']]
    connect_or_create: Union['PostConnectOrCreateWithoutRelationsInput', List['PostConnectOrCreateWithoutRelationsInput']]

_PostWhereUnique_id_Input = TypedDict(
    '_PostWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

PostWhereUniqueInput = _PostWhereUnique_id_Input


class PostUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    created_at: datetime.datetime
    title: _str
    content: Optional[_str]
    published: _bool
    author: 'UserUpdateOneWithoutRelationsInput'


class PostUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    created_at: datetime.datetime
    title: _str
    content: Optional[_str]
    published: _bool


class PostUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['PostCreateWithoutRelationsInput']
    connect: List['PostWhereUniqueInput']
    connect_or_create: List['PostConnectOrCreateWithoutRelationsInput']
    set: List['PostWhereUniqueInput']
    disconnect: List['PostWhereUniqueInput']
    delete: List['PostWhereUniqueInput']

    # TODO
    # update: List['PostUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['PostUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['PostScalarWhereInput']
    # upsert: List['PostUpserteWithWhereUniqueWithoutRelationsInput']


class PostUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'PostCreateWithoutRelationsInput'
    connect: 'PostWhereUniqueInput'
    connect_or_create: 'PostConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'PostUpdateInput'
    # upsert: 'PostUpsertWithoutRelationsInput'


class PostUpsertInput(TypedDict):
    create: 'PostCreateInput'
    update: 'PostUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Post_id_OrderByInput = TypedDict(
    '_Post_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Post_created_at_OrderByInput = TypedDict(
    '_Post_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_Post_title_OrderByInput = TypedDict(
    '_Post_title_OrderByInput',
    {
        'title': 'SortOrder',
    },
    total=True
)

_Post_content_OrderByInput = TypedDict(
    '_Post_content_OrderByInput',
    {
        'content': 'SortOrder',
    },
    total=True
)

_Post_published_OrderByInput = TypedDict(
    '_Post_published_OrderByInput',
    {
        'published': 'SortOrder',
    },
    total=True
)

_Post_author_id_OrderByInput = TypedDict(
    '_Post_author_id_OrderByInput',
    {
        'author_id': 'SortOrder',
    },
    total=True
)

_Post_RelevanceInner = TypedDict(
    '_Post_RelevanceInner',
    {
        'fields': 'List[PostScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Post_RelevanceOrderByInput = TypedDict(
    '_Post_RelevanceOrderByInput',
    {
        '_relevance': '_Post_RelevanceInner',
    },
    total=True
)

PostOrderByInput = Union[
    '_Post_id_OrderByInput',
    '_Post_created_at_OrderByInput',
    '_Post_title_OrderByInput',
    '_Post_content_OrderByInput',
    '_Post_published_OrderByInput',
    '_Post_author_id_OrderByInput',
    '_Post_RelevanceOrderByInput',
]



# recursive Post types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

PostRelationFilter = TypedDict(
    'PostRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class PostListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class PostInclude(TypedDict, total=False):
    """Post relational arguments"""
    author: Union[bool, 'UserArgsFromPost']


    

class PostIncludeFromPost(TypedDict, total=False):
    """Relational arguments for Post"""
    author: Union[bool, 'UserArgsFromPostRecursive1']


class PostIncludeFromPostRecursive1(TypedDict, total=False):
    """Relational arguments for Post"""
    author: Union[bool, 'UserArgsFromPostRecursive2']


class PostIncludeFromPostRecursive2(TypedDict, total=False):
    """Relational arguments for Post"""

    

class PostArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    include: 'PostIncludeFromPostRecursive1'


class PostArgsFromPostRecursive1(TypedDict, total=False):
    """Arguments for Post"""
    include: 'PostIncludeFromPostRecursive2'


class PostArgsFromPostRecursive2(TypedDict, total=False):
    """Arguments for Post"""
    
    

class FindManyPostArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPostRecursive1'


class FindManyPostArgsFromPostRecursive1(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPostRecursive2'


class FindManyPostArgsFromPostRecursive2(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    
    

class UserIncludeFromPost(TypedDict, total=False):
    """Relational arguments for Post"""
    posts: Union[bool, 'FindManyPostArgsFromPostRecursive1']


class UserIncludeFromPostRecursive1(TypedDict, total=False):
    """Relational arguments for Post"""
    posts: Union[bool, 'FindManyPostArgsFromPostRecursive2']


class UserIncludeFromPostRecursive2(TypedDict, total=False):
    """Relational arguments for Post"""

    

class UserArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromPostRecursive1(TypedDict, total=False):
    """Arguments for Post"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromPostRecursive2(TypedDict, total=False):
    """Arguments for Post"""
    
    

class FindManyUserArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromPostRecursive1(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromPostRecursive2(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class MIncludeFromPost(TypedDict, total=False):
    """Relational arguments for Post"""
    n: Union[bool, 'FindManyNArgsFromPostRecursive1']


class MIncludeFromPostRecursive1(TypedDict, total=False):
    """Relational arguments for Post"""
    n: Union[bool, 'FindManyNArgsFromPostRecursive2']


class MIncludeFromPostRecursive2(TypedDict, total=False):
    """Relational arguments for Post"""

    

class MArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    include: 'MIncludeFromMRecursive1'


class MArgsFromPostRecursive1(TypedDict, total=False):
    """Arguments for Post"""
    include: 'MIncludeFromMRecursive2'


class MArgsFromPostRecursive2(TypedDict, total=False):
    """Arguments for Post"""
    
    

class FindManyMArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromMRecursive1'


class FindManyMArgsFromPostRecursive1(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromMRecursive2'


class FindManyMArgsFromPostRecursive2(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    
    

class NIncludeFromPost(TypedDict, total=False):
    """Relational arguments for Post"""
    m: Union[bool, 'FindManyMArgsFromPostRecursive1']


class NIncludeFromPostRecursive1(TypedDict, total=False):
    """Relational arguments for Post"""
    m: Union[bool, 'FindManyMArgsFromPostRecursive2']


class NIncludeFromPostRecursive2(TypedDict, total=False):
    """Relational arguments for Post"""

    

class NArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    include: 'NIncludeFromNRecursive1'


class NArgsFromPostRecursive1(TypedDict, total=False):
    """Arguments for Post"""
    include: 'NIncludeFromNRecursive2'


class NArgsFromPostRecursive2(TypedDict, total=False):
    """Arguments for Post"""
    
    

class FindManyNArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromNRecursive1'


class FindManyNArgsFromPostRecursive1(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromNRecursive2'


class FindManyNArgsFromPostRecursive2(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    
    

class OneOptionalIncludeFromPost(TypedDict, total=False):
    """Relational arguments for Post"""
    many: Union[bool, 'FindManyManyRequiredArgsFromPostRecursive1']


class OneOptionalIncludeFromPostRecursive1(TypedDict, total=False):
    """Relational arguments for Post"""
    many: Union[bool, 'FindManyManyRequiredArgsFromPostRecursive2']


class OneOptionalIncludeFromPostRecursive2(TypedDict, total=False):
    """Relational arguments for Post"""

    

class OneOptionalArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    include: 'OneOptionalIncludeFromOneOptionalRecursive1'


class OneOptionalArgsFromPostRecursive1(TypedDict, total=False):
    """Arguments for Post"""
    include: 'OneOptionalIncludeFromOneOptionalRecursive2'


class OneOptionalArgsFromPostRecursive2(TypedDict, total=False):
    """Arguments for Post"""
    
    

class FindManyOneOptionalArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromOneOptionalRecursive1'


class FindManyOneOptionalArgsFromPostRecursive1(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromOneOptionalRecursive2'


class FindManyOneOptionalArgsFromPostRecursive2(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    
    

class ManyRequiredIncludeFromPost(TypedDict, total=False):
    """Relational arguments for Post"""
    one: Union[bool, 'OneOptionalArgsFromPostRecursive1']


class ManyRequiredIncludeFromPostRecursive1(TypedDict, total=False):
    """Relational arguments for Post"""
    one: Union[bool, 'OneOptionalArgsFromPostRecursive2']


class ManyRequiredIncludeFromPostRecursive2(TypedDict, total=False):
    """Relational arguments for Post"""

    

class ManyRequiredArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    include: 'ManyRequiredIncludeFromManyRequiredRecursive1'


class ManyRequiredArgsFromPostRecursive1(TypedDict, total=False):
    """Arguments for Post"""
    include: 'ManyRequiredIncludeFromManyRequiredRecursive2'


class ManyRequiredArgsFromPostRecursive2(TypedDict, total=False):
    """Arguments for Post"""
    
    

class FindManyManyRequiredArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromManyRequiredRecursive1'


class FindManyManyRequiredArgsFromPostRecursive1(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromManyRequiredRecursive2'


class FindManyManyRequiredArgsFromPostRecursive2(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    
    

class ListsIncludeFromPost(TypedDict, total=False):
    """Relational arguments for Post"""


class ListsIncludeFromPostRecursive1(TypedDict, total=False):
    """Relational arguments for Post"""


class ListsIncludeFromPostRecursive2(TypedDict, total=False):
    """Relational arguments for Post"""

    

class ListsArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    include: 'ListsIncludeFromListsRecursive1'


class ListsArgsFromPostRecursive1(TypedDict, total=False):
    """Arguments for Post"""
    include: 'ListsIncludeFromListsRecursive2'


class ListsArgsFromPostRecursive2(TypedDict, total=False):
    """Arguments for Post"""
    
    

class FindManyListsArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromListsRecursive1'


class FindManyListsArgsFromPostRecursive1(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromListsRecursive2'


class FindManyListsArgsFromPostRecursive2(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    
    

class AIncludeFromPost(TypedDict, total=False):
    """Relational arguments for Post"""


class AIncludeFromPostRecursive1(TypedDict, total=False):
    """Relational arguments for Post"""


class AIncludeFromPostRecursive2(TypedDict, total=False):
    """Relational arguments for Post"""

    

class AArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    include: 'AIncludeFromARecursive1'


class AArgsFromPostRecursive1(TypedDict, total=False):
    """Arguments for Post"""
    include: 'AIncludeFromARecursive2'


class AArgsFromPostRecursive2(TypedDict, total=False):
    """Arguments for Post"""
    
    

class FindManyAArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromARecursive1'


class FindManyAArgsFromPostRecursive1(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromARecursive2'


class FindManyAArgsFromPostRecursive2(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    
    

class BIncludeFromPost(TypedDict, total=False):
    """Relational arguments for Post"""


class BIncludeFromPostRecursive1(TypedDict, total=False):
    """Relational arguments for Post"""


class BIncludeFromPostRecursive2(TypedDict, total=False):
    """Relational arguments for Post"""

    

class BArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    include: 'BIncludeFromBRecursive1'


class BArgsFromPostRecursive1(TypedDict, total=False):
    """Arguments for Post"""
    include: 'BIncludeFromBRecursive2'


class BArgsFromPostRecursive2(TypedDict, total=False):
    """Arguments for Post"""
    
    

class FindManyBArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromBRecursive1'


class FindManyBArgsFromPostRecursive1(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromBRecursive2'


class FindManyBArgsFromPostRecursive2(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    
    

class CIncludeFromPost(TypedDict, total=False):
    """Relational arguments for Post"""


class CIncludeFromPostRecursive1(TypedDict, total=False):
    """Relational arguments for Post"""


class CIncludeFromPostRecursive2(TypedDict, total=False):
    """Relational arguments for Post"""

    

class CArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    include: 'CIncludeFromCRecursive1'


class CArgsFromPostRecursive1(TypedDict, total=False):
    """Arguments for Post"""
    include: 'CIncludeFromCRecursive2'


class CArgsFromPostRecursive2(TypedDict, total=False):
    """Arguments for Post"""
    
    

class FindManyCArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromCRecursive1'


class FindManyCArgsFromPostRecursive1(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromCRecursive2'


class FindManyCArgsFromPostRecursive2(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    
    

class DIncludeFromPost(TypedDict, total=False):
    """Relational arguments for Post"""


class DIncludeFromPostRecursive1(TypedDict, total=False):
    """Relational arguments for Post"""


class DIncludeFromPostRecursive2(TypedDict, total=False):
    """Relational arguments for Post"""

    

class DArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    include: 'DIncludeFromDRecursive1'


class DArgsFromPostRecursive1(TypedDict, total=False):
    """Arguments for Post"""
    include: 'DIncludeFromDRecursive2'


class DArgsFromPostRecursive2(TypedDict, total=False):
    """Arguments for Post"""
    
    

class FindManyDArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromDRecursive1'


class FindManyDArgsFromPostRecursive1(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromDRecursive2'


class FindManyDArgsFromPostRecursive2(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    
    

class EIncludeFromPost(TypedDict, total=False):
    """Relational arguments for Post"""


class EIncludeFromPostRecursive1(TypedDict, total=False):
    """Relational arguments for Post"""


class EIncludeFromPostRecursive2(TypedDict, total=False):
    """Relational arguments for Post"""

    

class EArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    include: 'EIncludeFromERecursive1'


class EArgsFromPostRecursive1(TypedDict, total=False):
    """Arguments for Post"""
    include: 'EIncludeFromERecursive2'


class EArgsFromPostRecursive2(TypedDict, total=False):
    """Arguments for Post"""
    
    

class FindManyEArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromERecursive1'


class FindManyEArgsFromPostRecursive1(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromERecursive2'


class FindManyEArgsFromPostRecursive2(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    


FindManyPostArgs = FindManyPostArgsFromPost
FindFirstPostArgs = FindManyPostArgsFromPost


    

class PostWhereInput(TypedDict, total=False):
    """Post arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    title: Union[_str, 'types.StringFilter']
    content: Union[None, _str, 'types.StringFilter']
    published: Union[_bool, 'types.BooleanFilter']
    author: 'UserRelationFilter'
    author_id: Union[_int, 'types.IntFilter']

    # should be noted that AND and NOT should be Union['PostWhereInputRecursive1', List['PostWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['PostWhereInputRecursive1']
    OR: List['PostWhereInputRecursive1']
    NOT: List['PostWhereInputRecursive1']


class PostWhereInputRecursive1(TypedDict, total=False):
    """Post arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    title: Union[_str, 'types.StringFilter']
    content: Union[None, _str, 'types.StringFilter']
    published: Union[_bool, 'types.BooleanFilter']
    author: 'UserRelationFilter'
    author_id: Union[_int, 'types.IntFilter']

    # should be noted that AND and NOT should be Union['PostWhereInputRecursive2', List['PostWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['PostWhereInputRecursive2']
    OR: List['PostWhereInputRecursive2']
    NOT: List['PostWhereInputRecursive2']


class PostWhereInputRecursive2(TypedDict, total=False):
    """Post arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    title: Union[_str, 'types.StringFilter']
    content: Union[None, _str, 'types.StringFilter']
    published: Union[_bool, 'types.BooleanFilter']
    author: 'UserRelationFilter'
    author_id: Union[_int, 'types.IntFilter']



# aggregate Post types


    

class PostScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Post arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    content: Union[_str, 'types.StringWithAggregatesFilter']
    published: Union[_bool, 'types.BooleanWithAggregatesFilter']
    author_id: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['PostScalarWhereWithAggregatesInputRecursive1']
    OR: List['PostScalarWhereWithAggregatesInputRecursive1']
    NOT: List['PostScalarWhereWithAggregatesInputRecursive1']


class PostScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Post arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    content: Union[_str, 'types.StringWithAggregatesFilter']
    published: Union[_bool, 'types.BooleanWithAggregatesFilter']
    author_id: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['PostScalarWhereWithAggregatesInputRecursive2']
    OR: List['PostScalarWhereWithAggregatesInputRecursive2']
    NOT: List['PostScalarWhereWithAggregatesInputRecursive2']


class PostScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Post arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    content: Union[_str, 'types.StringWithAggregatesFilter']
    published: Union[_bool, 'types.BooleanWithAggregatesFilter']
    author_id: Union[_int, 'types.IntWithAggregatesFilter']



class PostGroupByOutput(TypedDict, total=False):
    id: _int
    created_at: datetime.datetime
    title: _str
    content: _str
    published: _bool
    author_id: _int
    _sum: 'PostSumAggregateOutput'
    _avg: 'PostAvgAggregateOutput'
    _min: 'PostMinAggregateOutput'
    _max: 'PostMaxAggregateOutput'
    _count: 'PostCountAggregateOutput'


class PostAvgAggregateOutput(TypedDict, total=False):
    """Post output for aggregating averages"""
    id: float
    author_id: float


class PostSumAggregateOutput(TypedDict, total=False):
    """Post output for aggregating sums"""
    id: _int
    author_id: _int


class PostScalarAggregateOutput(TypedDict, total=False):
    """Post output including scalar fields"""
    id: _int
    created_at: datetime.datetime
    title: _str
    content: _str
    published: _bool
    author_id: _int


PostMinAggregateOutput = PostScalarAggregateOutput
PostMaxAggregateOutput = PostScalarAggregateOutput


class PostMaxAggregateInput(TypedDict, total=False):
    """Post input for aggregating by max"""
    id: bool
    created_at: bool
    title: bool
    content: bool
    published: bool
    author_id: bool


class PostMinAggregateInput(TypedDict, total=False):
    """Post input for aggregating by min"""
    id: bool
    created_at: bool
    title: bool
    content: bool
    published: bool
    author_id: bool


class PostNumberAggregateInput(TypedDict, total=False):
    """Post input for aggregating numbers"""
    id: bool
    author_id: bool


PostAvgAggregateInput = PostNumberAggregateInput
PostSumAggregateInput = PostNumberAggregateInput


PostCountAggregateInput = TypedDict(
    'PostCountAggregateInput',
    {
        'id': bool,
        'created_at': bool,
        'title': bool,
        'content': bool,
        'published': bool,
        'author_id': bool,
        '_all': bool,
    },
    total=False,
)

PostCountAggregateOutput = TypedDict(
    'PostCountAggregateOutput',
    {
        'id': int,
        'created_at': int,
        'title': int,
        'content': int,
        'published': int,
        'author_id': int,
        '_all': int,
    },
    total=False,
)


PostKeys = Literal[
    'id',
    'created_at',
    'title',
    'content',
    'published',
    'author',
    'author_id',
]
PostScalarFieldKeys = Literal[
    'id',
    'created_at',
    'title',
    'content',
    'published',
    'author_id',
]
PostScalarFieldKeysT = TypeVar('PostScalarFieldKeysT', bound=PostScalarFieldKeys)

PostRelationalFieldKeys = Literal[
        'author',
    ]

# User types

class UserOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the User create method"""
    id: _int
    optional_int: Optional[_int]
    optional_float: Optional[_float]
    optional_string: Optional[_str]
    optional_enum: Optional['enums.ABeautifulEnum']
    optional_boolean: Optional[_bool]
    posts: 'PostCreateManyNestedWithoutRelationsInput'


class UserCreateInput(UserOptionalCreateInput):
    """Required arguments to the User create method"""
    email: _str
    int: _int
    float: _float
    string: _str
    enum: 'enums.ABeautifulEnum'
    boolean: _bool


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UserOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the User create method, without relations"""
    id: _int
    optional_int: Optional[_int]
    optional_float: Optional[_float]
    optional_string: Optional[_str]
    optional_enum: Optional['enums.ABeautifulEnum']
    optional_boolean: Optional[_bool]


class UserCreateWithoutRelationsInput(UserOptionalCreateWithoutRelationsInput):
    """Required arguments to the User create method, without relations"""
    email: _str
    int: _int
    float: _float
    string: _str
    enum: 'enums.ABeautifulEnum'
    boolean: _bool

class UserConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'UserCreateWithoutRelationsInput'
    where: 'UserWhereUniqueInput'

class UserCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    connect_or_create: 'UserConnectOrCreateWithoutRelationsInput'


class UserCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UserCreateWithoutRelationsInput', List['UserCreateWithoutRelationsInput']]
    connect: Union['UserWhereUniqueInput', List['UserWhereUniqueInput']]
    connect_or_create: Union['UserConnectOrCreateWithoutRelationsInput', List['UserConnectOrCreateWithoutRelationsInput']]

_UserWhereUnique_id_Input = TypedDict(
    '_UserWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_UserWhereUnique_email_Input = TypedDict(
    '_UserWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

UserWhereUniqueInput = Union[
    '_UserWhereUnique_id_Input',
    '_UserWhereUnique_email_Input',
]


class UserUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    email: _str
    int: Union[AtomicIntInput, _int]
    optional_int: Optional[Union[AtomicIntInput, _int]]
    float: Union[AtomicFloatInput, _float]
    optional_float: Optional[Union[AtomicFloatInput, _float]]
    string: _str
    optional_string: Optional[_str]
    enum: 'enums.ABeautifulEnum'
    optional_enum: Optional['enums.ABeautifulEnum']
    boolean: _bool
    optional_boolean: Optional[_bool]
    posts: 'PostUpdateManyWithoutRelationsInput'


class UserUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    email: _str
    int: Union[AtomicIntInput, _int]
    optional_int: Optional[Union[AtomicIntInput, _int]]
    float: Union[AtomicFloatInput, _float]
    optional_float: Optional[Union[AtomicFloatInput, _float]]
    string: _str
    optional_string: Optional[_str]
    enum: 'enums.ABeautifulEnum'
    optional_enum: Optional['enums.ABeautifulEnum']
    boolean: _bool
    optional_boolean: Optional[_bool]


class UserUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UserCreateWithoutRelationsInput']
    connect: List['UserWhereUniqueInput']
    connect_or_create: List['UserConnectOrCreateWithoutRelationsInput']
    set: List['UserWhereUniqueInput']
    disconnect: List['UserWhereUniqueInput']
    delete: List['UserWhereUniqueInput']

    # TODO
    # update: List['UserUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UserUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UserScalarWhereInput']
    # upsert: List['UserUpserteWithWhereUniqueWithoutRelationsInput']


class UserUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    connect_or_create: 'UserConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UserUpdateInput'
    # upsert: 'UserUpsertWithoutRelationsInput'


class UserUpsertInput(TypedDict):
    create: 'UserCreateInput'
    update: 'UserUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_User_id_OrderByInput = TypedDict(
    '_User_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_User_email_OrderByInput = TypedDict(
    '_User_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_User_int_OrderByInput = TypedDict(
    '_User_int_OrderByInput',
    {
        'int': 'SortOrder',
    },
    total=True
)

_User_optional_int_OrderByInput = TypedDict(
    '_User_optional_int_OrderByInput',
    {
        'optional_int': 'SortOrder',
    },
    total=True
)

_User_float_OrderByInput = TypedDict(
    '_User_float_OrderByInput',
    {
        'float': 'SortOrder',
    },
    total=True
)

_User_optional_float_OrderByInput = TypedDict(
    '_User_optional_float_OrderByInput',
    {
        'optional_float': 'SortOrder',
    },
    total=True
)

_User_string_OrderByInput = TypedDict(
    '_User_string_OrderByInput',
    {
        'string': 'SortOrder',
    },
    total=True
)

_User_optional_string_OrderByInput = TypedDict(
    '_User_optional_string_OrderByInput',
    {
        'optional_string': 'SortOrder',
    },
    total=True
)

_User_enum_OrderByInput = TypedDict(
    '_User_enum_OrderByInput',
    {
        'enum': 'SortOrder',
    },
    total=True
)

_User_optional_enum_OrderByInput = TypedDict(
    '_User_optional_enum_OrderByInput',
    {
        'optional_enum': 'SortOrder',
    },
    total=True
)

_User_boolean_OrderByInput = TypedDict(
    '_User_boolean_OrderByInput',
    {
        'boolean': 'SortOrder',
    },
    total=True
)

_User_optional_boolean_OrderByInput = TypedDict(
    '_User_optional_boolean_OrderByInput',
    {
        'optional_boolean': 'SortOrder',
    },
    total=True
)

_User_RelevanceInner = TypedDict(
    '_User_RelevanceInner',
    {
        'fields': 'List[UserScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_User_RelevanceOrderByInput = TypedDict(
    '_User_RelevanceOrderByInput',
    {
        '_relevance': '_User_RelevanceInner',
    },
    total=True
)

UserOrderByInput = Union[
    '_User_id_OrderByInput',
    '_User_email_OrderByInput',
    '_User_int_OrderByInput',
    '_User_optional_int_OrderByInput',
    '_User_float_OrderByInput',
    '_User_optional_float_OrderByInput',
    '_User_string_OrderByInput',
    '_User_optional_string_OrderByInput',
    '_User_enum_OrderByInput',
    '_User_optional_enum_OrderByInput',
    '_User_boolean_OrderByInput',
    '_User_optional_boolean_OrderByInput',
    '_User_RelevanceOrderByInput',
]



# recursive User types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

UserRelationFilter = TypedDict(
    'UserRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class UserListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class UserInclude(TypedDict, total=False):
    """User relational arguments"""
    posts: Union[bool, 'FindManyPostArgsFromUser']


    

class PostIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    author: Union[bool, 'UserArgsFromUserRecursive1']


class PostIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    author: Union[bool, 'UserArgsFromUserRecursive2']


class PostIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""

    

class PostArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'PostIncludeFromPostRecursive1'


class PostArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'PostIncludeFromPostRecursive2'


class PostArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyPostArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPostRecursive1'


class FindManyPostArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPostRecursive2'


class FindManyPostArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    
    

class UserIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    posts: Union[bool, 'FindManyPostArgsFromUserRecursive1']


class UserIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    posts: Union[bool, 'FindManyPostArgsFromUserRecursive2']


class UserIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""

    

class UserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyUserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class MIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    n: Union[bool, 'FindManyNArgsFromUserRecursive1']


class MIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    n: Union[bool, 'FindManyNArgsFromUserRecursive2']


class MIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""

    

class MArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'MIncludeFromMRecursive1'


class MArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'MIncludeFromMRecursive2'


class MArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyMArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromMRecursive1'


class FindManyMArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromMRecursive2'


class FindManyMArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    
    

class NIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    m: Union[bool, 'FindManyMArgsFromUserRecursive1']


class NIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    m: Union[bool, 'FindManyMArgsFromUserRecursive2']


class NIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""

    

class NArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'NIncludeFromNRecursive1'


class NArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'NIncludeFromNRecursive2'


class NArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyNArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromNRecursive1'


class FindManyNArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromNRecursive2'


class FindManyNArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    
    

class OneOptionalIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    many: Union[bool, 'FindManyManyRequiredArgsFromUserRecursive1']


class OneOptionalIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    many: Union[bool, 'FindManyManyRequiredArgsFromUserRecursive2']


class OneOptionalIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""

    

class OneOptionalArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'OneOptionalIncludeFromOneOptionalRecursive1'


class OneOptionalArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'OneOptionalIncludeFromOneOptionalRecursive2'


class OneOptionalArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyOneOptionalArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromOneOptionalRecursive1'


class FindManyOneOptionalArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromOneOptionalRecursive2'


class FindManyOneOptionalArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    
    

class ManyRequiredIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    one: Union[bool, 'OneOptionalArgsFromUserRecursive1']


class ManyRequiredIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    one: Union[bool, 'OneOptionalArgsFromUserRecursive2']


class ManyRequiredIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""

    

class ManyRequiredArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'ManyRequiredIncludeFromManyRequiredRecursive1'


class ManyRequiredArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'ManyRequiredIncludeFromManyRequiredRecursive2'


class ManyRequiredArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyManyRequiredArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromManyRequiredRecursive1'


class FindManyManyRequiredArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromManyRequiredRecursive2'


class FindManyManyRequiredArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    
    

class ListsIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""


class ListsIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""


class ListsIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""

    

class ListsArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'ListsIncludeFromListsRecursive1'


class ListsArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'ListsIncludeFromListsRecursive2'


class ListsArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyListsArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromListsRecursive1'


class FindManyListsArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromListsRecursive2'


class FindManyListsArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    
    

class AIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""


class AIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""


class AIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""

    

class AArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'AIncludeFromARecursive1'


class AArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'AIncludeFromARecursive2'


class AArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyAArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromARecursive1'


class FindManyAArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromARecursive2'


class FindManyAArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    
    

class BIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""


class BIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""


class BIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""

    

class BArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'BIncludeFromBRecursive1'


class BArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'BIncludeFromBRecursive2'


class BArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyBArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromBRecursive1'


class FindManyBArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromBRecursive2'


class FindManyBArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    
    

class CIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""


class CIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""


class CIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""

    

class CArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'CIncludeFromCRecursive1'


class CArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'CIncludeFromCRecursive2'


class CArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyCArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromCRecursive1'


class FindManyCArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromCRecursive2'


class FindManyCArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    
    

class DIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""


class DIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""


class DIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""

    

class DArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'DIncludeFromDRecursive1'


class DArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'DIncludeFromDRecursive2'


class DArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyDArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromDRecursive1'


class FindManyDArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromDRecursive2'


class FindManyDArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    
    

class EIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""


class EIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""


class EIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""

    

class EArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'EIncludeFromERecursive1'


class EArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'EIncludeFromERecursive2'


class EArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyEArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromERecursive1'


class FindManyEArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromERecursive2'


class FindManyEArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    


FindManyUserArgs = FindManyUserArgsFromUser
FindFirstUserArgs = FindManyUserArgsFromUser


    

class UserWhereInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    email: Union[_str, 'types.StringFilter']
    int: Union[_int, 'types.IntFilter']
    optional_int: Union[None, _int, 'types.IntFilter']
    float: Union[_float, 'types.FloatFilter']
    optional_float: Union[None, _float, 'types.FloatFilter']
    string: Union[_str, 'types.StringFilter']
    optional_string: Union[None, _str, 'types.StringFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanFilter']
    optional_boolean: Union[None, _bool, 'types.BooleanFilter']
    posts: 'PostListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive1', List['UserWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive1']
    OR: List['UserWhereInputRecursive1']
    NOT: List['UserWhereInputRecursive1']


class UserWhereInputRecursive1(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    email: Union[_str, 'types.StringFilter']
    int: Union[_int, 'types.IntFilter']
    optional_int: Union[None, _int, 'types.IntFilter']
    float: Union[_float, 'types.FloatFilter']
    optional_float: Union[None, _float, 'types.FloatFilter']
    string: Union[_str, 'types.StringFilter']
    optional_string: Union[None, _str, 'types.StringFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanFilter']
    optional_boolean: Union[None, _bool, 'types.BooleanFilter']
    posts: 'PostListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive2', List['UserWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive2']
    OR: List['UserWhereInputRecursive2']
    NOT: List['UserWhereInputRecursive2']


class UserWhereInputRecursive2(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    email: Union[_str, 'types.StringFilter']
    int: Union[_int, 'types.IntFilter']
    optional_int: Union[None, _int, 'types.IntFilter']
    float: Union[_float, 'types.FloatFilter']
    optional_float: Union[None, _float, 'types.FloatFilter']
    string: Union[_str, 'types.StringFilter']
    optional_string: Union[None, _str, 'types.StringFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanFilter']
    optional_boolean: Union[None, _bool, 'types.BooleanFilter']
    posts: 'PostListRelationFilter'



# aggregate User types


    

class UserScalarWhereWithAggregatesInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    optional_int: Union[_int, 'types.IntWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    optional_float: Union[_float, 'types.FloatWithAggregatesFilter']
    string: Union[_str, 'types.StringWithAggregatesFilter']
    optional_string: Union[_str, 'types.StringWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']
    optional_boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive1']
    OR: List['UserScalarWhereWithAggregatesInputRecursive1']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive1']


class UserScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    optional_int: Union[_int, 'types.IntWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    optional_float: Union[_float, 'types.FloatWithAggregatesFilter']
    string: Union[_str, 'types.StringWithAggregatesFilter']
    optional_string: Union[_str, 'types.StringWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']
    optional_boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive2']
    OR: List['UserScalarWhereWithAggregatesInputRecursive2']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive2']


class UserScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    optional_int: Union[_int, 'types.IntWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    optional_float: Union[_float, 'types.FloatWithAggregatesFilter']
    string: Union[_str, 'types.StringWithAggregatesFilter']
    optional_string: Union[_str, 'types.StringWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']
    optional_boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']



class UserGroupByOutput(TypedDict, total=False):
    id: _int
    email: _str
    int: _int
    optional_int: _int
    float: _float
    optional_float: _float
    string: _str
    optional_string: _str
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: _bool
    optional_boolean: _bool
    _sum: 'UserSumAggregateOutput'
    _avg: 'UserAvgAggregateOutput'
    _min: 'UserMinAggregateOutput'
    _max: 'UserMaxAggregateOutput'
    _count: 'UserCountAggregateOutput'


class UserAvgAggregateOutput(TypedDict, total=False):
    """User output for aggregating averages"""
    id: float
    int: float
    optional_int: float
    float: float
    optional_float: float


class UserSumAggregateOutput(TypedDict, total=False):
    """User output for aggregating sums"""
    id: _int
    int: _int
    optional_int: _int
    float: _float
    optional_float: _float


class UserScalarAggregateOutput(TypedDict, total=False):
    """User output including scalar fields"""
    id: _int
    email: _str
    int: _int
    optional_int: _int
    float: _float
    optional_float: _float
    string: _str
    optional_string: _str
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: _bool
    optional_boolean: _bool


UserMinAggregateOutput = UserScalarAggregateOutput
UserMaxAggregateOutput = UserScalarAggregateOutput


class UserMaxAggregateInput(TypedDict, total=False):
    """User input for aggregating by max"""
    id: bool
    email: bool
    int: bool
    optional_int: bool
    float: bool
    optional_float: bool
    string: bool
    optional_string: bool
    enum: bool
    optional_enum: bool
    boolean: bool
    optional_boolean: bool


class UserMinAggregateInput(TypedDict, total=False):
    """User input for aggregating by min"""
    id: bool
    email: bool
    int: bool
    optional_int: bool
    float: bool
    optional_float: bool
    string: bool
    optional_string: bool
    enum: bool
    optional_enum: bool
    boolean: bool
    optional_boolean: bool


class UserNumberAggregateInput(TypedDict, total=False):
    """User input for aggregating numbers"""
    id: bool
    int: bool
    optional_int: bool
    float: bool
    optional_float: bool


UserAvgAggregateInput = UserNumberAggregateInput
UserSumAggregateInput = UserNumberAggregateInput


UserCountAggregateInput = TypedDict(
    'UserCountAggregateInput',
    {
        'id': bool,
        'email': bool,
        'int': bool,
        'optional_int': bool,
        'float': bool,
        'optional_float': bool,
        'string': bool,
        'optional_string': bool,
        'enum': bool,
        'optional_enum': bool,
        'boolean': bool,
        'optional_boolean': bool,
        '_all': bool,
    },
    total=False,
)

UserCountAggregateOutput = TypedDict(
    'UserCountAggregateOutput',
    {
        'id': int,
        'email': int,
        'int': int,
        'optional_int': int,
        'float': int,
        'optional_float': int,
        'string': int,
        'optional_string': int,
        'enum': int,
        'optional_enum': int,
        'boolean': int,
        'optional_boolean': int,
        '_all': int,
    },
    total=False,
)


UserKeys = Literal[
    'id',
    'email',
    'int',
    'optional_int',
    'float',
    'optional_float',
    'string',
    'optional_string',
    'enum',
    'optional_enum',
    'boolean',
    'optional_boolean',
    'posts',
]
UserScalarFieldKeys = Literal[
    'id',
    'email',
    'int',
    'optional_int',
    'float',
    'optional_float',
    'string',
    'optional_string',
    'enum',
    'optional_enum',
    'boolean',
    'optional_boolean',
]
UserScalarFieldKeysT = TypeVar('UserScalarFieldKeysT', bound=UserScalarFieldKeys)

UserRelationalFieldKeys = Literal[
        'posts',
    ]

# M types

class MOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the M create method"""
    id: _int
    n: 'NCreateManyNestedWithoutRelationsInput'
    optional_int: Optional[_int]
    optional_float: Optional[_float]
    optional_string: Optional[_str]
    optional_enum: Optional['enums.ABeautifulEnum']
    optional_boolean: Optional[_bool]


class MCreateInput(MOptionalCreateInput):
    """Required arguments to the M create method"""
    int: _int
    float: _float
    string: _str
    enum: 'enums.ABeautifulEnum'
    boolean: _bool


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class MOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the M create method, without relations"""
    id: _int
    optional_int: Optional[_int]
    optional_float: Optional[_float]
    optional_string: Optional[_str]
    optional_enum: Optional['enums.ABeautifulEnum']
    optional_boolean: Optional[_bool]


class MCreateWithoutRelationsInput(MOptionalCreateWithoutRelationsInput):
    """Required arguments to the M create method, without relations"""
    int: _int
    float: _float
    string: _str
    enum: 'enums.ABeautifulEnum'
    boolean: _bool

class MConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'MCreateWithoutRelationsInput'
    where: 'MWhereUniqueInput'

class MCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'MCreateWithoutRelationsInput'
    connect: 'MWhereUniqueInput'
    connect_or_create: 'MConnectOrCreateWithoutRelationsInput'


class MCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['MCreateWithoutRelationsInput', List['MCreateWithoutRelationsInput']]
    connect: Union['MWhereUniqueInput', List['MWhereUniqueInput']]
    connect_or_create: Union['MConnectOrCreateWithoutRelationsInput', List['MConnectOrCreateWithoutRelationsInput']]

_MWhereUnique_id_Input = TypedDict(
    '_MWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

MWhereUniqueInput = _MWhereUnique_id_Input


class MUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    n: 'NUpdateManyWithoutRelationsInput'
    int: Union[AtomicIntInput, _int]
    optional_int: Optional[Union[AtomicIntInput, _int]]
    float: Union[AtomicFloatInput, _float]
    optional_float: Optional[Union[AtomicFloatInput, _float]]
    string: _str
    optional_string: Optional[_str]
    enum: 'enums.ABeautifulEnum'
    optional_enum: Optional['enums.ABeautifulEnum']
    boolean: _bool
    optional_boolean: Optional[_bool]


class MUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    int: Union[AtomicIntInput, _int]
    optional_int: Optional[Union[AtomicIntInput, _int]]
    float: Union[AtomicFloatInput, _float]
    optional_float: Optional[Union[AtomicFloatInput, _float]]
    string: _str
    optional_string: Optional[_str]
    enum: 'enums.ABeautifulEnum'
    optional_enum: Optional['enums.ABeautifulEnum']
    boolean: _bool
    optional_boolean: Optional[_bool]


class MUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['MCreateWithoutRelationsInput']
    connect: List['MWhereUniqueInput']
    connect_or_create: List['MConnectOrCreateWithoutRelationsInput']
    set: List['MWhereUniqueInput']
    disconnect: List['MWhereUniqueInput']
    delete: List['MWhereUniqueInput']

    # TODO
    # update: List['MUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['MUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['MScalarWhereInput']
    # upsert: List['MUpserteWithWhereUniqueWithoutRelationsInput']


class MUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'MCreateWithoutRelationsInput'
    connect: 'MWhereUniqueInput'
    connect_or_create: 'MConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'MUpdateInput'
    # upsert: 'MUpsertWithoutRelationsInput'


class MUpsertInput(TypedDict):
    create: 'MCreateInput'
    update: 'MUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_M_id_OrderByInput = TypedDict(
    '_M_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_M_int_OrderByInput = TypedDict(
    '_M_int_OrderByInput',
    {
        'int': 'SortOrder',
    },
    total=True
)

_M_optional_int_OrderByInput = TypedDict(
    '_M_optional_int_OrderByInput',
    {
        'optional_int': 'SortOrder',
    },
    total=True
)

_M_float_OrderByInput = TypedDict(
    '_M_float_OrderByInput',
    {
        'float': 'SortOrder',
    },
    total=True
)

_M_optional_float_OrderByInput = TypedDict(
    '_M_optional_float_OrderByInput',
    {
        'optional_float': 'SortOrder',
    },
    total=True
)

_M_string_OrderByInput = TypedDict(
    '_M_string_OrderByInput',
    {
        'string': 'SortOrder',
    },
    total=True
)

_M_optional_string_OrderByInput = TypedDict(
    '_M_optional_string_OrderByInput',
    {
        'optional_string': 'SortOrder',
    },
    total=True
)

_M_enum_OrderByInput = TypedDict(
    '_M_enum_OrderByInput',
    {
        'enum': 'SortOrder',
    },
    total=True
)

_M_optional_enum_OrderByInput = TypedDict(
    '_M_optional_enum_OrderByInput',
    {
        'optional_enum': 'SortOrder',
    },
    total=True
)

_M_boolean_OrderByInput = TypedDict(
    '_M_boolean_OrderByInput',
    {
        'boolean': 'SortOrder',
    },
    total=True
)

_M_optional_boolean_OrderByInput = TypedDict(
    '_M_optional_boolean_OrderByInput',
    {
        'optional_boolean': 'SortOrder',
    },
    total=True
)

_M_RelevanceInner = TypedDict(
    '_M_RelevanceInner',
    {
        'fields': 'List[MScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_M_RelevanceOrderByInput = TypedDict(
    '_M_RelevanceOrderByInput',
    {
        '_relevance': '_M_RelevanceInner',
    },
    total=True
)

MOrderByInput = Union[
    '_M_id_OrderByInput',
    '_M_int_OrderByInput',
    '_M_optional_int_OrderByInput',
    '_M_float_OrderByInput',
    '_M_optional_float_OrderByInput',
    '_M_string_OrderByInput',
    '_M_optional_string_OrderByInput',
    '_M_enum_OrderByInput',
    '_M_optional_enum_OrderByInput',
    '_M_boolean_OrderByInput',
    '_M_optional_boolean_OrderByInput',
    '_M_RelevanceOrderByInput',
]



# recursive M types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

MRelationFilter = TypedDict(
    'MRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class MListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class MInclude(TypedDict, total=False):
    """M relational arguments"""
    n: Union[bool, 'FindManyNArgsFromM']


    

class PostIncludeFromM(TypedDict, total=False):
    """Relational arguments for M"""
    author: Union[bool, 'UserArgsFromMRecursive1']


class PostIncludeFromMRecursive1(TypedDict, total=False):
    """Relational arguments for M"""
    author: Union[bool, 'UserArgsFromMRecursive2']


class PostIncludeFromMRecursive2(TypedDict, total=False):
    """Relational arguments for M"""

    

class PostArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    include: 'PostIncludeFromPostRecursive1'


class PostArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    include: 'PostIncludeFromPostRecursive2'


class PostArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    
    

class FindManyPostArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPostRecursive1'


class FindManyPostArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPostRecursive2'


class FindManyPostArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    
    

class UserIncludeFromM(TypedDict, total=False):
    """Relational arguments for M"""
    posts: Union[bool, 'FindManyPostArgsFromMRecursive1']


class UserIncludeFromMRecursive1(TypedDict, total=False):
    """Relational arguments for M"""
    posts: Union[bool, 'FindManyPostArgsFromMRecursive2']


class UserIncludeFromMRecursive2(TypedDict, total=False):
    """Relational arguments for M"""

    

class UserArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    
    

class FindManyUserArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class MIncludeFromM(TypedDict, total=False):
    """Relational arguments for M"""
    n: Union[bool, 'FindManyNArgsFromMRecursive1']


class MIncludeFromMRecursive1(TypedDict, total=False):
    """Relational arguments for M"""
    n: Union[bool, 'FindManyNArgsFromMRecursive2']


class MIncludeFromMRecursive2(TypedDict, total=False):
    """Relational arguments for M"""

    

class MArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    include: 'MIncludeFromMRecursive1'


class MArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    include: 'MIncludeFromMRecursive2'


class MArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    
    

class FindManyMArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromMRecursive1'


class FindManyMArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromMRecursive2'


class FindManyMArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    
    

class NIncludeFromM(TypedDict, total=False):
    """Relational arguments for M"""
    m: Union[bool, 'FindManyMArgsFromMRecursive1']


class NIncludeFromMRecursive1(TypedDict, total=False):
    """Relational arguments for M"""
    m: Union[bool, 'FindManyMArgsFromMRecursive2']


class NIncludeFromMRecursive2(TypedDict, total=False):
    """Relational arguments for M"""

    

class NArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    include: 'NIncludeFromNRecursive1'


class NArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    include: 'NIncludeFromNRecursive2'


class NArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    
    

class FindManyNArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromNRecursive1'


class FindManyNArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromNRecursive2'


class FindManyNArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    
    

class OneOptionalIncludeFromM(TypedDict, total=False):
    """Relational arguments for M"""
    many: Union[bool, 'FindManyManyRequiredArgsFromMRecursive1']


class OneOptionalIncludeFromMRecursive1(TypedDict, total=False):
    """Relational arguments for M"""
    many: Union[bool, 'FindManyManyRequiredArgsFromMRecursive2']


class OneOptionalIncludeFromMRecursive2(TypedDict, total=False):
    """Relational arguments for M"""

    

class OneOptionalArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    include: 'OneOptionalIncludeFromOneOptionalRecursive1'


class OneOptionalArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    include: 'OneOptionalIncludeFromOneOptionalRecursive2'


class OneOptionalArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    
    

class FindManyOneOptionalArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromOneOptionalRecursive1'


class FindManyOneOptionalArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromOneOptionalRecursive2'


class FindManyOneOptionalArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    
    

class ManyRequiredIncludeFromM(TypedDict, total=False):
    """Relational arguments for M"""
    one: Union[bool, 'OneOptionalArgsFromMRecursive1']


class ManyRequiredIncludeFromMRecursive1(TypedDict, total=False):
    """Relational arguments for M"""
    one: Union[bool, 'OneOptionalArgsFromMRecursive2']


class ManyRequiredIncludeFromMRecursive2(TypedDict, total=False):
    """Relational arguments for M"""

    

class ManyRequiredArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    include: 'ManyRequiredIncludeFromManyRequiredRecursive1'


class ManyRequiredArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    include: 'ManyRequiredIncludeFromManyRequiredRecursive2'


class ManyRequiredArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    
    

class FindManyManyRequiredArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromManyRequiredRecursive1'


class FindManyManyRequiredArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromManyRequiredRecursive2'


class FindManyManyRequiredArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    
    

class ListsIncludeFromM(TypedDict, total=False):
    """Relational arguments for M"""


class ListsIncludeFromMRecursive1(TypedDict, total=False):
    """Relational arguments for M"""


class ListsIncludeFromMRecursive2(TypedDict, total=False):
    """Relational arguments for M"""

    

class ListsArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    include: 'ListsIncludeFromListsRecursive1'


class ListsArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    include: 'ListsIncludeFromListsRecursive2'


class ListsArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    
    

class FindManyListsArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromListsRecursive1'


class FindManyListsArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromListsRecursive2'


class FindManyListsArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    
    

class AIncludeFromM(TypedDict, total=False):
    """Relational arguments for M"""


class AIncludeFromMRecursive1(TypedDict, total=False):
    """Relational arguments for M"""


class AIncludeFromMRecursive2(TypedDict, total=False):
    """Relational arguments for M"""

    

class AArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    include: 'AIncludeFromARecursive1'


class AArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    include: 'AIncludeFromARecursive2'


class AArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    
    

class FindManyAArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromARecursive1'


class FindManyAArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromARecursive2'


class FindManyAArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    
    

class BIncludeFromM(TypedDict, total=False):
    """Relational arguments for M"""


class BIncludeFromMRecursive1(TypedDict, total=False):
    """Relational arguments for M"""


class BIncludeFromMRecursive2(TypedDict, total=False):
    """Relational arguments for M"""

    

class BArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    include: 'BIncludeFromBRecursive1'


class BArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    include: 'BIncludeFromBRecursive2'


class BArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    
    

class FindManyBArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromBRecursive1'


class FindManyBArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromBRecursive2'


class FindManyBArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    
    

class CIncludeFromM(TypedDict, total=False):
    """Relational arguments for M"""


class CIncludeFromMRecursive1(TypedDict, total=False):
    """Relational arguments for M"""


class CIncludeFromMRecursive2(TypedDict, total=False):
    """Relational arguments for M"""

    

class CArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    include: 'CIncludeFromCRecursive1'


class CArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    include: 'CIncludeFromCRecursive2'


class CArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    
    

class FindManyCArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromCRecursive1'


class FindManyCArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromCRecursive2'


class FindManyCArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    
    

class DIncludeFromM(TypedDict, total=False):
    """Relational arguments for M"""


class DIncludeFromMRecursive1(TypedDict, total=False):
    """Relational arguments for M"""


class DIncludeFromMRecursive2(TypedDict, total=False):
    """Relational arguments for M"""

    

class DArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    include: 'DIncludeFromDRecursive1'


class DArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    include: 'DIncludeFromDRecursive2'


class DArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    
    

class FindManyDArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromDRecursive1'


class FindManyDArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromDRecursive2'


class FindManyDArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    
    

class EIncludeFromM(TypedDict, total=False):
    """Relational arguments for M"""


class EIncludeFromMRecursive1(TypedDict, total=False):
    """Relational arguments for M"""


class EIncludeFromMRecursive2(TypedDict, total=False):
    """Relational arguments for M"""

    

class EArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    include: 'EIncludeFromERecursive1'


class EArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    include: 'EIncludeFromERecursive2'


class EArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    
    

class FindManyEArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromERecursive1'


class FindManyEArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromERecursive2'


class FindManyEArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    


FindManyMArgs = FindManyMArgsFromM
FindFirstMArgs = FindManyMArgsFromM


    

class MWhereInput(TypedDict, total=False):
    """M arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    n: 'NListRelationFilter'
    int: Union[_int, 'types.IntFilter']
    optional_int: Union[None, _int, 'types.IntFilter']
    float: Union[_float, 'types.FloatFilter']
    optional_float: Union[None, _float, 'types.FloatFilter']
    string: Union[_str, 'types.StringFilter']
    optional_string: Union[None, _str, 'types.StringFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanFilter']
    optional_boolean: Union[None, _bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['MWhereInputRecursive1', List['MWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['MWhereInputRecursive1']
    OR: List['MWhereInputRecursive1']
    NOT: List['MWhereInputRecursive1']


class MWhereInputRecursive1(TypedDict, total=False):
    """M arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    n: 'NListRelationFilter'
    int: Union[_int, 'types.IntFilter']
    optional_int: Union[None, _int, 'types.IntFilter']
    float: Union[_float, 'types.FloatFilter']
    optional_float: Union[None, _float, 'types.FloatFilter']
    string: Union[_str, 'types.StringFilter']
    optional_string: Union[None, _str, 'types.StringFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanFilter']
    optional_boolean: Union[None, _bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['MWhereInputRecursive2', List['MWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['MWhereInputRecursive2']
    OR: List['MWhereInputRecursive2']
    NOT: List['MWhereInputRecursive2']


class MWhereInputRecursive2(TypedDict, total=False):
    """M arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    n: 'NListRelationFilter'
    int: Union[_int, 'types.IntFilter']
    optional_int: Union[None, _int, 'types.IntFilter']
    float: Union[_float, 'types.FloatFilter']
    optional_float: Union[None, _float, 'types.FloatFilter']
    string: Union[_str, 'types.StringFilter']
    optional_string: Union[None, _str, 'types.StringFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanFilter']
    optional_boolean: Union[None, _bool, 'types.BooleanFilter']



# aggregate M types


    

class MScalarWhereWithAggregatesInput(TypedDict, total=False):
    """M arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    optional_int: Union[_int, 'types.IntWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    optional_float: Union[_float, 'types.FloatWithAggregatesFilter']
    string: Union[_str, 'types.StringWithAggregatesFilter']
    optional_string: Union[_str, 'types.StringWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']
    optional_boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['MScalarWhereWithAggregatesInputRecursive1']
    OR: List['MScalarWhereWithAggregatesInputRecursive1']
    NOT: List['MScalarWhereWithAggregatesInputRecursive1']


class MScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """M arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    optional_int: Union[_int, 'types.IntWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    optional_float: Union[_float, 'types.FloatWithAggregatesFilter']
    string: Union[_str, 'types.StringWithAggregatesFilter']
    optional_string: Union[_str, 'types.StringWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']
    optional_boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['MScalarWhereWithAggregatesInputRecursive2']
    OR: List['MScalarWhereWithAggregatesInputRecursive2']
    NOT: List['MScalarWhereWithAggregatesInputRecursive2']


class MScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """M arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    optional_int: Union[_int, 'types.IntWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    optional_float: Union[_float, 'types.FloatWithAggregatesFilter']
    string: Union[_str, 'types.StringWithAggregatesFilter']
    optional_string: Union[_str, 'types.StringWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']
    optional_boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']



class MGroupByOutput(TypedDict, total=False):
    id: _int
    int: _int
    optional_int: _int
    float: _float
    optional_float: _float
    string: _str
    optional_string: _str
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: _bool
    optional_boolean: _bool
    _sum: 'MSumAggregateOutput'
    _avg: 'MAvgAggregateOutput'
    _min: 'MMinAggregateOutput'
    _max: 'MMaxAggregateOutput'
    _count: 'MCountAggregateOutput'


class MAvgAggregateOutput(TypedDict, total=False):
    """M output for aggregating averages"""
    id: float
    int: float
    optional_int: float
    float: float
    optional_float: float


class MSumAggregateOutput(TypedDict, total=False):
    """M output for aggregating sums"""
    id: _int
    int: _int
    optional_int: _int
    float: _float
    optional_float: _float


class MScalarAggregateOutput(TypedDict, total=False):
    """M output including scalar fields"""
    id: _int
    int: _int
    optional_int: _int
    float: _float
    optional_float: _float
    string: _str
    optional_string: _str
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: _bool
    optional_boolean: _bool


MMinAggregateOutput = MScalarAggregateOutput
MMaxAggregateOutput = MScalarAggregateOutput


class MMaxAggregateInput(TypedDict, total=False):
    """M input for aggregating by max"""
    id: bool
    int: bool
    optional_int: bool
    float: bool
    optional_float: bool
    string: bool
    optional_string: bool
    enum: bool
    optional_enum: bool
    boolean: bool
    optional_boolean: bool


class MMinAggregateInput(TypedDict, total=False):
    """M input for aggregating by min"""
    id: bool
    int: bool
    optional_int: bool
    float: bool
    optional_float: bool
    string: bool
    optional_string: bool
    enum: bool
    optional_enum: bool
    boolean: bool
    optional_boolean: bool


class MNumberAggregateInput(TypedDict, total=False):
    """M input for aggregating numbers"""
    id: bool
    int: bool
    optional_int: bool
    float: bool
    optional_float: bool


MAvgAggregateInput = MNumberAggregateInput
MSumAggregateInput = MNumberAggregateInput


MCountAggregateInput = TypedDict(
    'MCountAggregateInput',
    {
        'id': bool,
        'int': bool,
        'optional_int': bool,
        'float': bool,
        'optional_float': bool,
        'string': bool,
        'optional_string': bool,
        'enum': bool,
        'optional_enum': bool,
        'boolean': bool,
        'optional_boolean': bool,
        '_all': bool,
    },
    total=False,
)

MCountAggregateOutput = TypedDict(
    'MCountAggregateOutput',
    {
        'id': int,
        'int': int,
        'optional_int': int,
        'float': int,
        'optional_float': int,
        'string': int,
        'optional_string': int,
        'enum': int,
        'optional_enum': int,
        'boolean': int,
        'optional_boolean': int,
        '_all': int,
    },
    total=False,
)


MKeys = Literal[
    'id',
    'n',
    'int',
    'optional_int',
    'float',
    'optional_float',
    'string',
    'optional_string',
    'enum',
    'optional_enum',
    'boolean',
    'optional_boolean',
]
MScalarFieldKeys = Literal[
    'id',
    'int',
    'optional_int',
    'float',
    'optional_float',
    'string',
    'optional_string',
    'enum',
    'optional_enum',
    'boolean',
    'optional_boolean',
]
MScalarFieldKeysT = TypeVar('MScalarFieldKeysT', bound=MScalarFieldKeys)

MRelationalFieldKeys = Literal[
        'n',
    ]

# N types

class NOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the N create method"""
    id: _int
    m: 'MCreateManyNestedWithoutRelationsInput'
    optional_int: Optional[_int]
    optional_float: Optional[_float]
    optional_string: Optional[_str]
    optional_json: Optional['fields.Json']
    optional_enum: Optional['enums.ABeautifulEnum']
    optional_boolean: Optional[_bool]


class NCreateInput(NOptionalCreateInput):
    """Required arguments to the N create method"""
    int: _int
    float: _float
    string: _str
    json_: 'fields.Json'
    enum: 'enums.ABeautifulEnum'
    boolean: _bool


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class NOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the N create method, without relations"""
    id: _int
    optional_int: Optional[_int]
    optional_float: Optional[_float]
    optional_string: Optional[_str]
    optional_json: Optional['fields.Json']
    optional_enum: Optional['enums.ABeautifulEnum']
    optional_boolean: Optional[_bool]


class NCreateWithoutRelationsInput(NOptionalCreateWithoutRelationsInput):
    """Required arguments to the N create method, without relations"""
    int: _int
    float: _float
    string: _str
    json_: 'fields.Json'
    enum: 'enums.ABeautifulEnum'
    boolean: _bool

class NConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'NCreateWithoutRelationsInput'
    where: 'NWhereUniqueInput'

class NCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'NCreateWithoutRelationsInput'
    connect: 'NWhereUniqueInput'
    connect_or_create: 'NConnectOrCreateWithoutRelationsInput'


class NCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['NCreateWithoutRelationsInput', List['NCreateWithoutRelationsInput']]
    connect: Union['NWhereUniqueInput', List['NWhereUniqueInput']]
    connect_or_create: Union['NConnectOrCreateWithoutRelationsInput', List['NConnectOrCreateWithoutRelationsInput']]

_NWhereUnique_id_Input = TypedDict(
    '_NWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

NWhereUniqueInput = _NWhereUnique_id_Input


class NUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    m: 'MUpdateManyWithoutRelationsInput'
    int: Union[AtomicIntInput, _int]
    optional_int: Optional[Union[AtomicIntInput, _int]]
    float: Union[AtomicFloatInput, _float]
    optional_float: Optional[Union[AtomicFloatInput, _float]]
    string: _str
    optional_string: Optional[_str]
    json_: 'fields.Json'
    optional_json: Optional['fields.Json']
    enum: 'enums.ABeautifulEnum'
    optional_enum: Optional['enums.ABeautifulEnum']
    boolean: _bool
    optional_boolean: Optional[_bool]


class NUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    int: Union[AtomicIntInput, _int]
    optional_int: Optional[Union[AtomicIntInput, _int]]
    float: Union[AtomicFloatInput, _float]
    optional_float: Optional[Union[AtomicFloatInput, _float]]
    string: _str
    optional_string: Optional[_str]
    json_: 'fields.Json'
    optional_json: Optional['fields.Json']
    enum: 'enums.ABeautifulEnum'
    optional_enum: Optional['enums.ABeautifulEnum']
    boolean: _bool
    optional_boolean: Optional[_bool]


class NUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['NCreateWithoutRelationsInput']
    connect: List['NWhereUniqueInput']
    connect_or_create: List['NConnectOrCreateWithoutRelationsInput']
    set: List['NWhereUniqueInput']
    disconnect: List['NWhereUniqueInput']
    delete: List['NWhereUniqueInput']

    # TODO
    # update: List['NUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['NUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['NScalarWhereInput']
    # upsert: List['NUpserteWithWhereUniqueWithoutRelationsInput']


class NUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'NCreateWithoutRelationsInput'
    connect: 'NWhereUniqueInput'
    connect_or_create: 'NConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'NUpdateInput'
    # upsert: 'NUpsertWithoutRelationsInput'


class NUpsertInput(TypedDict):
    create: 'NCreateInput'
    update: 'NUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_N_id_OrderByInput = TypedDict(
    '_N_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_N_int_OrderByInput = TypedDict(
    '_N_int_OrderByInput',
    {
        'int': 'SortOrder',
    },
    total=True
)

_N_optional_int_OrderByInput = TypedDict(
    '_N_optional_int_OrderByInput',
    {
        'optional_int': 'SortOrder',
    },
    total=True
)

_N_float_OrderByInput = TypedDict(
    '_N_float_OrderByInput',
    {
        'float': 'SortOrder',
    },
    total=True
)

_N_optional_float_OrderByInput = TypedDict(
    '_N_optional_float_OrderByInput',
    {
        'optional_float': 'SortOrder',
    },
    total=True
)

_N_string_OrderByInput = TypedDict(
    '_N_string_OrderByInput',
    {
        'string': 'SortOrder',
    },
    total=True
)

_N_optional_string_OrderByInput = TypedDict(
    '_N_optional_string_OrderByInput',
    {
        'optional_string': 'SortOrder',
    },
    total=True
)

_N_json__OrderByInput = TypedDict(
    '_N_json__OrderByInput',
    {
        'json_': 'SortOrder',
    },
    total=True
)

_N_optional_json_OrderByInput = TypedDict(
    '_N_optional_json_OrderByInput',
    {
        'optional_json': 'SortOrder',
    },
    total=True
)

_N_enum_OrderByInput = TypedDict(
    '_N_enum_OrderByInput',
    {
        'enum': 'SortOrder',
    },
    total=True
)

_N_optional_enum_OrderByInput = TypedDict(
    '_N_optional_enum_OrderByInput',
    {
        'optional_enum': 'SortOrder',
    },
    total=True
)

_N_boolean_OrderByInput = TypedDict(
    '_N_boolean_OrderByInput',
    {
        'boolean': 'SortOrder',
    },
    total=True
)

_N_optional_boolean_OrderByInput = TypedDict(
    '_N_optional_boolean_OrderByInput',
    {
        'optional_boolean': 'SortOrder',
    },
    total=True
)

_N_RelevanceInner = TypedDict(
    '_N_RelevanceInner',
    {
        'fields': 'List[NScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_N_RelevanceOrderByInput = TypedDict(
    '_N_RelevanceOrderByInput',
    {
        '_relevance': '_N_RelevanceInner',
    },
    total=True
)

NOrderByInput = Union[
    '_N_id_OrderByInput',
    '_N_int_OrderByInput',
    '_N_optional_int_OrderByInput',
    '_N_float_OrderByInput',
    '_N_optional_float_OrderByInput',
    '_N_string_OrderByInput',
    '_N_optional_string_OrderByInput',
    '_N_json__OrderByInput',
    '_N_optional_json_OrderByInput',
    '_N_enum_OrderByInput',
    '_N_optional_enum_OrderByInput',
    '_N_boolean_OrderByInput',
    '_N_optional_boolean_OrderByInput',
    '_N_RelevanceOrderByInput',
]



# recursive N types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

NRelationFilter = TypedDict(
    'NRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class NListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class NInclude(TypedDict, total=False):
    """N relational arguments"""
    m: Union[bool, 'FindManyMArgsFromN']


    

class PostIncludeFromN(TypedDict, total=False):
    """Relational arguments for N"""
    author: Union[bool, 'UserArgsFromNRecursive1']


class PostIncludeFromNRecursive1(TypedDict, total=False):
    """Relational arguments for N"""
    author: Union[bool, 'UserArgsFromNRecursive2']


class PostIncludeFromNRecursive2(TypedDict, total=False):
    """Relational arguments for N"""

    

class PostArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    include: 'PostIncludeFromPostRecursive1'


class PostArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    include: 'PostIncludeFromPostRecursive2'


class PostArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    
    

class FindManyPostArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPostRecursive1'


class FindManyPostArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPostRecursive2'


class FindManyPostArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    
    

class UserIncludeFromN(TypedDict, total=False):
    """Relational arguments for N"""
    posts: Union[bool, 'FindManyPostArgsFromNRecursive1']


class UserIncludeFromNRecursive1(TypedDict, total=False):
    """Relational arguments for N"""
    posts: Union[bool, 'FindManyPostArgsFromNRecursive2']


class UserIncludeFromNRecursive2(TypedDict, total=False):
    """Relational arguments for N"""

    

class UserArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    
    

class FindManyUserArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class MIncludeFromN(TypedDict, total=False):
    """Relational arguments for N"""
    n: Union[bool, 'FindManyNArgsFromNRecursive1']


class MIncludeFromNRecursive1(TypedDict, total=False):
    """Relational arguments for N"""
    n: Union[bool, 'FindManyNArgsFromNRecursive2']


class MIncludeFromNRecursive2(TypedDict, total=False):
    """Relational arguments for N"""

    

class MArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    include: 'MIncludeFromMRecursive1'


class MArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    include: 'MIncludeFromMRecursive2'


class MArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    
    

class FindManyMArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromMRecursive1'


class FindManyMArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromMRecursive2'


class FindManyMArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    
    

class NIncludeFromN(TypedDict, total=False):
    """Relational arguments for N"""
    m: Union[bool, 'FindManyMArgsFromNRecursive1']


class NIncludeFromNRecursive1(TypedDict, total=False):
    """Relational arguments for N"""
    m: Union[bool, 'FindManyMArgsFromNRecursive2']


class NIncludeFromNRecursive2(TypedDict, total=False):
    """Relational arguments for N"""

    

class NArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    include: 'NIncludeFromNRecursive1'


class NArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    include: 'NIncludeFromNRecursive2'


class NArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    
    

class FindManyNArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromNRecursive1'


class FindManyNArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromNRecursive2'


class FindManyNArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    
    

class OneOptionalIncludeFromN(TypedDict, total=False):
    """Relational arguments for N"""
    many: Union[bool, 'FindManyManyRequiredArgsFromNRecursive1']


class OneOptionalIncludeFromNRecursive1(TypedDict, total=False):
    """Relational arguments for N"""
    many: Union[bool, 'FindManyManyRequiredArgsFromNRecursive2']


class OneOptionalIncludeFromNRecursive2(TypedDict, total=False):
    """Relational arguments for N"""

    

class OneOptionalArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    include: 'OneOptionalIncludeFromOneOptionalRecursive1'


class OneOptionalArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    include: 'OneOptionalIncludeFromOneOptionalRecursive2'


class OneOptionalArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    
    

class FindManyOneOptionalArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromOneOptionalRecursive1'


class FindManyOneOptionalArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromOneOptionalRecursive2'


class FindManyOneOptionalArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    
    

class ManyRequiredIncludeFromN(TypedDict, total=False):
    """Relational arguments for N"""
    one: Union[bool, 'OneOptionalArgsFromNRecursive1']


class ManyRequiredIncludeFromNRecursive1(TypedDict, total=False):
    """Relational arguments for N"""
    one: Union[bool, 'OneOptionalArgsFromNRecursive2']


class ManyRequiredIncludeFromNRecursive2(TypedDict, total=False):
    """Relational arguments for N"""

    

class ManyRequiredArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    include: 'ManyRequiredIncludeFromManyRequiredRecursive1'


class ManyRequiredArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    include: 'ManyRequiredIncludeFromManyRequiredRecursive2'


class ManyRequiredArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    
    

class FindManyManyRequiredArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromManyRequiredRecursive1'


class FindManyManyRequiredArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromManyRequiredRecursive2'


class FindManyManyRequiredArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    
    

class ListsIncludeFromN(TypedDict, total=False):
    """Relational arguments for N"""


class ListsIncludeFromNRecursive1(TypedDict, total=False):
    """Relational arguments for N"""


class ListsIncludeFromNRecursive2(TypedDict, total=False):
    """Relational arguments for N"""

    

class ListsArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    include: 'ListsIncludeFromListsRecursive1'


class ListsArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    include: 'ListsIncludeFromListsRecursive2'


class ListsArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    
    

class FindManyListsArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromListsRecursive1'


class FindManyListsArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromListsRecursive2'


class FindManyListsArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    
    

class AIncludeFromN(TypedDict, total=False):
    """Relational arguments for N"""


class AIncludeFromNRecursive1(TypedDict, total=False):
    """Relational arguments for N"""


class AIncludeFromNRecursive2(TypedDict, total=False):
    """Relational arguments for N"""

    

class AArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    include: 'AIncludeFromARecursive1'


class AArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    include: 'AIncludeFromARecursive2'


class AArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    
    

class FindManyAArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromARecursive1'


class FindManyAArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromARecursive2'


class FindManyAArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    
    

class BIncludeFromN(TypedDict, total=False):
    """Relational arguments for N"""


class BIncludeFromNRecursive1(TypedDict, total=False):
    """Relational arguments for N"""


class BIncludeFromNRecursive2(TypedDict, total=False):
    """Relational arguments for N"""

    

class BArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    include: 'BIncludeFromBRecursive1'


class BArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    include: 'BIncludeFromBRecursive2'


class BArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    
    

class FindManyBArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromBRecursive1'


class FindManyBArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromBRecursive2'


class FindManyBArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    
    

class CIncludeFromN(TypedDict, total=False):
    """Relational arguments for N"""


class CIncludeFromNRecursive1(TypedDict, total=False):
    """Relational arguments for N"""


class CIncludeFromNRecursive2(TypedDict, total=False):
    """Relational arguments for N"""

    

class CArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    include: 'CIncludeFromCRecursive1'


class CArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    include: 'CIncludeFromCRecursive2'


class CArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    
    

class FindManyCArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromCRecursive1'


class FindManyCArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromCRecursive2'


class FindManyCArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    
    

class DIncludeFromN(TypedDict, total=False):
    """Relational arguments for N"""


class DIncludeFromNRecursive1(TypedDict, total=False):
    """Relational arguments for N"""


class DIncludeFromNRecursive2(TypedDict, total=False):
    """Relational arguments for N"""

    

class DArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    include: 'DIncludeFromDRecursive1'


class DArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    include: 'DIncludeFromDRecursive2'


class DArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    
    

class FindManyDArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromDRecursive1'


class FindManyDArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromDRecursive2'


class FindManyDArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    
    

class EIncludeFromN(TypedDict, total=False):
    """Relational arguments for N"""


class EIncludeFromNRecursive1(TypedDict, total=False):
    """Relational arguments for N"""


class EIncludeFromNRecursive2(TypedDict, total=False):
    """Relational arguments for N"""

    

class EArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    include: 'EIncludeFromERecursive1'


class EArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    include: 'EIncludeFromERecursive2'


class EArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    
    

class FindManyEArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromERecursive1'


class FindManyEArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromERecursive2'


class FindManyEArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    


FindManyNArgs = FindManyNArgsFromN
FindFirstNArgs = FindManyNArgsFromN


    

class NWhereInput(TypedDict, total=False):
    """N arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    m: 'MListRelationFilter'
    int: Union[_int, 'types.IntFilter']
    optional_int: Union[None, _int, 'types.IntFilter']
    float: Union[_float, 'types.FloatFilter']
    optional_float: Union[None, _float, 'types.FloatFilter']
    string: Union[_str, 'types.StringFilter']
    optional_string: Union[None, _str, 'types.StringFilter']
    json_: Union['fields.Json', 'types.JsonFilter']
    optional_json: Union[None, 'fields.Json', 'types.JsonFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanFilter']
    optional_boolean: Union[None, _bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['NWhereInputRecursive1', List['NWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['NWhereInputRecursive1']
    OR: List['NWhereInputRecursive1']
    NOT: List['NWhereInputRecursive1']


class NWhereInputRecursive1(TypedDict, total=False):
    """N arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    m: 'MListRelationFilter'
    int: Union[_int, 'types.IntFilter']
    optional_int: Union[None, _int, 'types.IntFilter']
    float: Union[_float, 'types.FloatFilter']
    optional_float: Union[None, _float, 'types.FloatFilter']
    string: Union[_str, 'types.StringFilter']
    optional_string: Union[None, _str, 'types.StringFilter']
    json_: Union['fields.Json', 'types.JsonFilter']
    optional_json: Union[None, 'fields.Json', 'types.JsonFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanFilter']
    optional_boolean: Union[None, _bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['NWhereInputRecursive2', List['NWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['NWhereInputRecursive2']
    OR: List['NWhereInputRecursive2']
    NOT: List['NWhereInputRecursive2']


class NWhereInputRecursive2(TypedDict, total=False):
    """N arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    m: 'MListRelationFilter'
    int: Union[_int, 'types.IntFilter']
    optional_int: Union[None, _int, 'types.IntFilter']
    float: Union[_float, 'types.FloatFilter']
    optional_float: Union[None, _float, 'types.FloatFilter']
    string: Union[_str, 'types.StringFilter']
    optional_string: Union[None, _str, 'types.StringFilter']
    json_: Union['fields.Json', 'types.JsonFilter']
    optional_json: Union[None, 'fields.Json', 'types.JsonFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanFilter']
    optional_boolean: Union[None, _bool, 'types.BooleanFilter']



# aggregate N types


    

class NScalarWhereWithAggregatesInput(TypedDict, total=False):
    """N arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    optional_int: Union[_int, 'types.IntWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    optional_float: Union[_float, 'types.FloatWithAggregatesFilter']
    string: Union[_str, 'types.StringWithAggregatesFilter']
    optional_string: Union[_str, 'types.StringWithAggregatesFilter']
    json_: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    optional_json: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']
    optional_boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['NScalarWhereWithAggregatesInputRecursive1']
    OR: List['NScalarWhereWithAggregatesInputRecursive1']
    NOT: List['NScalarWhereWithAggregatesInputRecursive1']


class NScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """N arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    optional_int: Union[_int, 'types.IntWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    optional_float: Union[_float, 'types.FloatWithAggregatesFilter']
    string: Union[_str, 'types.StringWithAggregatesFilter']
    optional_string: Union[_str, 'types.StringWithAggregatesFilter']
    json_: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    optional_json: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']
    optional_boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['NScalarWhereWithAggregatesInputRecursive2']
    OR: List['NScalarWhereWithAggregatesInputRecursive2']
    NOT: List['NScalarWhereWithAggregatesInputRecursive2']


class NScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """N arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    optional_int: Union[_int, 'types.IntWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    optional_float: Union[_float, 'types.FloatWithAggregatesFilter']
    string: Union[_str, 'types.StringWithAggregatesFilter']
    optional_string: Union[_str, 'types.StringWithAggregatesFilter']
    json_: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    optional_json: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']
    optional_boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']



class NGroupByOutput(TypedDict, total=False):
    id: _int
    int: _int
    optional_int: _int
    float: _float
    optional_float: _float
    string: _str
    optional_string: _str
    json_: 'fields.Json'
    optional_json: 'fields.Json'
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: _bool
    optional_boolean: _bool
    _sum: 'NSumAggregateOutput'
    _avg: 'NAvgAggregateOutput'
    _min: 'NMinAggregateOutput'
    _max: 'NMaxAggregateOutput'
    _count: 'NCountAggregateOutput'


class NAvgAggregateOutput(TypedDict, total=False):
    """N output for aggregating averages"""
    id: float
    int: float
    optional_int: float
    float: float
    optional_float: float


class NSumAggregateOutput(TypedDict, total=False):
    """N output for aggregating sums"""
    id: _int
    int: _int
    optional_int: _int
    float: _float
    optional_float: _float


class NScalarAggregateOutput(TypedDict, total=False):
    """N output including scalar fields"""
    id: _int
    int: _int
    optional_int: _int
    float: _float
    optional_float: _float
    string: _str
    optional_string: _str
    json_: 'fields.Json'
    optional_json: 'fields.Json'
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: _bool
    optional_boolean: _bool


NMinAggregateOutput = NScalarAggregateOutput
NMaxAggregateOutput = NScalarAggregateOutput


class NMaxAggregateInput(TypedDict, total=False):
    """N input for aggregating by max"""
    id: bool
    int: bool
    optional_int: bool
    float: bool
    optional_float: bool
    string: bool
    optional_string: bool
    json_: bool
    optional_json: bool
    enum: bool
    optional_enum: bool
    boolean: bool
    optional_boolean: bool


class NMinAggregateInput(TypedDict, total=False):
    """N input for aggregating by min"""
    id: bool
    int: bool
    optional_int: bool
    float: bool
    optional_float: bool
    string: bool
    optional_string: bool
    json_: bool
    optional_json: bool
    enum: bool
    optional_enum: bool
    boolean: bool
    optional_boolean: bool


class NNumberAggregateInput(TypedDict, total=False):
    """N input for aggregating numbers"""
    id: bool
    int: bool
    optional_int: bool
    float: bool
    optional_float: bool


NAvgAggregateInput = NNumberAggregateInput
NSumAggregateInput = NNumberAggregateInput


NCountAggregateInput = TypedDict(
    'NCountAggregateInput',
    {
        'id': bool,
        'int': bool,
        'optional_int': bool,
        'float': bool,
        'optional_float': bool,
        'string': bool,
        'optional_string': bool,
        'json_': bool,
        'optional_json': bool,
        'enum': bool,
        'optional_enum': bool,
        'boolean': bool,
        'optional_boolean': bool,
        '_all': bool,
    },
    total=False,
)

NCountAggregateOutput = TypedDict(
    'NCountAggregateOutput',
    {
        'id': int,
        'int': int,
        'optional_int': int,
        'float': int,
        'optional_float': int,
        'string': int,
        'optional_string': int,
        'json_': int,
        'optional_json': int,
        'enum': int,
        'optional_enum': int,
        'boolean': int,
        'optional_boolean': int,
        '_all': int,
    },
    total=False,
)


NKeys = Literal[
    'id',
    'm',
    'int',
    'optional_int',
    'float',
    'optional_float',
    'string',
    'optional_string',
    'json_',
    'optional_json',
    'enum',
    'optional_enum',
    'boolean',
    'optional_boolean',
]
NScalarFieldKeys = Literal[
    'id',
    'int',
    'optional_int',
    'float',
    'optional_float',
    'string',
    'optional_string',
    'json_',
    'optional_json',
    'enum',
    'optional_enum',
    'boolean',
    'optional_boolean',
]
NScalarFieldKeysT = TypeVar('NScalarFieldKeysT', bound=NScalarFieldKeys)

NRelationalFieldKeys = Literal[
        'm',
    ]

# OneOptional types

class OneOptionalOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the OneOptional create method"""
    id: _int
    many: 'ManyRequiredCreateManyNestedWithoutRelationsInput'
    optional_int: Optional[_int]
    optional_float: Optional[_float]
    optional_string: Optional[_str]
    optional_enum: Optional['enums.ABeautifulEnum']
    optional_boolean: Optional[_bool]


class OneOptionalCreateInput(OneOptionalOptionalCreateInput):
    """Required arguments to the OneOptional create method"""
    int: _int
    float: _float
    string: _str
    enum: 'enums.ABeautifulEnum'
    boolean: _bool


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class OneOptionalOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the OneOptional create method, without relations"""
    id: _int
    optional_int: Optional[_int]
    optional_float: Optional[_float]
    optional_string: Optional[_str]
    optional_enum: Optional['enums.ABeautifulEnum']
    optional_boolean: Optional[_bool]


class OneOptionalCreateWithoutRelationsInput(OneOptionalOptionalCreateWithoutRelationsInput):
    """Required arguments to the OneOptional create method, without relations"""
    int: _int
    float: _float
    string: _str
    enum: 'enums.ABeautifulEnum'
    boolean: _bool

class OneOptionalConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'OneOptionalCreateWithoutRelationsInput'
    where: 'OneOptionalWhereUniqueInput'

class OneOptionalCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'OneOptionalCreateWithoutRelationsInput'
    connect: 'OneOptionalWhereUniqueInput'
    connect_or_create: 'OneOptionalConnectOrCreateWithoutRelationsInput'


class OneOptionalCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['OneOptionalCreateWithoutRelationsInput', List['OneOptionalCreateWithoutRelationsInput']]
    connect: Union['OneOptionalWhereUniqueInput', List['OneOptionalWhereUniqueInput']]
    connect_or_create: Union['OneOptionalConnectOrCreateWithoutRelationsInput', List['OneOptionalConnectOrCreateWithoutRelationsInput']]

_OneOptionalWhereUnique_id_Input = TypedDict(
    '_OneOptionalWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

OneOptionalWhereUniqueInput = _OneOptionalWhereUnique_id_Input


class OneOptionalUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    many: 'ManyRequiredUpdateManyWithoutRelationsInput'
    int: Union[AtomicIntInput, _int]
    optional_int: Optional[Union[AtomicIntInput, _int]]
    float: Union[AtomicFloatInput, _float]
    optional_float: Optional[Union[AtomicFloatInput, _float]]
    string: _str
    optional_string: Optional[_str]
    enum: 'enums.ABeautifulEnum'
    optional_enum: Optional['enums.ABeautifulEnum']
    boolean: _bool
    optional_boolean: Optional[_bool]


class OneOptionalUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    int: Union[AtomicIntInput, _int]
    optional_int: Optional[Union[AtomicIntInput, _int]]
    float: Union[AtomicFloatInput, _float]
    optional_float: Optional[Union[AtomicFloatInput, _float]]
    string: _str
    optional_string: Optional[_str]
    enum: 'enums.ABeautifulEnum'
    optional_enum: Optional['enums.ABeautifulEnum']
    boolean: _bool
    optional_boolean: Optional[_bool]


class OneOptionalUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['OneOptionalCreateWithoutRelationsInput']
    connect: List['OneOptionalWhereUniqueInput']
    connect_or_create: List['OneOptionalConnectOrCreateWithoutRelationsInput']
    set: List['OneOptionalWhereUniqueInput']
    disconnect: List['OneOptionalWhereUniqueInput']
    delete: List['OneOptionalWhereUniqueInput']

    # TODO
    # update: List['OneOptionalUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['OneOptionalUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['OneOptionalScalarWhereInput']
    # upsert: List['OneOptionalUpserteWithWhereUniqueWithoutRelationsInput']


class OneOptionalUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'OneOptionalCreateWithoutRelationsInput'
    connect: 'OneOptionalWhereUniqueInput'
    connect_or_create: 'OneOptionalConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'OneOptionalUpdateInput'
    # upsert: 'OneOptionalUpsertWithoutRelationsInput'


class OneOptionalUpsertInput(TypedDict):
    create: 'OneOptionalCreateInput'
    update: 'OneOptionalUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_OneOptional_id_OrderByInput = TypedDict(
    '_OneOptional_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_OneOptional_int_OrderByInput = TypedDict(
    '_OneOptional_int_OrderByInput',
    {
        'int': 'SortOrder',
    },
    total=True
)

_OneOptional_optional_int_OrderByInput = TypedDict(
    '_OneOptional_optional_int_OrderByInput',
    {
        'optional_int': 'SortOrder',
    },
    total=True
)

_OneOptional_float_OrderByInput = TypedDict(
    '_OneOptional_float_OrderByInput',
    {
        'float': 'SortOrder',
    },
    total=True
)

_OneOptional_optional_float_OrderByInput = TypedDict(
    '_OneOptional_optional_float_OrderByInput',
    {
        'optional_float': 'SortOrder',
    },
    total=True
)

_OneOptional_string_OrderByInput = TypedDict(
    '_OneOptional_string_OrderByInput',
    {
        'string': 'SortOrder',
    },
    total=True
)

_OneOptional_optional_string_OrderByInput = TypedDict(
    '_OneOptional_optional_string_OrderByInput',
    {
        'optional_string': 'SortOrder',
    },
    total=True
)

_OneOptional_enum_OrderByInput = TypedDict(
    '_OneOptional_enum_OrderByInput',
    {
        'enum': 'SortOrder',
    },
    total=True
)

_OneOptional_optional_enum_OrderByInput = TypedDict(
    '_OneOptional_optional_enum_OrderByInput',
    {
        'optional_enum': 'SortOrder',
    },
    total=True
)

_OneOptional_boolean_OrderByInput = TypedDict(
    '_OneOptional_boolean_OrderByInput',
    {
        'boolean': 'SortOrder',
    },
    total=True
)

_OneOptional_optional_boolean_OrderByInput = TypedDict(
    '_OneOptional_optional_boolean_OrderByInput',
    {
        'optional_boolean': 'SortOrder',
    },
    total=True
)

_OneOptional_RelevanceInner = TypedDict(
    '_OneOptional_RelevanceInner',
    {
        'fields': 'List[OneOptionalScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_OneOptional_RelevanceOrderByInput = TypedDict(
    '_OneOptional_RelevanceOrderByInput',
    {
        '_relevance': '_OneOptional_RelevanceInner',
    },
    total=True
)

OneOptionalOrderByInput = Union[
    '_OneOptional_id_OrderByInput',
    '_OneOptional_int_OrderByInput',
    '_OneOptional_optional_int_OrderByInput',
    '_OneOptional_float_OrderByInput',
    '_OneOptional_optional_float_OrderByInput',
    '_OneOptional_string_OrderByInput',
    '_OneOptional_optional_string_OrderByInput',
    '_OneOptional_enum_OrderByInput',
    '_OneOptional_optional_enum_OrderByInput',
    '_OneOptional_boolean_OrderByInput',
    '_OneOptional_optional_boolean_OrderByInput',
    '_OneOptional_RelevanceOrderByInput',
]



# recursive OneOptional types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

OneOptionalRelationFilter = TypedDict(
    'OneOptionalRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class OneOptionalListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class OneOptionalInclude(TypedDict, total=False):
    """OneOptional relational arguments"""
    many: Union[bool, 'FindManyManyRequiredArgsFromOneOptional']


    

class PostIncludeFromOneOptional(TypedDict, total=False):
    """Relational arguments for OneOptional"""
    author: Union[bool, 'UserArgsFromOneOptionalRecursive1']


class PostIncludeFromOneOptionalRecursive1(TypedDict, total=False):
    """Relational arguments for OneOptional"""
    author: Union[bool, 'UserArgsFromOneOptionalRecursive2']


class PostIncludeFromOneOptionalRecursive2(TypedDict, total=False):
    """Relational arguments for OneOptional"""

    

class PostArgsFromOneOptional(TypedDict, total=False):
    """Arguments for OneOptional"""
    include: 'PostIncludeFromPostRecursive1'


class PostArgsFromOneOptionalRecursive1(TypedDict, total=False):
    """Arguments for OneOptional"""
    include: 'PostIncludeFromPostRecursive2'


class PostArgsFromOneOptionalRecursive2(TypedDict, total=False):
    """Arguments for OneOptional"""
    
    

class FindManyPostArgsFromOneOptional(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPostRecursive1'


class FindManyPostArgsFromOneOptionalRecursive1(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPostRecursive2'


class FindManyPostArgsFromOneOptionalRecursive2(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    
    

class UserIncludeFromOneOptional(TypedDict, total=False):
    """Relational arguments for OneOptional"""
    posts: Union[bool, 'FindManyPostArgsFromOneOptionalRecursive1']


class UserIncludeFromOneOptionalRecursive1(TypedDict, total=False):
    """Relational arguments for OneOptional"""
    posts: Union[bool, 'FindManyPostArgsFromOneOptionalRecursive2']


class UserIncludeFromOneOptionalRecursive2(TypedDict, total=False):
    """Relational arguments for OneOptional"""

    

class UserArgsFromOneOptional(TypedDict, total=False):
    """Arguments for OneOptional"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromOneOptionalRecursive1(TypedDict, total=False):
    """Arguments for OneOptional"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromOneOptionalRecursive2(TypedDict, total=False):
    """Arguments for OneOptional"""
    
    

class FindManyUserArgsFromOneOptional(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromOneOptionalRecursive1(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromOneOptionalRecursive2(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class MIncludeFromOneOptional(TypedDict, total=False):
    """Relational arguments for OneOptional"""
    n: Union[bool, 'FindManyNArgsFromOneOptionalRecursive1']


class MIncludeFromOneOptionalRecursive1(TypedDict, total=False):
    """Relational arguments for OneOptional"""
    n: Union[bool, 'FindManyNArgsFromOneOptionalRecursive2']


class MIncludeFromOneOptionalRecursive2(TypedDict, total=False):
    """Relational arguments for OneOptional"""

    

class MArgsFromOneOptional(TypedDict, total=False):
    """Arguments for OneOptional"""
    include: 'MIncludeFromMRecursive1'


class MArgsFromOneOptionalRecursive1(TypedDict, total=False):
    """Arguments for OneOptional"""
    include: 'MIncludeFromMRecursive2'


class MArgsFromOneOptionalRecursive2(TypedDict, total=False):
    """Arguments for OneOptional"""
    
    

class FindManyMArgsFromOneOptional(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromMRecursive1'


class FindManyMArgsFromOneOptionalRecursive1(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromMRecursive2'


class FindManyMArgsFromOneOptionalRecursive2(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    
    

class NIncludeFromOneOptional(TypedDict, total=False):
    """Relational arguments for OneOptional"""
    m: Union[bool, 'FindManyMArgsFromOneOptionalRecursive1']


class NIncludeFromOneOptionalRecursive1(TypedDict, total=False):
    """Relational arguments for OneOptional"""
    m: Union[bool, 'FindManyMArgsFromOneOptionalRecursive2']


class NIncludeFromOneOptionalRecursive2(TypedDict, total=False):
    """Relational arguments for OneOptional"""

    

class NArgsFromOneOptional(TypedDict, total=False):
    """Arguments for OneOptional"""
    include: 'NIncludeFromNRecursive1'


class NArgsFromOneOptionalRecursive1(TypedDict, total=False):
    """Arguments for OneOptional"""
    include: 'NIncludeFromNRecursive2'


class NArgsFromOneOptionalRecursive2(TypedDict, total=False):
    """Arguments for OneOptional"""
    
    

class FindManyNArgsFromOneOptional(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromNRecursive1'


class FindManyNArgsFromOneOptionalRecursive1(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromNRecursive2'


class FindManyNArgsFromOneOptionalRecursive2(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    
    

class OneOptionalIncludeFromOneOptional(TypedDict, total=False):
    """Relational arguments for OneOptional"""
    many: Union[bool, 'FindManyManyRequiredArgsFromOneOptionalRecursive1']


class OneOptionalIncludeFromOneOptionalRecursive1(TypedDict, total=False):
    """Relational arguments for OneOptional"""
    many: Union[bool, 'FindManyManyRequiredArgsFromOneOptionalRecursive2']


class OneOptionalIncludeFromOneOptionalRecursive2(TypedDict, total=False):
    """Relational arguments for OneOptional"""

    

class OneOptionalArgsFromOneOptional(TypedDict, total=False):
    """Arguments for OneOptional"""
    include: 'OneOptionalIncludeFromOneOptionalRecursive1'


class OneOptionalArgsFromOneOptionalRecursive1(TypedDict, total=False):
    """Arguments for OneOptional"""
    include: 'OneOptionalIncludeFromOneOptionalRecursive2'


class OneOptionalArgsFromOneOptionalRecursive2(TypedDict, total=False):
    """Arguments for OneOptional"""
    
    

class FindManyOneOptionalArgsFromOneOptional(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromOneOptionalRecursive1'


class FindManyOneOptionalArgsFromOneOptionalRecursive1(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromOneOptionalRecursive2'


class FindManyOneOptionalArgsFromOneOptionalRecursive2(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    
    

class ManyRequiredIncludeFromOneOptional(TypedDict, total=False):
    """Relational arguments for OneOptional"""
    one: Union[bool, 'OneOptionalArgsFromOneOptionalRecursive1']


class ManyRequiredIncludeFromOneOptionalRecursive1(TypedDict, total=False):
    """Relational arguments for OneOptional"""
    one: Union[bool, 'OneOptionalArgsFromOneOptionalRecursive2']


class ManyRequiredIncludeFromOneOptionalRecursive2(TypedDict, total=False):
    """Relational arguments for OneOptional"""

    

class ManyRequiredArgsFromOneOptional(TypedDict, total=False):
    """Arguments for OneOptional"""
    include: 'ManyRequiredIncludeFromManyRequiredRecursive1'


class ManyRequiredArgsFromOneOptionalRecursive1(TypedDict, total=False):
    """Arguments for OneOptional"""
    include: 'ManyRequiredIncludeFromManyRequiredRecursive2'


class ManyRequiredArgsFromOneOptionalRecursive2(TypedDict, total=False):
    """Arguments for OneOptional"""
    
    

class FindManyManyRequiredArgsFromOneOptional(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromManyRequiredRecursive1'


class FindManyManyRequiredArgsFromOneOptionalRecursive1(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromManyRequiredRecursive2'


class FindManyManyRequiredArgsFromOneOptionalRecursive2(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    
    

class ListsIncludeFromOneOptional(TypedDict, total=False):
    """Relational arguments for OneOptional"""


class ListsIncludeFromOneOptionalRecursive1(TypedDict, total=False):
    """Relational arguments for OneOptional"""


class ListsIncludeFromOneOptionalRecursive2(TypedDict, total=False):
    """Relational arguments for OneOptional"""

    

class ListsArgsFromOneOptional(TypedDict, total=False):
    """Arguments for OneOptional"""
    include: 'ListsIncludeFromListsRecursive1'


class ListsArgsFromOneOptionalRecursive1(TypedDict, total=False):
    """Arguments for OneOptional"""
    include: 'ListsIncludeFromListsRecursive2'


class ListsArgsFromOneOptionalRecursive2(TypedDict, total=False):
    """Arguments for OneOptional"""
    
    

class FindManyListsArgsFromOneOptional(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromListsRecursive1'


class FindManyListsArgsFromOneOptionalRecursive1(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromListsRecursive2'


class FindManyListsArgsFromOneOptionalRecursive2(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    
    

class AIncludeFromOneOptional(TypedDict, total=False):
    """Relational arguments for OneOptional"""


class AIncludeFromOneOptionalRecursive1(TypedDict, total=False):
    """Relational arguments for OneOptional"""


class AIncludeFromOneOptionalRecursive2(TypedDict, total=False):
    """Relational arguments for OneOptional"""

    

class AArgsFromOneOptional(TypedDict, total=False):
    """Arguments for OneOptional"""
    include: 'AIncludeFromARecursive1'


class AArgsFromOneOptionalRecursive1(TypedDict, total=False):
    """Arguments for OneOptional"""
    include: 'AIncludeFromARecursive2'


class AArgsFromOneOptionalRecursive2(TypedDict, total=False):
    """Arguments for OneOptional"""
    
    

class FindManyAArgsFromOneOptional(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromARecursive1'


class FindManyAArgsFromOneOptionalRecursive1(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromARecursive2'


class FindManyAArgsFromOneOptionalRecursive2(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    
    

class BIncludeFromOneOptional(TypedDict, total=False):
    """Relational arguments for OneOptional"""


class BIncludeFromOneOptionalRecursive1(TypedDict, total=False):
    """Relational arguments for OneOptional"""


class BIncludeFromOneOptionalRecursive2(TypedDict, total=False):
    """Relational arguments for OneOptional"""

    

class BArgsFromOneOptional(TypedDict, total=False):
    """Arguments for OneOptional"""
    include: 'BIncludeFromBRecursive1'


class BArgsFromOneOptionalRecursive1(TypedDict, total=False):
    """Arguments for OneOptional"""
    include: 'BIncludeFromBRecursive2'


class BArgsFromOneOptionalRecursive2(TypedDict, total=False):
    """Arguments for OneOptional"""
    
    

class FindManyBArgsFromOneOptional(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromBRecursive1'


class FindManyBArgsFromOneOptionalRecursive1(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromBRecursive2'


class FindManyBArgsFromOneOptionalRecursive2(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    
    

class CIncludeFromOneOptional(TypedDict, total=False):
    """Relational arguments for OneOptional"""


class CIncludeFromOneOptionalRecursive1(TypedDict, total=False):
    """Relational arguments for OneOptional"""


class CIncludeFromOneOptionalRecursive2(TypedDict, total=False):
    """Relational arguments for OneOptional"""

    

class CArgsFromOneOptional(TypedDict, total=False):
    """Arguments for OneOptional"""
    include: 'CIncludeFromCRecursive1'


class CArgsFromOneOptionalRecursive1(TypedDict, total=False):
    """Arguments for OneOptional"""
    include: 'CIncludeFromCRecursive2'


class CArgsFromOneOptionalRecursive2(TypedDict, total=False):
    """Arguments for OneOptional"""
    
    

class FindManyCArgsFromOneOptional(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromCRecursive1'


class FindManyCArgsFromOneOptionalRecursive1(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromCRecursive2'


class FindManyCArgsFromOneOptionalRecursive2(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    
    

class DIncludeFromOneOptional(TypedDict, total=False):
    """Relational arguments for OneOptional"""


class DIncludeFromOneOptionalRecursive1(TypedDict, total=False):
    """Relational arguments for OneOptional"""


class DIncludeFromOneOptionalRecursive2(TypedDict, total=False):
    """Relational arguments for OneOptional"""

    

class DArgsFromOneOptional(TypedDict, total=False):
    """Arguments for OneOptional"""
    include: 'DIncludeFromDRecursive1'


class DArgsFromOneOptionalRecursive1(TypedDict, total=False):
    """Arguments for OneOptional"""
    include: 'DIncludeFromDRecursive2'


class DArgsFromOneOptionalRecursive2(TypedDict, total=False):
    """Arguments for OneOptional"""
    
    

class FindManyDArgsFromOneOptional(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromDRecursive1'


class FindManyDArgsFromOneOptionalRecursive1(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromDRecursive2'


class FindManyDArgsFromOneOptionalRecursive2(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    
    

class EIncludeFromOneOptional(TypedDict, total=False):
    """Relational arguments for OneOptional"""


class EIncludeFromOneOptionalRecursive1(TypedDict, total=False):
    """Relational arguments for OneOptional"""


class EIncludeFromOneOptionalRecursive2(TypedDict, total=False):
    """Relational arguments for OneOptional"""

    

class EArgsFromOneOptional(TypedDict, total=False):
    """Arguments for OneOptional"""
    include: 'EIncludeFromERecursive1'


class EArgsFromOneOptionalRecursive1(TypedDict, total=False):
    """Arguments for OneOptional"""
    include: 'EIncludeFromERecursive2'


class EArgsFromOneOptionalRecursive2(TypedDict, total=False):
    """Arguments for OneOptional"""
    
    

class FindManyEArgsFromOneOptional(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromERecursive1'


class FindManyEArgsFromOneOptionalRecursive1(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromERecursive2'


class FindManyEArgsFromOneOptionalRecursive2(TypedDict, total=False):
    """Arguments for OneOptional"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    


FindManyOneOptionalArgs = FindManyOneOptionalArgsFromOneOptional
FindFirstOneOptionalArgs = FindManyOneOptionalArgsFromOneOptional


    

class OneOptionalWhereInput(TypedDict, total=False):
    """OneOptional arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    many: 'ManyRequiredListRelationFilter'
    int: Union[_int, 'types.IntFilter']
    optional_int: Union[None, _int, 'types.IntFilter']
    float: Union[_float, 'types.FloatFilter']
    optional_float: Union[None, _float, 'types.FloatFilter']
    string: Union[_str, 'types.StringFilter']
    optional_string: Union[None, _str, 'types.StringFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanFilter']
    optional_boolean: Union[None, _bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['OneOptionalWhereInputRecursive1', List['OneOptionalWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['OneOptionalWhereInputRecursive1']
    OR: List['OneOptionalWhereInputRecursive1']
    NOT: List['OneOptionalWhereInputRecursive1']


class OneOptionalWhereInputRecursive1(TypedDict, total=False):
    """OneOptional arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    many: 'ManyRequiredListRelationFilter'
    int: Union[_int, 'types.IntFilter']
    optional_int: Union[None, _int, 'types.IntFilter']
    float: Union[_float, 'types.FloatFilter']
    optional_float: Union[None, _float, 'types.FloatFilter']
    string: Union[_str, 'types.StringFilter']
    optional_string: Union[None, _str, 'types.StringFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanFilter']
    optional_boolean: Union[None, _bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['OneOptionalWhereInputRecursive2', List['OneOptionalWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['OneOptionalWhereInputRecursive2']
    OR: List['OneOptionalWhereInputRecursive2']
    NOT: List['OneOptionalWhereInputRecursive2']


class OneOptionalWhereInputRecursive2(TypedDict, total=False):
    """OneOptional arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    many: 'ManyRequiredListRelationFilter'
    int: Union[_int, 'types.IntFilter']
    optional_int: Union[None, _int, 'types.IntFilter']
    float: Union[_float, 'types.FloatFilter']
    optional_float: Union[None, _float, 'types.FloatFilter']
    string: Union[_str, 'types.StringFilter']
    optional_string: Union[None, _str, 'types.StringFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanFilter']
    optional_boolean: Union[None, _bool, 'types.BooleanFilter']



# aggregate OneOptional types


    

class OneOptionalScalarWhereWithAggregatesInput(TypedDict, total=False):
    """OneOptional arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    optional_int: Union[_int, 'types.IntWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    optional_float: Union[_float, 'types.FloatWithAggregatesFilter']
    string: Union[_str, 'types.StringWithAggregatesFilter']
    optional_string: Union[_str, 'types.StringWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']
    optional_boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['OneOptionalScalarWhereWithAggregatesInputRecursive1']
    OR: List['OneOptionalScalarWhereWithAggregatesInputRecursive1']
    NOT: List['OneOptionalScalarWhereWithAggregatesInputRecursive1']


class OneOptionalScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """OneOptional arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    optional_int: Union[_int, 'types.IntWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    optional_float: Union[_float, 'types.FloatWithAggregatesFilter']
    string: Union[_str, 'types.StringWithAggregatesFilter']
    optional_string: Union[_str, 'types.StringWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']
    optional_boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['OneOptionalScalarWhereWithAggregatesInputRecursive2']
    OR: List['OneOptionalScalarWhereWithAggregatesInputRecursive2']
    NOT: List['OneOptionalScalarWhereWithAggregatesInputRecursive2']


class OneOptionalScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """OneOptional arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    optional_int: Union[_int, 'types.IntWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    optional_float: Union[_float, 'types.FloatWithAggregatesFilter']
    string: Union[_str, 'types.StringWithAggregatesFilter']
    optional_string: Union[_str, 'types.StringWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']
    optional_boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']



class OneOptionalGroupByOutput(TypedDict, total=False):
    id: _int
    int: _int
    optional_int: _int
    float: _float
    optional_float: _float
    string: _str
    optional_string: _str
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: _bool
    optional_boolean: _bool
    _sum: 'OneOptionalSumAggregateOutput'
    _avg: 'OneOptionalAvgAggregateOutput'
    _min: 'OneOptionalMinAggregateOutput'
    _max: 'OneOptionalMaxAggregateOutput'
    _count: 'OneOptionalCountAggregateOutput'


class OneOptionalAvgAggregateOutput(TypedDict, total=False):
    """OneOptional output for aggregating averages"""
    id: float
    int: float
    optional_int: float
    float: float
    optional_float: float


class OneOptionalSumAggregateOutput(TypedDict, total=False):
    """OneOptional output for aggregating sums"""
    id: _int
    int: _int
    optional_int: _int
    float: _float
    optional_float: _float


class OneOptionalScalarAggregateOutput(TypedDict, total=False):
    """OneOptional output including scalar fields"""
    id: _int
    int: _int
    optional_int: _int
    float: _float
    optional_float: _float
    string: _str
    optional_string: _str
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: _bool
    optional_boolean: _bool


OneOptionalMinAggregateOutput = OneOptionalScalarAggregateOutput
OneOptionalMaxAggregateOutput = OneOptionalScalarAggregateOutput


class OneOptionalMaxAggregateInput(TypedDict, total=False):
    """OneOptional input for aggregating by max"""
    id: bool
    int: bool
    optional_int: bool
    float: bool
    optional_float: bool
    string: bool
    optional_string: bool
    enum: bool
    optional_enum: bool
    boolean: bool
    optional_boolean: bool


class OneOptionalMinAggregateInput(TypedDict, total=False):
    """OneOptional input for aggregating by min"""
    id: bool
    int: bool
    optional_int: bool
    float: bool
    optional_float: bool
    string: bool
    optional_string: bool
    enum: bool
    optional_enum: bool
    boolean: bool
    optional_boolean: bool


class OneOptionalNumberAggregateInput(TypedDict, total=False):
    """OneOptional input for aggregating numbers"""
    id: bool
    int: bool
    optional_int: bool
    float: bool
    optional_float: bool


OneOptionalAvgAggregateInput = OneOptionalNumberAggregateInput
OneOptionalSumAggregateInput = OneOptionalNumberAggregateInput


OneOptionalCountAggregateInput = TypedDict(
    'OneOptionalCountAggregateInput',
    {
        'id': bool,
        'int': bool,
        'optional_int': bool,
        'float': bool,
        'optional_float': bool,
        'string': bool,
        'optional_string': bool,
        'enum': bool,
        'optional_enum': bool,
        'boolean': bool,
        'optional_boolean': bool,
        '_all': bool,
    },
    total=False,
)

OneOptionalCountAggregateOutput = TypedDict(
    'OneOptionalCountAggregateOutput',
    {
        'id': int,
        'int': int,
        'optional_int': int,
        'float': int,
        'optional_float': int,
        'string': int,
        'optional_string': int,
        'enum': int,
        'optional_enum': int,
        'boolean': int,
        'optional_boolean': int,
        '_all': int,
    },
    total=False,
)


OneOptionalKeys = Literal[
    'id',
    'many',
    'int',
    'optional_int',
    'float',
    'optional_float',
    'string',
    'optional_string',
    'enum',
    'optional_enum',
    'boolean',
    'optional_boolean',
]
OneOptionalScalarFieldKeys = Literal[
    'id',
    'int',
    'optional_int',
    'float',
    'optional_float',
    'string',
    'optional_string',
    'enum',
    'optional_enum',
    'boolean',
    'optional_boolean',
]
OneOptionalScalarFieldKeysT = TypeVar('OneOptionalScalarFieldKeysT', bound=OneOptionalScalarFieldKeys)

OneOptionalRelationalFieldKeys = Literal[
        'many',
    ]

# ManyRequired types

class ManyRequiredOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the ManyRequired create method"""
    id: _int
    one: 'OneOptionalCreateNestedWithoutRelationsInput'
    one_optional_id: Optional[_int]
    optional_int: Optional[_int]
    optional_float: Optional[_float]
    optional_string: Optional[_str]
    optional_enum: Optional['enums.ABeautifulEnum']
    optional_boolean: Optional[_bool]


class ManyRequiredCreateInput(ManyRequiredOptionalCreateInput):
    """Required arguments to the ManyRequired create method"""
    int: _int
    float: _float
    string: _str
    enum: 'enums.ABeautifulEnum'
    boolean: _bool


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ManyRequiredOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the ManyRequired create method, without relations"""
    id: _int
    one_optional_id: Optional[_int]
    optional_int: Optional[_int]
    optional_float: Optional[_float]
    optional_string: Optional[_str]
    optional_enum: Optional['enums.ABeautifulEnum']
    optional_boolean: Optional[_bool]


class ManyRequiredCreateWithoutRelationsInput(ManyRequiredOptionalCreateWithoutRelationsInput):
    """Required arguments to the ManyRequired create method, without relations"""
    int: _int
    float: _float
    string: _str
    enum: 'enums.ABeautifulEnum'
    boolean: _bool

class ManyRequiredConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ManyRequiredCreateWithoutRelationsInput'
    where: 'ManyRequiredWhereUniqueInput'

class ManyRequiredCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ManyRequiredCreateWithoutRelationsInput'
    connect: 'ManyRequiredWhereUniqueInput'
    connect_or_create: 'ManyRequiredConnectOrCreateWithoutRelationsInput'


class ManyRequiredCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ManyRequiredCreateWithoutRelationsInput', List['ManyRequiredCreateWithoutRelationsInput']]
    connect: Union['ManyRequiredWhereUniqueInput', List['ManyRequiredWhereUniqueInput']]
    connect_or_create: Union['ManyRequiredConnectOrCreateWithoutRelationsInput', List['ManyRequiredConnectOrCreateWithoutRelationsInput']]

_ManyRequiredWhereUnique_id_Input = TypedDict(
    '_ManyRequiredWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

ManyRequiredWhereUniqueInput = _ManyRequiredWhereUnique_id_Input


class ManyRequiredUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    one: 'OneOptionalUpdateOneWithoutRelationsInput'
    int: Union[AtomicIntInput, _int]
    optional_int: Optional[Union[AtomicIntInput, _int]]
    float: Union[AtomicFloatInput, _float]
    optional_float: Optional[Union[AtomicFloatInput, _float]]
    string: _str
    optional_string: Optional[_str]
    enum: 'enums.ABeautifulEnum'
    optional_enum: Optional['enums.ABeautifulEnum']
    boolean: _bool
    optional_boolean: Optional[_bool]


class ManyRequiredUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    int: Union[AtomicIntInput, _int]
    optional_int: Optional[Union[AtomicIntInput, _int]]
    float: Union[AtomicFloatInput, _float]
    optional_float: Optional[Union[AtomicFloatInput, _float]]
    string: _str
    optional_string: Optional[_str]
    enum: 'enums.ABeautifulEnum'
    optional_enum: Optional['enums.ABeautifulEnum']
    boolean: _bool
    optional_boolean: Optional[_bool]


class ManyRequiredUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ManyRequiredCreateWithoutRelationsInput']
    connect: List['ManyRequiredWhereUniqueInput']
    connect_or_create: List['ManyRequiredConnectOrCreateWithoutRelationsInput']
    set: List['ManyRequiredWhereUniqueInput']
    disconnect: List['ManyRequiredWhereUniqueInput']
    delete: List['ManyRequiredWhereUniqueInput']

    # TODO
    # update: List['ManyRequiredUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ManyRequiredUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ManyRequiredScalarWhereInput']
    # upsert: List['ManyRequiredUpserteWithWhereUniqueWithoutRelationsInput']


class ManyRequiredUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ManyRequiredCreateWithoutRelationsInput'
    connect: 'ManyRequiredWhereUniqueInput'
    connect_or_create: 'ManyRequiredConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ManyRequiredUpdateInput'
    # upsert: 'ManyRequiredUpsertWithoutRelationsInput'


class ManyRequiredUpsertInput(TypedDict):
    create: 'ManyRequiredCreateInput'
    update: 'ManyRequiredUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_ManyRequired_id_OrderByInput = TypedDict(
    '_ManyRequired_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_ManyRequired_one_optional_id_OrderByInput = TypedDict(
    '_ManyRequired_one_optional_id_OrderByInput',
    {
        'one_optional_id': 'SortOrder',
    },
    total=True
)

_ManyRequired_int_OrderByInput = TypedDict(
    '_ManyRequired_int_OrderByInput',
    {
        'int': 'SortOrder',
    },
    total=True
)

_ManyRequired_optional_int_OrderByInput = TypedDict(
    '_ManyRequired_optional_int_OrderByInput',
    {
        'optional_int': 'SortOrder',
    },
    total=True
)

_ManyRequired_float_OrderByInput = TypedDict(
    '_ManyRequired_float_OrderByInput',
    {
        'float': 'SortOrder',
    },
    total=True
)

_ManyRequired_optional_float_OrderByInput = TypedDict(
    '_ManyRequired_optional_float_OrderByInput',
    {
        'optional_float': 'SortOrder',
    },
    total=True
)

_ManyRequired_string_OrderByInput = TypedDict(
    '_ManyRequired_string_OrderByInput',
    {
        'string': 'SortOrder',
    },
    total=True
)

_ManyRequired_optional_string_OrderByInput = TypedDict(
    '_ManyRequired_optional_string_OrderByInput',
    {
        'optional_string': 'SortOrder',
    },
    total=True
)

_ManyRequired_enum_OrderByInput = TypedDict(
    '_ManyRequired_enum_OrderByInput',
    {
        'enum': 'SortOrder',
    },
    total=True
)

_ManyRequired_optional_enum_OrderByInput = TypedDict(
    '_ManyRequired_optional_enum_OrderByInput',
    {
        'optional_enum': 'SortOrder',
    },
    total=True
)

_ManyRequired_boolean_OrderByInput = TypedDict(
    '_ManyRequired_boolean_OrderByInput',
    {
        'boolean': 'SortOrder',
    },
    total=True
)

_ManyRequired_optional_boolean_OrderByInput = TypedDict(
    '_ManyRequired_optional_boolean_OrderByInput',
    {
        'optional_boolean': 'SortOrder',
    },
    total=True
)

_ManyRequired_RelevanceInner = TypedDict(
    '_ManyRequired_RelevanceInner',
    {
        'fields': 'List[ManyRequiredScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_ManyRequired_RelevanceOrderByInput = TypedDict(
    '_ManyRequired_RelevanceOrderByInput',
    {
        '_relevance': '_ManyRequired_RelevanceInner',
    },
    total=True
)

ManyRequiredOrderByInput = Union[
    '_ManyRequired_id_OrderByInput',
    '_ManyRequired_one_optional_id_OrderByInput',
    '_ManyRequired_int_OrderByInput',
    '_ManyRequired_optional_int_OrderByInput',
    '_ManyRequired_float_OrderByInput',
    '_ManyRequired_optional_float_OrderByInput',
    '_ManyRequired_string_OrderByInput',
    '_ManyRequired_optional_string_OrderByInput',
    '_ManyRequired_enum_OrderByInput',
    '_ManyRequired_optional_enum_OrderByInput',
    '_ManyRequired_boolean_OrderByInput',
    '_ManyRequired_optional_boolean_OrderByInput',
    '_ManyRequired_RelevanceOrderByInput',
]



# recursive ManyRequired types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

ManyRequiredRelationFilter = TypedDict(
    'ManyRequiredRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class ManyRequiredListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class ManyRequiredInclude(TypedDict, total=False):
    """ManyRequired relational arguments"""
    one: Union[bool, 'OneOptionalArgsFromManyRequired']


    

class PostIncludeFromManyRequired(TypedDict, total=False):
    """Relational arguments for ManyRequired"""
    author: Union[bool, 'UserArgsFromManyRequiredRecursive1']


class PostIncludeFromManyRequiredRecursive1(TypedDict, total=False):
    """Relational arguments for ManyRequired"""
    author: Union[bool, 'UserArgsFromManyRequiredRecursive2']


class PostIncludeFromManyRequiredRecursive2(TypedDict, total=False):
    """Relational arguments for ManyRequired"""

    

class PostArgsFromManyRequired(TypedDict, total=False):
    """Arguments for ManyRequired"""
    include: 'PostIncludeFromPostRecursive1'


class PostArgsFromManyRequiredRecursive1(TypedDict, total=False):
    """Arguments for ManyRequired"""
    include: 'PostIncludeFromPostRecursive2'


class PostArgsFromManyRequiredRecursive2(TypedDict, total=False):
    """Arguments for ManyRequired"""
    
    

class FindManyPostArgsFromManyRequired(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPostRecursive1'


class FindManyPostArgsFromManyRequiredRecursive1(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPostRecursive2'


class FindManyPostArgsFromManyRequiredRecursive2(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    
    

class UserIncludeFromManyRequired(TypedDict, total=False):
    """Relational arguments for ManyRequired"""
    posts: Union[bool, 'FindManyPostArgsFromManyRequiredRecursive1']


class UserIncludeFromManyRequiredRecursive1(TypedDict, total=False):
    """Relational arguments for ManyRequired"""
    posts: Union[bool, 'FindManyPostArgsFromManyRequiredRecursive2']


class UserIncludeFromManyRequiredRecursive2(TypedDict, total=False):
    """Relational arguments for ManyRequired"""

    

class UserArgsFromManyRequired(TypedDict, total=False):
    """Arguments for ManyRequired"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromManyRequiredRecursive1(TypedDict, total=False):
    """Arguments for ManyRequired"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromManyRequiredRecursive2(TypedDict, total=False):
    """Arguments for ManyRequired"""
    
    

class FindManyUserArgsFromManyRequired(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromManyRequiredRecursive1(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromManyRequiredRecursive2(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class MIncludeFromManyRequired(TypedDict, total=False):
    """Relational arguments for ManyRequired"""
    n: Union[bool, 'FindManyNArgsFromManyRequiredRecursive1']


class MIncludeFromManyRequiredRecursive1(TypedDict, total=False):
    """Relational arguments for ManyRequired"""
    n: Union[bool, 'FindManyNArgsFromManyRequiredRecursive2']


class MIncludeFromManyRequiredRecursive2(TypedDict, total=False):
    """Relational arguments for ManyRequired"""

    

class MArgsFromManyRequired(TypedDict, total=False):
    """Arguments for ManyRequired"""
    include: 'MIncludeFromMRecursive1'


class MArgsFromManyRequiredRecursive1(TypedDict, total=False):
    """Arguments for ManyRequired"""
    include: 'MIncludeFromMRecursive2'


class MArgsFromManyRequiredRecursive2(TypedDict, total=False):
    """Arguments for ManyRequired"""
    
    

class FindManyMArgsFromManyRequired(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromMRecursive1'


class FindManyMArgsFromManyRequiredRecursive1(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromMRecursive2'


class FindManyMArgsFromManyRequiredRecursive2(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    
    

class NIncludeFromManyRequired(TypedDict, total=False):
    """Relational arguments for ManyRequired"""
    m: Union[bool, 'FindManyMArgsFromManyRequiredRecursive1']


class NIncludeFromManyRequiredRecursive1(TypedDict, total=False):
    """Relational arguments for ManyRequired"""
    m: Union[bool, 'FindManyMArgsFromManyRequiredRecursive2']


class NIncludeFromManyRequiredRecursive2(TypedDict, total=False):
    """Relational arguments for ManyRequired"""

    

class NArgsFromManyRequired(TypedDict, total=False):
    """Arguments for ManyRequired"""
    include: 'NIncludeFromNRecursive1'


class NArgsFromManyRequiredRecursive1(TypedDict, total=False):
    """Arguments for ManyRequired"""
    include: 'NIncludeFromNRecursive2'


class NArgsFromManyRequiredRecursive2(TypedDict, total=False):
    """Arguments for ManyRequired"""
    
    

class FindManyNArgsFromManyRequired(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromNRecursive1'


class FindManyNArgsFromManyRequiredRecursive1(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromNRecursive2'


class FindManyNArgsFromManyRequiredRecursive2(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    
    

class OneOptionalIncludeFromManyRequired(TypedDict, total=False):
    """Relational arguments for ManyRequired"""
    many: Union[bool, 'FindManyManyRequiredArgsFromManyRequiredRecursive1']


class OneOptionalIncludeFromManyRequiredRecursive1(TypedDict, total=False):
    """Relational arguments for ManyRequired"""
    many: Union[bool, 'FindManyManyRequiredArgsFromManyRequiredRecursive2']


class OneOptionalIncludeFromManyRequiredRecursive2(TypedDict, total=False):
    """Relational arguments for ManyRequired"""

    

class OneOptionalArgsFromManyRequired(TypedDict, total=False):
    """Arguments for ManyRequired"""
    include: 'OneOptionalIncludeFromOneOptionalRecursive1'


class OneOptionalArgsFromManyRequiredRecursive1(TypedDict, total=False):
    """Arguments for ManyRequired"""
    include: 'OneOptionalIncludeFromOneOptionalRecursive2'


class OneOptionalArgsFromManyRequiredRecursive2(TypedDict, total=False):
    """Arguments for ManyRequired"""
    
    

class FindManyOneOptionalArgsFromManyRequired(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromOneOptionalRecursive1'


class FindManyOneOptionalArgsFromManyRequiredRecursive1(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromOneOptionalRecursive2'


class FindManyOneOptionalArgsFromManyRequiredRecursive2(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    
    

class ManyRequiredIncludeFromManyRequired(TypedDict, total=False):
    """Relational arguments for ManyRequired"""
    one: Union[bool, 'OneOptionalArgsFromManyRequiredRecursive1']


class ManyRequiredIncludeFromManyRequiredRecursive1(TypedDict, total=False):
    """Relational arguments for ManyRequired"""
    one: Union[bool, 'OneOptionalArgsFromManyRequiredRecursive2']


class ManyRequiredIncludeFromManyRequiredRecursive2(TypedDict, total=False):
    """Relational arguments for ManyRequired"""

    

class ManyRequiredArgsFromManyRequired(TypedDict, total=False):
    """Arguments for ManyRequired"""
    include: 'ManyRequiredIncludeFromManyRequiredRecursive1'


class ManyRequiredArgsFromManyRequiredRecursive1(TypedDict, total=False):
    """Arguments for ManyRequired"""
    include: 'ManyRequiredIncludeFromManyRequiredRecursive2'


class ManyRequiredArgsFromManyRequiredRecursive2(TypedDict, total=False):
    """Arguments for ManyRequired"""
    
    

class FindManyManyRequiredArgsFromManyRequired(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromManyRequiredRecursive1'


class FindManyManyRequiredArgsFromManyRequiredRecursive1(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromManyRequiredRecursive2'


class FindManyManyRequiredArgsFromManyRequiredRecursive2(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    
    

class ListsIncludeFromManyRequired(TypedDict, total=False):
    """Relational arguments for ManyRequired"""


class ListsIncludeFromManyRequiredRecursive1(TypedDict, total=False):
    """Relational arguments for ManyRequired"""


class ListsIncludeFromManyRequiredRecursive2(TypedDict, total=False):
    """Relational arguments for ManyRequired"""

    

class ListsArgsFromManyRequired(TypedDict, total=False):
    """Arguments for ManyRequired"""
    include: 'ListsIncludeFromListsRecursive1'


class ListsArgsFromManyRequiredRecursive1(TypedDict, total=False):
    """Arguments for ManyRequired"""
    include: 'ListsIncludeFromListsRecursive2'


class ListsArgsFromManyRequiredRecursive2(TypedDict, total=False):
    """Arguments for ManyRequired"""
    
    

class FindManyListsArgsFromManyRequired(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromListsRecursive1'


class FindManyListsArgsFromManyRequiredRecursive1(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromListsRecursive2'


class FindManyListsArgsFromManyRequiredRecursive2(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    
    

class AIncludeFromManyRequired(TypedDict, total=False):
    """Relational arguments for ManyRequired"""


class AIncludeFromManyRequiredRecursive1(TypedDict, total=False):
    """Relational arguments for ManyRequired"""


class AIncludeFromManyRequiredRecursive2(TypedDict, total=False):
    """Relational arguments for ManyRequired"""

    

class AArgsFromManyRequired(TypedDict, total=False):
    """Arguments for ManyRequired"""
    include: 'AIncludeFromARecursive1'


class AArgsFromManyRequiredRecursive1(TypedDict, total=False):
    """Arguments for ManyRequired"""
    include: 'AIncludeFromARecursive2'


class AArgsFromManyRequiredRecursive2(TypedDict, total=False):
    """Arguments for ManyRequired"""
    
    

class FindManyAArgsFromManyRequired(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromARecursive1'


class FindManyAArgsFromManyRequiredRecursive1(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromARecursive2'


class FindManyAArgsFromManyRequiredRecursive2(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    
    

class BIncludeFromManyRequired(TypedDict, total=False):
    """Relational arguments for ManyRequired"""


class BIncludeFromManyRequiredRecursive1(TypedDict, total=False):
    """Relational arguments for ManyRequired"""


class BIncludeFromManyRequiredRecursive2(TypedDict, total=False):
    """Relational arguments for ManyRequired"""

    

class BArgsFromManyRequired(TypedDict, total=False):
    """Arguments for ManyRequired"""
    include: 'BIncludeFromBRecursive1'


class BArgsFromManyRequiredRecursive1(TypedDict, total=False):
    """Arguments for ManyRequired"""
    include: 'BIncludeFromBRecursive2'


class BArgsFromManyRequiredRecursive2(TypedDict, total=False):
    """Arguments for ManyRequired"""
    
    

class FindManyBArgsFromManyRequired(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromBRecursive1'


class FindManyBArgsFromManyRequiredRecursive1(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromBRecursive2'


class FindManyBArgsFromManyRequiredRecursive2(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    
    

class CIncludeFromManyRequired(TypedDict, total=False):
    """Relational arguments for ManyRequired"""


class CIncludeFromManyRequiredRecursive1(TypedDict, total=False):
    """Relational arguments for ManyRequired"""


class CIncludeFromManyRequiredRecursive2(TypedDict, total=False):
    """Relational arguments for ManyRequired"""

    

class CArgsFromManyRequired(TypedDict, total=False):
    """Arguments for ManyRequired"""
    include: 'CIncludeFromCRecursive1'


class CArgsFromManyRequiredRecursive1(TypedDict, total=False):
    """Arguments for ManyRequired"""
    include: 'CIncludeFromCRecursive2'


class CArgsFromManyRequiredRecursive2(TypedDict, total=False):
    """Arguments for ManyRequired"""
    
    

class FindManyCArgsFromManyRequired(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromCRecursive1'


class FindManyCArgsFromManyRequiredRecursive1(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromCRecursive2'


class FindManyCArgsFromManyRequiredRecursive2(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    
    

class DIncludeFromManyRequired(TypedDict, total=False):
    """Relational arguments for ManyRequired"""


class DIncludeFromManyRequiredRecursive1(TypedDict, total=False):
    """Relational arguments for ManyRequired"""


class DIncludeFromManyRequiredRecursive2(TypedDict, total=False):
    """Relational arguments for ManyRequired"""

    

class DArgsFromManyRequired(TypedDict, total=False):
    """Arguments for ManyRequired"""
    include: 'DIncludeFromDRecursive1'


class DArgsFromManyRequiredRecursive1(TypedDict, total=False):
    """Arguments for ManyRequired"""
    include: 'DIncludeFromDRecursive2'


class DArgsFromManyRequiredRecursive2(TypedDict, total=False):
    """Arguments for ManyRequired"""
    
    

class FindManyDArgsFromManyRequired(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromDRecursive1'


class FindManyDArgsFromManyRequiredRecursive1(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromDRecursive2'


class FindManyDArgsFromManyRequiredRecursive2(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    
    

class EIncludeFromManyRequired(TypedDict, total=False):
    """Relational arguments for ManyRequired"""


class EIncludeFromManyRequiredRecursive1(TypedDict, total=False):
    """Relational arguments for ManyRequired"""


class EIncludeFromManyRequiredRecursive2(TypedDict, total=False):
    """Relational arguments for ManyRequired"""

    

class EArgsFromManyRequired(TypedDict, total=False):
    """Arguments for ManyRequired"""
    include: 'EIncludeFromERecursive1'


class EArgsFromManyRequiredRecursive1(TypedDict, total=False):
    """Arguments for ManyRequired"""
    include: 'EIncludeFromERecursive2'


class EArgsFromManyRequiredRecursive2(TypedDict, total=False):
    """Arguments for ManyRequired"""
    
    

class FindManyEArgsFromManyRequired(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromERecursive1'


class FindManyEArgsFromManyRequiredRecursive1(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromERecursive2'


class FindManyEArgsFromManyRequiredRecursive2(TypedDict, total=False):
    """Arguments for ManyRequired"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    


FindManyManyRequiredArgs = FindManyManyRequiredArgsFromManyRequired
FindFirstManyRequiredArgs = FindManyManyRequiredArgsFromManyRequired


    

class ManyRequiredWhereInput(TypedDict, total=False):
    """ManyRequired arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    one: 'OneOptionalRelationFilter'
    one_optional_id: Union[None, _int, 'types.IntFilter']
    int: Union[_int, 'types.IntFilter']
    optional_int: Union[None, _int, 'types.IntFilter']
    float: Union[_float, 'types.FloatFilter']
    optional_float: Union[None, _float, 'types.FloatFilter']
    string: Union[_str, 'types.StringFilter']
    optional_string: Union[None, _str, 'types.StringFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanFilter']
    optional_boolean: Union[None, _bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['ManyRequiredWhereInputRecursive1', List['ManyRequiredWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['ManyRequiredWhereInputRecursive1']
    OR: List['ManyRequiredWhereInputRecursive1']
    NOT: List['ManyRequiredWhereInputRecursive1']


class ManyRequiredWhereInputRecursive1(TypedDict, total=False):
    """ManyRequired arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    one: 'OneOptionalRelationFilter'
    one_optional_id: Union[None, _int, 'types.IntFilter']
    int: Union[_int, 'types.IntFilter']
    optional_int: Union[None, _int, 'types.IntFilter']
    float: Union[_float, 'types.FloatFilter']
    optional_float: Union[None, _float, 'types.FloatFilter']
    string: Union[_str, 'types.StringFilter']
    optional_string: Union[None, _str, 'types.StringFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanFilter']
    optional_boolean: Union[None, _bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['ManyRequiredWhereInputRecursive2', List['ManyRequiredWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['ManyRequiredWhereInputRecursive2']
    OR: List['ManyRequiredWhereInputRecursive2']
    NOT: List['ManyRequiredWhereInputRecursive2']


class ManyRequiredWhereInputRecursive2(TypedDict, total=False):
    """ManyRequired arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    one: 'OneOptionalRelationFilter'
    one_optional_id: Union[None, _int, 'types.IntFilter']
    int: Union[_int, 'types.IntFilter']
    optional_int: Union[None, _int, 'types.IntFilter']
    float: Union[_float, 'types.FloatFilter']
    optional_float: Union[None, _float, 'types.FloatFilter']
    string: Union[_str, 'types.StringFilter']
    optional_string: Union[None, _str, 'types.StringFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanFilter']
    optional_boolean: Union[None, _bool, 'types.BooleanFilter']



# aggregate ManyRequired types


    

class ManyRequiredScalarWhereWithAggregatesInput(TypedDict, total=False):
    """ManyRequired arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    one_optional_id: Union[_int, 'types.IntWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    optional_int: Union[_int, 'types.IntWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    optional_float: Union[_float, 'types.FloatWithAggregatesFilter']
    string: Union[_str, 'types.StringWithAggregatesFilter']
    optional_string: Union[_str, 'types.StringWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']
    optional_boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['ManyRequiredScalarWhereWithAggregatesInputRecursive1']
    OR: List['ManyRequiredScalarWhereWithAggregatesInputRecursive1']
    NOT: List['ManyRequiredScalarWhereWithAggregatesInputRecursive1']


class ManyRequiredScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """ManyRequired arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    one_optional_id: Union[_int, 'types.IntWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    optional_int: Union[_int, 'types.IntWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    optional_float: Union[_float, 'types.FloatWithAggregatesFilter']
    string: Union[_str, 'types.StringWithAggregatesFilter']
    optional_string: Union[_str, 'types.StringWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']
    optional_boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['ManyRequiredScalarWhereWithAggregatesInputRecursive2']
    OR: List['ManyRequiredScalarWhereWithAggregatesInputRecursive2']
    NOT: List['ManyRequiredScalarWhereWithAggregatesInputRecursive2']


class ManyRequiredScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """ManyRequired arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    one_optional_id: Union[_int, 'types.IntWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    optional_int: Union[_int, 'types.IntWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    optional_float: Union[_float, 'types.FloatWithAggregatesFilter']
    string: Union[_str, 'types.StringWithAggregatesFilter']
    optional_string: Union[_str, 'types.StringWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']
    optional_boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']



class ManyRequiredGroupByOutput(TypedDict, total=False):
    id: _int
    one_optional_id: _int
    int: _int
    optional_int: _int
    float: _float
    optional_float: _float
    string: _str
    optional_string: _str
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: _bool
    optional_boolean: _bool
    _sum: 'ManyRequiredSumAggregateOutput'
    _avg: 'ManyRequiredAvgAggregateOutput'
    _min: 'ManyRequiredMinAggregateOutput'
    _max: 'ManyRequiredMaxAggregateOutput'
    _count: 'ManyRequiredCountAggregateOutput'


class ManyRequiredAvgAggregateOutput(TypedDict, total=False):
    """ManyRequired output for aggregating averages"""
    id: float
    one_optional_id: float
    int: float
    optional_int: float
    float: float
    optional_float: float


class ManyRequiredSumAggregateOutput(TypedDict, total=False):
    """ManyRequired output for aggregating sums"""
    id: _int
    one_optional_id: _int
    int: _int
    optional_int: _int
    float: _float
    optional_float: _float


class ManyRequiredScalarAggregateOutput(TypedDict, total=False):
    """ManyRequired output including scalar fields"""
    id: _int
    one_optional_id: _int
    int: _int
    optional_int: _int
    float: _float
    optional_float: _float
    string: _str
    optional_string: _str
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: _bool
    optional_boolean: _bool


ManyRequiredMinAggregateOutput = ManyRequiredScalarAggregateOutput
ManyRequiredMaxAggregateOutput = ManyRequiredScalarAggregateOutput


class ManyRequiredMaxAggregateInput(TypedDict, total=False):
    """ManyRequired input for aggregating by max"""
    id: bool
    one_optional_id: bool
    int: bool
    optional_int: bool
    float: bool
    optional_float: bool
    string: bool
    optional_string: bool
    enum: bool
    optional_enum: bool
    boolean: bool
    optional_boolean: bool


class ManyRequiredMinAggregateInput(TypedDict, total=False):
    """ManyRequired input for aggregating by min"""
    id: bool
    one_optional_id: bool
    int: bool
    optional_int: bool
    float: bool
    optional_float: bool
    string: bool
    optional_string: bool
    enum: bool
    optional_enum: bool
    boolean: bool
    optional_boolean: bool


class ManyRequiredNumberAggregateInput(TypedDict, total=False):
    """ManyRequired input for aggregating numbers"""
    id: bool
    one_optional_id: bool
    int: bool
    optional_int: bool
    float: bool
    optional_float: bool


ManyRequiredAvgAggregateInput = ManyRequiredNumberAggregateInput
ManyRequiredSumAggregateInput = ManyRequiredNumberAggregateInput


ManyRequiredCountAggregateInput = TypedDict(
    'ManyRequiredCountAggregateInput',
    {
        'id': bool,
        'one_optional_id': bool,
        'int': bool,
        'optional_int': bool,
        'float': bool,
        'optional_float': bool,
        'string': bool,
        'optional_string': bool,
        'enum': bool,
        'optional_enum': bool,
        'boolean': bool,
        'optional_boolean': bool,
        '_all': bool,
    },
    total=False,
)

ManyRequiredCountAggregateOutput = TypedDict(
    'ManyRequiredCountAggregateOutput',
    {
        'id': int,
        'one_optional_id': int,
        'int': int,
        'optional_int': int,
        'float': int,
        'optional_float': int,
        'string': int,
        'optional_string': int,
        'enum': int,
        'optional_enum': int,
        'boolean': int,
        'optional_boolean': int,
        '_all': int,
    },
    total=False,
)


ManyRequiredKeys = Literal[
    'id',
    'one',
    'one_optional_id',
    'int',
    'optional_int',
    'float',
    'optional_float',
    'string',
    'optional_string',
    'enum',
    'optional_enum',
    'boolean',
    'optional_boolean',
]
ManyRequiredScalarFieldKeys = Literal[
    'id',
    'one_optional_id',
    'int',
    'optional_int',
    'float',
    'optional_float',
    'string',
    'optional_string',
    'enum',
    'optional_enum',
    'boolean',
    'optional_boolean',
]
ManyRequiredScalarFieldKeysT = TypeVar('ManyRequiredScalarFieldKeysT', bound=ManyRequiredScalarFieldKeys)

ManyRequiredRelationalFieldKeys = Literal[
        'one',
    ]

# Lists types

class ListsOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Lists create method"""
    id: _str
    strings: List[_str]
    bytes: List['fields.Base64']
    dates: List[datetime.datetime]
    bools: List[_bool]
    ints: List[_int]
    floats: List[_float]
    bigints: List[_int]
    json_objects: List['fields.Json']
    decimals: List[decimal.Decimal]


class ListsCreateInput(ListsOptionalCreateInput):
    """Required arguments to the Lists create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ListsOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Lists create method, without relations"""
    id: _str
    strings: List[_str]
    bytes: List['fields.Base64']
    dates: List[datetime.datetime]
    bools: List[_bool]
    ints: List[_int]
    floats: List[_float]
    bigints: List[_int]
    json_objects: List['fields.Json']
    decimals: List[decimal.Decimal]


class ListsCreateWithoutRelationsInput(ListsOptionalCreateWithoutRelationsInput):
    """Required arguments to the Lists create method, without relations"""

class ListsConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ListsCreateWithoutRelationsInput'
    where: 'ListsWhereUniqueInput'

class ListsCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ListsCreateWithoutRelationsInput'
    connect: 'ListsWhereUniqueInput'
    connect_or_create: 'ListsConnectOrCreateWithoutRelationsInput'


class ListsCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ListsCreateWithoutRelationsInput', List['ListsCreateWithoutRelationsInput']]
    connect: Union['ListsWhereUniqueInput', List['ListsWhereUniqueInput']]
    connect_or_create: Union['ListsConnectOrCreateWithoutRelationsInput', List['ListsConnectOrCreateWithoutRelationsInput']]

_ListsWhereUnique_id_Input = TypedDict(
    '_ListsWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

ListsWhereUniqueInput = _ListsWhereUnique_id_Input


class ListsUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    strings: 'types.StringListUpdate'
    bytes: 'types.BytesListUpdate'
    dates: 'types.DateTimeListUpdate'
    bools: 'types.BooleanListUpdate'
    ints: 'types.IntListUpdate'
    floats: 'types.FloatListUpdate'
    bigints: 'types.BigIntListUpdate'
    json_objects: 'types.JsonListUpdate'
    decimals: 'types.DecimalListUpdate'


class ListsUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    strings: 'types.StringListUpdate'
    bytes: 'types.BytesListUpdate'
    dates: 'types.DateTimeListUpdate'
    bools: 'types.BooleanListUpdate'
    ints: 'types.IntListUpdate'
    floats: 'types.FloatListUpdate'
    bigints: 'types.BigIntListUpdate'
    json_objects: 'types.JsonListUpdate'
    decimals: 'types.DecimalListUpdate'


class ListsUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ListsCreateWithoutRelationsInput']
    connect: List['ListsWhereUniqueInput']
    connect_or_create: List['ListsConnectOrCreateWithoutRelationsInput']
    set: List['ListsWhereUniqueInput']
    disconnect: List['ListsWhereUniqueInput']
    delete: List['ListsWhereUniqueInput']

    # TODO
    # update: List['ListsUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ListsUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ListsScalarWhereInput']
    # upsert: List['ListsUpserteWithWhereUniqueWithoutRelationsInput']


class ListsUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ListsCreateWithoutRelationsInput'
    connect: 'ListsWhereUniqueInput'
    connect_or_create: 'ListsConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ListsUpdateInput'
    # upsert: 'ListsUpsertWithoutRelationsInput'


class ListsUpsertInput(TypedDict):
    create: 'ListsCreateInput'
    update: 'ListsUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Lists_id_OrderByInput = TypedDict(
    '_Lists_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Lists_strings_OrderByInput = TypedDict(
    '_Lists_strings_OrderByInput',
    {
        'strings': 'SortOrder',
    },
    total=True
)

_Lists_bytes_OrderByInput = TypedDict(
    '_Lists_bytes_OrderByInput',
    {
        'bytes': 'SortOrder',
    },
    total=True
)

_Lists_dates_OrderByInput = TypedDict(
    '_Lists_dates_OrderByInput',
    {
        'dates': 'SortOrder',
    },
    total=True
)

_Lists_bools_OrderByInput = TypedDict(
    '_Lists_bools_OrderByInput',
    {
        'bools': 'SortOrder',
    },
    total=True
)

_Lists_ints_OrderByInput = TypedDict(
    '_Lists_ints_OrderByInput',
    {
        'ints': 'SortOrder',
    },
    total=True
)

_Lists_floats_OrderByInput = TypedDict(
    '_Lists_floats_OrderByInput',
    {
        'floats': 'SortOrder',
    },
    total=True
)

_Lists_bigints_OrderByInput = TypedDict(
    '_Lists_bigints_OrderByInput',
    {
        'bigints': 'SortOrder',
    },
    total=True
)

_Lists_json_objects_OrderByInput = TypedDict(
    '_Lists_json_objects_OrderByInput',
    {
        'json_objects': 'SortOrder',
    },
    total=True
)

_Lists_decimals_OrderByInput = TypedDict(
    '_Lists_decimals_OrderByInput',
    {
        'decimals': 'SortOrder',
    },
    total=True
)

_Lists_RelevanceInner = TypedDict(
    '_Lists_RelevanceInner',
    {
        'fields': 'List[ListsScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Lists_RelevanceOrderByInput = TypedDict(
    '_Lists_RelevanceOrderByInput',
    {
        '_relevance': '_Lists_RelevanceInner',
    },
    total=True
)

ListsOrderByInput = Union[
    '_Lists_id_OrderByInput',
    '_Lists_strings_OrderByInput',
    '_Lists_bytes_OrderByInput',
    '_Lists_dates_OrderByInput',
    '_Lists_bools_OrderByInput',
    '_Lists_ints_OrderByInput',
    '_Lists_floats_OrderByInput',
    '_Lists_bigints_OrderByInput',
    '_Lists_json_objects_OrderByInput',
    '_Lists_decimals_OrderByInput',
    '_Lists_RelevanceOrderByInput',
]



# recursive Lists types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

ListsRelationFilter = TypedDict(
    'ListsRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class ListsListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class ListsInclude(TypedDict, total=False):
    """Lists relational arguments"""


    

class PostIncludeFromLists(TypedDict, total=False):
    """Relational arguments for Lists"""
    author: Union[bool, 'UserArgsFromListsRecursive1']


class PostIncludeFromListsRecursive1(TypedDict, total=False):
    """Relational arguments for Lists"""
    author: Union[bool, 'UserArgsFromListsRecursive2']


class PostIncludeFromListsRecursive2(TypedDict, total=False):
    """Relational arguments for Lists"""

    

class PostArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'PostIncludeFromPostRecursive1'


class PostArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'PostIncludeFromPostRecursive2'


class PostArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    
    

class FindManyPostArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPostRecursive1'


class FindManyPostArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPostRecursive2'


class FindManyPostArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    
    

class UserIncludeFromLists(TypedDict, total=False):
    """Relational arguments for Lists"""
    posts: Union[bool, 'FindManyPostArgsFromListsRecursive1']


class UserIncludeFromListsRecursive1(TypedDict, total=False):
    """Relational arguments for Lists"""
    posts: Union[bool, 'FindManyPostArgsFromListsRecursive2']


class UserIncludeFromListsRecursive2(TypedDict, total=False):
    """Relational arguments for Lists"""

    

class UserArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    
    

class FindManyUserArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class MIncludeFromLists(TypedDict, total=False):
    """Relational arguments for Lists"""
    n: Union[bool, 'FindManyNArgsFromListsRecursive1']


class MIncludeFromListsRecursive1(TypedDict, total=False):
    """Relational arguments for Lists"""
    n: Union[bool, 'FindManyNArgsFromListsRecursive2']


class MIncludeFromListsRecursive2(TypedDict, total=False):
    """Relational arguments for Lists"""

    

class MArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'MIncludeFromMRecursive1'


class MArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'MIncludeFromMRecursive2'


class MArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    
    

class FindManyMArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromMRecursive1'


class FindManyMArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromMRecursive2'


class FindManyMArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    
    

class NIncludeFromLists(TypedDict, total=False):
    """Relational arguments for Lists"""
    m: Union[bool, 'FindManyMArgsFromListsRecursive1']


class NIncludeFromListsRecursive1(TypedDict, total=False):
    """Relational arguments for Lists"""
    m: Union[bool, 'FindManyMArgsFromListsRecursive2']


class NIncludeFromListsRecursive2(TypedDict, total=False):
    """Relational arguments for Lists"""

    

class NArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'NIncludeFromNRecursive1'


class NArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'NIncludeFromNRecursive2'


class NArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    
    

class FindManyNArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromNRecursive1'


class FindManyNArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromNRecursive2'


class FindManyNArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    
    

class OneOptionalIncludeFromLists(TypedDict, total=False):
    """Relational arguments for Lists"""
    many: Union[bool, 'FindManyManyRequiredArgsFromListsRecursive1']


class OneOptionalIncludeFromListsRecursive1(TypedDict, total=False):
    """Relational arguments for Lists"""
    many: Union[bool, 'FindManyManyRequiredArgsFromListsRecursive2']


class OneOptionalIncludeFromListsRecursive2(TypedDict, total=False):
    """Relational arguments for Lists"""

    

class OneOptionalArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'OneOptionalIncludeFromOneOptionalRecursive1'


class OneOptionalArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'OneOptionalIncludeFromOneOptionalRecursive2'


class OneOptionalArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    
    

class FindManyOneOptionalArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromOneOptionalRecursive1'


class FindManyOneOptionalArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromOneOptionalRecursive2'


class FindManyOneOptionalArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    
    

class ManyRequiredIncludeFromLists(TypedDict, total=False):
    """Relational arguments for Lists"""
    one: Union[bool, 'OneOptionalArgsFromListsRecursive1']


class ManyRequiredIncludeFromListsRecursive1(TypedDict, total=False):
    """Relational arguments for Lists"""
    one: Union[bool, 'OneOptionalArgsFromListsRecursive2']


class ManyRequiredIncludeFromListsRecursive2(TypedDict, total=False):
    """Relational arguments for Lists"""

    

class ManyRequiredArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'ManyRequiredIncludeFromManyRequiredRecursive1'


class ManyRequiredArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'ManyRequiredIncludeFromManyRequiredRecursive2'


class ManyRequiredArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    
    

class FindManyManyRequiredArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromManyRequiredRecursive1'


class FindManyManyRequiredArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromManyRequiredRecursive2'


class FindManyManyRequiredArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    
    

class ListsIncludeFromLists(TypedDict, total=False):
    """Relational arguments for Lists"""


class ListsIncludeFromListsRecursive1(TypedDict, total=False):
    """Relational arguments for Lists"""


class ListsIncludeFromListsRecursive2(TypedDict, total=False):
    """Relational arguments for Lists"""

    

class ListsArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'ListsIncludeFromListsRecursive1'


class ListsArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'ListsIncludeFromListsRecursive2'


class ListsArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    
    

class FindManyListsArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromListsRecursive1'


class FindManyListsArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromListsRecursive2'


class FindManyListsArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    
    

class AIncludeFromLists(TypedDict, total=False):
    """Relational arguments for Lists"""


class AIncludeFromListsRecursive1(TypedDict, total=False):
    """Relational arguments for Lists"""


class AIncludeFromListsRecursive2(TypedDict, total=False):
    """Relational arguments for Lists"""

    

class AArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'AIncludeFromARecursive1'


class AArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'AIncludeFromARecursive2'


class AArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    
    

class FindManyAArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromARecursive1'


class FindManyAArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromARecursive2'


class FindManyAArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    
    

class BIncludeFromLists(TypedDict, total=False):
    """Relational arguments for Lists"""


class BIncludeFromListsRecursive1(TypedDict, total=False):
    """Relational arguments for Lists"""


class BIncludeFromListsRecursive2(TypedDict, total=False):
    """Relational arguments for Lists"""

    

class BArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'BIncludeFromBRecursive1'


class BArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'BIncludeFromBRecursive2'


class BArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    
    

class FindManyBArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromBRecursive1'


class FindManyBArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromBRecursive2'


class FindManyBArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    
    

class CIncludeFromLists(TypedDict, total=False):
    """Relational arguments for Lists"""


class CIncludeFromListsRecursive1(TypedDict, total=False):
    """Relational arguments for Lists"""


class CIncludeFromListsRecursive2(TypedDict, total=False):
    """Relational arguments for Lists"""

    

class CArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'CIncludeFromCRecursive1'


class CArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'CIncludeFromCRecursive2'


class CArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    
    

class FindManyCArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromCRecursive1'


class FindManyCArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromCRecursive2'


class FindManyCArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    
    

class DIncludeFromLists(TypedDict, total=False):
    """Relational arguments for Lists"""


class DIncludeFromListsRecursive1(TypedDict, total=False):
    """Relational arguments for Lists"""


class DIncludeFromListsRecursive2(TypedDict, total=False):
    """Relational arguments for Lists"""

    

class DArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'DIncludeFromDRecursive1'


class DArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'DIncludeFromDRecursive2'


class DArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    
    

class FindManyDArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromDRecursive1'


class FindManyDArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromDRecursive2'


class FindManyDArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    
    

class EIncludeFromLists(TypedDict, total=False):
    """Relational arguments for Lists"""


class EIncludeFromListsRecursive1(TypedDict, total=False):
    """Relational arguments for Lists"""


class EIncludeFromListsRecursive2(TypedDict, total=False):
    """Relational arguments for Lists"""

    

class EArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'EIncludeFromERecursive1'


class EArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'EIncludeFromERecursive2'


class EArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    
    

class FindManyEArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromERecursive1'


class FindManyEArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromERecursive2'


class FindManyEArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    


FindManyListsArgs = FindManyListsArgsFromLists
FindFirstListsArgs = FindManyListsArgsFromLists


    

class ListsWhereInput(TypedDict, total=False):
    """Lists arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    strings: 'types.StringListFilter'
    bytes: 'types.BytesListFilter'
    dates: 'types.DateTimeListFilter'
    bools: 'types.BooleanListFilter'
    ints: 'types.IntListFilter'
    floats: 'types.FloatListFilter'
    bigints: 'types.BigIntListFilter'
    json_objects: 'types.JsonListFilter'
    decimals: 'types.DecimalListFilter'

    # should be noted that AND and NOT should be Union['ListsWhereInputRecursive1', List['ListsWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['ListsWhereInputRecursive1']
    OR: List['ListsWhereInputRecursive1']
    NOT: List['ListsWhereInputRecursive1']


class ListsWhereInputRecursive1(TypedDict, total=False):
    """Lists arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    strings: 'types.StringListFilter'
    bytes: 'types.BytesListFilter'
    dates: 'types.DateTimeListFilter'
    bools: 'types.BooleanListFilter'
    ints: 'types.IntListFilter'
    floats: 'types.FloatListFilter'
    bigints: 'types.BigIntListFilter'
    json_objects: 'types.JsonListFilter'
    decimals: 'types.DecimalListFilter'

    # should be noted that AND and NOT should be Union['ListsWhereInputRecursive2', List['ListsWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['ListsWhereInputRecursive2']
    OR: List['ListsWhereInputRecursive2']
    NOT: List['ListsWhereInputRecursive2']


class ListsWhereInputRecursive2(TypedDict, total=False):
    """Lists arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    strings: 'types.StringListFilter'
    bytes: 'types.BytesListFilter'
    dates: 'types.DateTimeListFilter'
    bools: 'types.BooleanListFilter'
    ints: 'types.IntListFilter'
    floats: 'types.FloatListFilter'
    bigints: 'types.BigIntListFilter'
    json_objects: 'types.JsonListFilter'
    decimals: 'types.DecimalListFilter'



# aggregate Lists types


    

class ListsScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Lists arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    strings: Union[_str, 'types.StringWithAggregatesFilter']
    bytes: Union['fields.Base64', 'types.BytesWithAggregatesFilter']
    dates: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    bools: Union[_bool, 'types.BooleanWithAggregatesFilter']
    ints: Union[_int, 'types.IntWithAggregatesFilter']
    floats: Union[_float, 'types.FloatWithAggregatesFilter']
    bigints: Union[_int, 'types.BigIntWithAggregatesFilter']
    json_objects: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    decimals: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']

    AND: List['ListsScalarWhereWithAggregatesInputRecursive1']
    OR: List['ListsScalarWhereWithAggregatesInputRecursive1']
    NOT: List['ListsScalarWhereWithAggregatesInputRecursive1']


class ListsScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Lists arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    strings: Union[_str, 'types.StringWithAggregatesFilter']
    bytes: Union['fields.Base64', 'types.BytesWithAggregatesFilter']
    dates: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    bools: Union[_bool, 'types.BooleanWithAggregatesFilter']
    ints: Union[_int, 'types.IntWithAggregatesFilter']
    floats: Union[_float, 'types.FloatWithAggregatesFilter']
    bigints: Union[_int, 'types.BigIntWithAggregatesFilter']
    json_objects: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    decimals: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']

    AND: List['ListsScalarWhereWithAggregatesInputRecursive2']
    OR: List['ListsScalarWhereWithAggregatesInputRecursive2']
    NOT: List['ListsScalarWhereWithAggregatesInputRecursive2']


class ListsScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Lists arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    strings: Union[_str, 'types.StringWithAggregatesFilter']
    bytes: Union['fields.Base64', 'types.BytesWithAggregatesFilter']
    dates: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    bools: Union[_bool, 'types.BooleanWithAggregatesFilter']
    ints: Union[_int, 'types.IntWithAggregatesFilter']
    floats: Union[_float, 'types.FloatWithAggregatesFilter']
    bigints: Union[_int, 'types.BigIntWithAggregatesFilter']
    json_objects: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    decimals: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']



class ListsGroupByOutput(TypedDict, total=False):
    id: _str
    strings: List[_str]
    bytes: List['fields.Base64']
    dates: List[datetime.datetime]
    bools: List[_bool]
    ints: List[_int]
    floats: List[_float]
    bigints: List[_int]
    json_objects: List['fields.Json']
    decimals: List[decimal.Decimal]
    _sum: 'ListsSumAggregateOutput'
    _avg: 'ListsAvgAggregateOutput'
    _min: 'ListsMinAggregateOutput'
    _max: 'ListsMaxAggregateOutput'
    _count: 'ListsCountAggregateOutput'


class ListsAvgAggregateOutput(TypedDict, total=False):
    """Lists output for aggregating averages"""
    ints: float
    floats: float
    bigints: float


class ListsSumAggregateOutput(TypedDict, total=False):
    """Lists output for aggregating sums"""
    ints: List[_int]
    floats: List[_float]
    bigints: List[_int]


class ListsScalarAggregateOutput(TypedDict, total=False):
    """Lists output including scalar fields"""
    id: _str
    strings: List[_str]
    bytes: List['fields.Base64']
    dates: List[datetime.datetime]
    bools: List[_bool]
    ints: List[_int]
    floats: List[_float]
    bigints: List[_int]
    json_objects: List['fields.Json']
    decimals: List[decimal.Decimal]


ListsMinAggregateOutput = ListsScalarAggregateOutput
ListsMaxAggregateOutput = ListsScalarAggregateOutput


class ListsMaxAggregateInput(TypedDict, total=False):
    """Lists input for aggregating by max"""
    id: bool
    strings: bool
    bytes: bool
    dates: bool
    bools: bool
    ints: bool
    floats: bool
    bigints: bool
    json_objects: bool
    decimals: bool


class ListsMinAggregateInput(TypedDict, total=False):
    """Lists input for aggregating by min"""
    id: bool
    strings: bool
    bytes: bool
    dates: bool
    bools: bool
    ints: bool
    floats: bool
    bigints: bool
    json_objects: bool
    decimals: bool


class ListsNumberAggregateInput(TypedDict, total=False):
    """Lists input for aggregating numbers"""
    ints: bool
    floats: bool
    bigints: bool


ListsAvgAggregateInput = ListsNumberAggregateInput
ListsSumAggregateInput = ListsNumberAggregateInput


ListsCountAggregateInput = TypedDict(
    'ListsCountAggregateInput',
    {
        'id': bool,
        'strings': bool,
        'bytes': bool,
        'dates': bool,
        'bools': bool,
        'ints': bool,
        'floats': bool,
        'bigints': bool,
        'json_objects': bool,
        'decimals': bool,
        '_all': bool,
    },
    total=False,
)

ListsCountAggregateOutput = TypedDict(
    'ListsCountAggregateOutput',
    {
        'id': int,
        'strings': int,
        'bytes': int,
        'dates': int,
        'bools': int,
        'ints': int,
        'floats': int,
        'bigints': int,
        'json_objects': int,
        'decimals': int,
        '_all': int,
    },
    total=False,
)


ListsKeys = Literal[
    'id',
    'strings',
    'bytes',
    'dates',
    'bools',
    'ints',
    'floats',
    'bigints',
    'json_objects',
    'decimals',
]
ListsScalarFieldKeys = Literal[
    'id',
    'strings',
    'bytes',
    'dates',
    'bools',
    'ints',
    'floats',
    'bigints',
    'json_objects',
    'decimals',
]
ListsScalarFieldKeysT = TypeVar('ListsScalarFieldKeysT', bound=ListsScalarFieldKeys)

ListsRelationalFieldKeys = _NoneType

# A types

class AOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the A create method"""
    name: Optional[_str]
    inc_int: _int
    inc_sInt: _int
    inc_bInt: _int
    enum: 'enums.ABeautifulEnum'


class ACreateInput(AOptionalCreateInput):
    """Required arguments to the A create method"""
    email: _str
    int: _int
    sInt: _int
    bInt: _int


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class AOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the A create method, without relations"""
    name: Optional[_str]
    inc_int: _int
    inc_sInt: _int
    inc_bInt: _int
    enum: 'enums.ABeautifulEnum'


class ACreateWithoutRelationsInput(AOptionalCreateWithoutRelationsInput):
    """Required arguments to the A create method, without relations"""
    email: _str
    int: _int
    sInt: _int
    bInt: _int

class AConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ACreateWithoutRelationsInput'
    where: 'AWhereUniqueInput'

class ACreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ACreateWithoutRelationsInput'
    connect: 'AWhereUniqueInput'
    connect_or_create: 'AConnectOrCreateWithoutRelationsInput'


class ACreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ACreateWithoutRelationsInput', List['ACreateWithoutRelationsInput']]
    connect: Union['AWhereUniqueInput', List['AWhereUniqueInput']]
    connect_or_create: Union['AConnectOrCreateWithoutRelationsInput', List['AConnectOrCreateWithoutRelationsInput']]

_AWhereUnique_email_Input = TypedDict(
    '_AWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

_ACompoundname_email_enumKeyInner = TypedDict(
    '_ACompoundname_email_enumKeyInner',
    {
        'name': '_str',
        'email': '_str',
        'enum': 'enums.ABeautifulEnum',
    },
    total=True
)

_ACompoundname_email_enumKey = TypedDict(
    '_ACompoundname_email_enumKey',
    {
        'name_email_enum': '_ACompoundname_email_enumKeyInner',
    },
    total=True
)

AWhereUniqueInput = Union[
    '_AWhereUnique_email_Input',
    '_ACompoundname_email_enumKey',
]


class AUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    email: _str
    name: Optional[_str]
    int: Union[AtomicIntInput, _int]
    sInt: Union[AtomicIntInput, _int]
    inc_int: Union[AtomicIntInput, _int]
    inc_sInt: Union[AtomicIntInput, _int]
    bInt: Union[AtomicBigIntInput, _int]
    inc_bInt: Union[AtomicBigIntInput, _int]
    enum: 'enums.ABeautifulEnum'


class AUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    email: _str
    name: Optional[_str]
    int: Union[AtomicIntInput, _int]
    sInt: Union[AtomicIntInput, _int]
    inc_int: Union[AtomicIntInput, _int]
    inc_sInt: Union[AtomicIntInput, _int]
    bInt: Union[AtomicBigIntInput, _int]
    inc_bInt: Union[AtomicBigIntInput, _int]
    enum: 'enums.ABeautifulEnum'


class AUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ACreateWithoutRelationsInput']
    connect: List['AWhereUniqueInput']
    connect_or_create: List['AConnectOrCreateWithoutRelationsInput']
    set: List['AWhereUniqueInput']
    disconnect: List['AWhereUniqueInput']
    delete: List['AWhereUniqueInput']

    # TODO
    # update: List['AUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['AUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['AScalarWhereInput']
    # upsert: List['AUpserteWithWhereUniqueWithoutRelationsInput']


class AUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ACreateWithoutRelationsInput'
    connect: 'AWhereUniqueInput'
    connect_or_create: 'AConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'AUpdateInput'
    # upsert: 'AUpsertWithoutRelationsInput'


class AUpsertInput(TypedDict):
    create: 'ACreateInput'
    update: 'AUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_A_email_OrderByInput = TypedDict(
    '_A_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_A_name_OrderByInput = TypedDict(
    '_A_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_A_int_OrderByInput = TypedDict(
    '_A_int_OrderByInput',
    {
        'int': 'SortOrder',
    },
    total=True
)

_A_sInt_OrderByInput = TypedDict(
    '_A_sInt_OrderByInput',
    {
        'sInt': 'SortOrder',
    },
    total=True
)

_A_inc_int_OrderByInput = TypedDict(
    '_A_inc_int_OrderByInput',
    {
        'inc_int': 'SortOrder',
    },
    total=True
)

_A_inc_sInt_OrderByInput = TypedDict(
    '_A_inc_sInt_OrderByInput',
    {
        'inc_sInt': 'SortOrder',
    },
    total=True
)

_A_bInt_OrderByInput = TypedDict(
    '_A_bInt_OrderByInput',
    {
        'bInt': 'SortOrder',
    },
    total=True
)

_A_inc_bInt_OrderByInput = TypedDict(
    '_A_inc_bInt_OrderByInput',
    {
        'inc_bInt': 'SortOrder',
    },
    total=True
)

_A_enum_OrderByInput = TypedDict(
    '_A_enum_OrderByInput',
    {
        'enum': 'SortOrder',
    },
    total=True
)

_A_RelevanceInner = TypedDict(
    '_A_RelevanceInner',
    {
        'fields': 'List[AScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_A_RelevanceOrderByInput = TypedDict(
    '_A_RelevanceOrderByInput',
    {
        '_relevance': '_A_RelevanceInner',
    },
    total=True
)

AOrderByInput = Union[
    '_A_email_OrderByInput',
    '_A_name_OrderByInput',
    '_A_int_OrderByInput',
    '_A_sInt_OrderByInput',
    '_A_inc_int_OrderByInput',
    '_A_inc_sInt_OrderByInput',
    '_A_bInt_OrderByInput',
    '_A_inc_bInt_OrderByInput',
    '_A_enum_OrderByInput',
    '_A_RelevanceOrderByInput',
]



# recursive A types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

ARelationFilter = TypedDict(
    'ARelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class AListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class AInclude(TypedDict, total=False):
    """A relational arguments"""


    

class PostIncludeFromA(TypedDict, total=False):
    """Relational arguments for A"""
    author: Union[bool, 'UserArgsFromARecursive1']


class PostIncludeFromARecursive1(TypedDict, total=False):
    """Relational arguments for A"""
    author: Union[bool, 'UserArgsFromARecursive2']


class PostIncludeFromARecursive2(TypedDict, total=False):
    """Relational arguments for A"""

    

class PostArgsFromA(TypedDict, total=False):
    """Arguments for A"""
    include: 'PostIncludeFromPostRecursive1'


class PostArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""
    include: 'PostIncludeFromPostRecursive2'


class PostArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""
    
    

class FindManyPostArgsFromA(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPostRecursive1'


class FindManyPostArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPostRecursive2'


class FindManyPostArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    
    

class UserIncludeFromA(TypedDict, total=False):
    """Relational arguments for A"""
    posts: Union[bool, 'FindManyPostArgsFromARecursive1']


class UserIncludeFromARecursive1(TypedDict, total=False):
    """Relational arguments for A"""
    posts: Union[bool, 'FindManyPostArgsFromARecursive2']


class UserIncludeFromARecursive2(TypedDict, total=False):
    """Relational arguments for A"""

    

class UserArgsFromA(TypedDict, total=False):
    """Arguments for A"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""
    
    

class FindManyUserArgsFromA(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class MIncludeFromA(TypedDict, total=False):
    """Relational arguments for A"""
    n: Union[bool, 'FindManyNArgsFromARecursive1']


class MIncludeFromARecursive1(TypedDict, total=False):
    """Relational arguments for A"""
    n: Union[bool, 'FindManyNArgsFromARecursive2']


class MIncludeFromARecursive2(TypedDict, total=False):
    """Relational arguments for A"""

    

class MArgsFromA(TypedDict, total=False):
    """Arguments for A"""
    include: 'MIncludeFromMRecursive1'


class MArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""
    include: 'MIncludeFromMRecursive2'


class MArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""
    
    

class FindManyMArgsFromA(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromMRecursive1'


class FindManyMArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromMRecursive2'


class FindManyMArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    
    

class NIncludeFromA(TypedDict, total=False):
    """Relational arguments for A"""
    m: Union[bool, 'FindManyMArgsFromARecursive1']


class NIncludeFromARecursive1(TypedDict, total=False):
    """Relational arguments for A"""
    m: Union[bool, 'FindManyMArgsFromARecursive2']


class NIncludeFromARecursive2(TypedDict, total=False):
    """Relational arguments for A"""

    

class NArgsFromA(TypedDict, total=False):
    """Arguments for A"""
    include: 'NIncludeFromNRecursive1'


class NArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""
    include: 'NIncludeFromNRecursive2'


class NArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""
    
    

class FindManyNArgsFromA(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromNRecursive1'


class FindManyNArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromNRecursive2'


class FindManyNArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    
    

class OneOptionalIncludeFromA(TypedDict, total=False):
    """Relational arguments for A"""
    many: Union[bool, 'FindManyManyRequiredArgsFromARecursive1']


class OneOptionalIncludeFromARecursive1(TypedDict, total=False):
    """Relational arguments for A"""
    many: Union[bool, 'FindManyManyRequiredArgsFromARecursive2']


class OneOptionalIncludeFromARecursive2(TypedDict, total=False):
    """Relational arguments for A"""

    

class OneOptionalArgsFromA(TypedDict, total=False):
    """Arguments for A"""
    include: 'OneOptionalIncludeFromOneOptionalRecursive1'


class OneOptionalArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""
    include: 'OneOptionalIncludeFromOneOptionalRecursive2'


class OneOptionalArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""
    
    

class FindManyOneOptionalArgsFromA(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromOneOptionalRecursive1'


class FindManyOneOptionalArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromOneOptionalRecursive2'


class FindManyOneOptionalArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    
    

class ManyRequiredIncludeFromA(TypedDict, total=False):
    """Relational arguments for A"""
    one: Union[bool, 'OneOptionalArgsFromARecursive1']


class ManyRequiredIncludeFromARecursive1(TypedDict, total=False):
    """Relational arguments for A"""
    one: Union[bool, 'OneOptionalArgsFromARecursive2']


class ManyRequiredIncludeFromARecursive2(TypedDict, total=False):
    """Relational arguments for A"""

    

class ManyRequiredArgsFromA(TypedDict, total=False):
    """Arguments for A"""
    include: 'ManyRequiredIncludeFromManyRequiredRecursive1'


class ManyRequiredArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""
    include: 'ManyRequiredIncludeFromManyRequiredRecursive2'


class ManyRequiredArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""
    
    

class FindManyManyRequiredArgsFromA(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromManyRequiredRecursive1'


class FindManyManyRequiredArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromManyRequiredRecursive2'


class FindManyManyRequiredArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    
    

class ListsIncludeFromA(TypedDict, total=False):
    """Relational arguments for A"""


class ListsIncludeFromARecursive1(TypedDict, total=False):
    """Relational arguments for A"""


class ListsIncludeFromARecursive2(TypedDict, total=False):
    """Relational arguments for A"""

    

class ListsArgsFromA(TypedDict, total=False):
    """Arguments for A"""
    include: 'ListsIncludeFromListsRecursive1'


class ListsArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""
    include: 'ListsIncludeFromListsRecursive2'


class ListsArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""
    
    

class FindManyListsArgsFromA(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromListsRecursive1'


class FindManyListsArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromListsRecursive2'


class FindManyListsArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    
    

class AIncludeFromA(TypedDict, total=False):
    """Relational arguments for A"""


class AIncludeFromARecursive1(TypedDict, total=False):
    """Relational arguments for A"""


class AIncludeFromARecursive2(TypedDict, total=False):
    """Relational arguments for A"""

    

class AArgsFromA(TypedDict, total=False):
    """Arguments for A"""
    include: 'AIncludeFromARecursive1'


class AArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""
    include: 'AIncludeFromARecursive2'


class AArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""
    
    

class FindManyAArgsFromA(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromARecursive1'


class FindManyAArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromARecursive2'


class FindManyAArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    
    

class BIncludeFromA(TypedDict, total=False):
    """Relational arguments for A"""


class BIncludeFromARecursive1(TypedDict, total=False):
    """Relational arguments for A"""


class BIncludeFromARecursive2(TypedDict, total=False):
    """Relational arguments for A"""

    

class BArgsFromA(TypedDict, total=False):
    """Arguments for A"""
    include: 'BIncludeFromBRecursive1'


class BArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""
    include: 'BIncludeFromBRecursive2'


class BArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""
    
    

class FindManyBArgsFromA(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromBRecursive1'


class FindManyBArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromBRecursive2'


class FindManyBArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    
    

class CIncludeFromA(TypedDict, total=False):
    """Relational arguments for A"""


class CIncludeFromARecursive1(TypedDict, total=False):
    """Relational arguments for A"""


class CIncludeFromARecursive2(TypedDict, total=False):
    """Relational arguments for A"""

    

class CArgsFromA(TypedDict, total=False):
    """Arguments for A"""
    include: 'CIncludeFromCRecursive1'


class CArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""
    include: 'CIncludeFromCRecursive2'


class CArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""
    
    

class FindManyCArgsFromA(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromCRecursive1'


class FindManyCArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromCRecursive2'


class FindManyCArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    
    

class DIncludeFromA(TypedDict, total=False):
    """Relational arguments for A"""


class DIncludeFromARecursive1(TypedDict, total=False):
    """Relational arguments for A"""


class DIncludeFromARecursive2(TypedDict, total=False):
    """Relational arguments for A"""

    

class DArgsFromA(TypedDict, total=False):
    """Arguments for A"""
    include: 'DIncludeFromDRecursive1'


class DArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""
    include: 'DIncludeFromDRecursive2'


class DArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""
    
    

class FindManyDArgsFromA(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromDRecursive1'


class FindManyDArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromDRecursive2'


class FindManyDArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    
    

class EIncludeFromA(TypedDict, total=False):
    """Relational arguments for A"""


class EIncludeFromARecursive1(TypedDict, total=False):
    """Relational arguments for A"""


class EIncludeFromARecursive2(TypedDict, total=False):
    """Relational arguments for A"""

    

class EArgsFromA(TypedDict, total=False):
    """Arguments for A"""
    include: 'EIncludeFromERecursive1'


class EArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""
    include: 'EIncludeFromERecursive2'


class EArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""
    
    

class FindManyEArgsFromA(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromERecursive1'


class FindManyEArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromERecursive2'


class FindManyEArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    


FindManyAArgs = FindManyAArgsFromA
FindFirstAArgs = FindManyAArgsFromA


    

class AWhereInput(TypedDict, total=False):
    """A arguments for searching"""
    email: Union[_str, 'types.StringFilter']
    name: Union[None, _str, 'types.StringFilter']
    int: Union[_int, 'types.IntFilter']
    sInt: Union[_int, 'types.IntFilter']
    inc_int: Union[_int, 'types.IntFilter']
    inc_sInt: Union[_int, 'types.IntFilter']
    bInt: Union[_int, 'types.BigIntFilter']
    inc_bInt: Union[_int, 'types.BigIntFilter']
    enum: 'enums.ABeautifulEnum'

    # should be noted that AND and NOT should be Union['AWhereInputRecursive1', List['AWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['AWhereInputRecursive1']
    OR: List['AWhereInputRecursive1']
    NOT: List['AWhereInputRecursive1']


class AWhereInputRecursive1(TypedDict, total=False):
    """A arguments for searching"""
    email: Union[_str, 'types.StringFilter']
    name: Union[None, _str, 'types.StringFilter']
    int: Union[_int, 'types.IntFilter']
    sInt: Union[_int, 'types.IntFilter']
    inc_int: Union[_int, 'types.IntFilter']
    inc_sInt: Union[_int, 'types.IntFilter']
    bInt: Union[_int, 'types.BigIntFilter']
    inc_bInt: Union[_int, 'types.BigIntFilter']
    enum: 'enums.ABeautifulEnum'

    # should be noted that AND and NOT should be Union['AWhereInputRecursive2', List['AWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['AWhereInputRecursive2']
    OR: List['AWhereInputRecursive2']
    NOT: List['AWhereInputRecursive2']


class AWhereInputRecursive2(TypedDict, total=False):
    """A arguments for searching"""
    email: Union[_str, 'types.StringFilter']
    name: Union[None, _str, 'types.StringFilter']
    int: Union[_int, 'types.IntFilter']
    sInt: Union[_int, 'types.IntFilter']
    inc_int: Union[_int, 'types.IntFilter']
    inc_sInt: Union[_int, 'types.IntFilter']
    bInt: Union[_int, 'types.BigIntFilter']
    inc_bInt: Union[_int, 'types.BigIntFilter']
    enum: 'enums.ABeautifulEnum'



# aggregate A types


    

class AScalarWhereWithAggregatesInput(TypedDict, total=False):
    """A arguments for searching"""
    email: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    sInt: Union[_int, 'types.IntWithAggregatesFilter']
    inc_int: Union[_int, 'types.IntWithAggregatesFilter']
    inc_sInt: Union[_int, 'types.IntWithAggregatesFilter']
    bInt: Union[_int, 'types.BigIntWithAggregatesFilter']
    inc_bInt: Union[_int, 'types.BigIntWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'

    AND: List['AScalarWhereWithAggregatesInputRecursive1']
    OR: List['AScalarWhereWithAggregatesInputRecursive1']
    NOT: List['AScalarWhereWithAggregatesInputRecursive1']


class AScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """A arguments for searching"""
    email: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    sInt: Union[_int, 'types.IntWithAggregatesFilter']
    inc_int: Union[_int, 'types.IntWithAggregatesFilter']
    inc_sInt: Union[_int, 'types.IntWithAggregatesFilter']
    bInt: Union[_int, 'types.BigIntWithAggregatesFilter']
    inc_bInt: Union[_int, 'types.BigIntWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'

    AND: List['AScalarWhereWithAggregatesInputRecursive2']
    OR: List['AScalarWhereWithAggregatesInputRecursive2']
    NOT: List['AScalarWhereWithAggregatesInputRecursive2']


class AScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """A arguments for searching"""
    email: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    sInt: Union[_int, 'types.IntWithAggregatesFilter']
    inc_int: Union[_int, 'types.IntWithAggregatesFilter']
    inc_sInt: Union[_int, 'types.IntWithAggregatesFilter']
    bInt: Union[_int, 'types.BigIntWithAggregatesFilter']
    inc_bInt: Union[_int, 'types.BigIntWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'



class AGroupByOutput(TypedDict, total=False):
    email: _str
    name: _str
    int: _int
    sInt: _int
    inc_int: _int
    inc_sInt: _int
    bInt: _int
    inc_bInt: _int
    enum: 'enums.ABeautifulEnum'
    _sum: 'ASumAggregateOutput'
    _avg: 'AAvgAggregateOutput'
    _min: 'AMinAggregateOutput'
    _max: 'AMaxAggregateOutput'
    _count: 'ACountAggregateOutput'


class AAvgAggregateOutput(TypedDict, total=False):
    """A output for aggregating averages"""
    int: float
    sInt: float
    inc_int: float
    inc_sInt: float
    bInt: float
    inc_bInt: float


class ASumAggregateOutput(TypedDict, total=False):
    """A output for aggregating sums"""
    int: _int
    sInt: _int
    inc_int: _int
    inc_sInt: _int
    bInt: _int
    inc_bInt: _int


class AScalarAggregateOutput(TypedDict, total=False):
    """A output including scalar fields"""
    email: _str
    name: _str
    int: _int
    sInt: _int
    inc_int: _int
    inc_sInt: _int
    bInt: _int
    inc_bInt: _int
    enum: 'enums.ABeautifulEnum'


AMinAggregateOutput = AScalarAggregateOutput
AMaxAggregateOutput = AScalarAggregateOutput


class AMaxAggregateInput(TypedDict, total=False):
    """A input for aggregating by max"""
    email: bool
    name: bool
    int: bool
    sInt: bool
    inc_int: bool
    inc_sInt: bool
    bInt: bool
    inc_bInt: bool
    enum: bool


class AMinAggregateInput(TypedDict, total=False):
    """A input for aggregating by min"""
    email: bool
    name: bool
    int: bool
    sInt: bool
    inc_int: bool
    inc_sInt: bool
    bInt: bool
    inc_bInt: bool
    enum: bool


class ANumberAggregateInput(TypedDict, total=False):
    """A input for aggregating numbers"""
    int: bool
    sInt: bool
    inc_int: bool
    inc_sInt: bool
    bInt: bool
    inc_bInt: bool


AAvgAggregateInput = ANumberAggregateInput
ASumAggregateInput = ANumberAggregateInput


ACountAggregateInput = TypedDict(
    'ACountAggregateInput',
    {
        'email': bool,
        'name': bool,
        'int': bool,
        'sInt': bool,
        'inc_int': bool,
        'inc_sInt': bool,
        'bInt': bool,
        'inc_bInt': bool,
        'enum': bool,
        '_all': bool,
    },
    total=False,
)

ACountAggregateOutput = TypedDict(
    'ACountAggregateOutput',
    {
        'email': int,
        'name': int,
        'int': int,
        'sInt': int,
        'inc_int': int,
        'inc_sInt': int,
        'bInt': int,
        'inc_bInt': int,
        'enum': int,
        '_all': int,
    },
    total=False,
)


AKeys = Literal[
    'email',
    'name',
    'int',
    'sInt',
    'inc_int',
    'inc_sInt',
    'bInt',
    'inc_bInt',
    'enum',
]
AScalarFieldKeys = Literal[
    'email',
    'name',
    'int',
    'sInt',
    'inc_int',
    'inc_sInt',
    'bInt',
    'inc_bInt',
    'enum',
]
AScalarFieldKeysT = TypeVar('AScalarFieldKeysT', bound=AScalarFieldKeys)

ARelationalFieldKeys = _NoneType

# B types

class BOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the B create method"""
    id: _str


class BCreateInput(BOptionalCreateInput):
    """Required arguments to the B create method"""
    float: _float
    d_float: _float
    decFloat: decimal.Decimal
    numFloat: decimal.Decimal


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class BOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the B create method, without relations"""
    id: _str


class BCreateWithoutRelationsInput(BOptionalCreateWithoutRelationsInput):
    """Required arguments to the B create method, without relations"""
    float: _float
    d_float: _float
    decFloat: decimal.Decimal
    numFloat: decimal.Decimal

class BConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'BCreateWithoutRelationsInput'
    where: 'BWhereUniqueInput'

class BCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'BCreateWithoutRelationsInput'
    connect: 'BWhereUniqueInput'
    connect_or_create: 'BConnectOrCreateWithoutRelationsInput'


class BCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['BCreateWithoutRelationsInput', List['BCreateWithoutRelationsInput']]
    connect: Union['BWhereUniqueInput', List['BWhereUniqueInput']]
    connect_or_create: Union['BConnectOrCreateWithoutRelationsInput', List['BConnectOrCreateWithoutRelationsInput']]

_BWhereUnique_id_Input = TypedDict(
    '_BWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_BCompoundmy_constraintKeyInner = TypedDict(
    '_BCompoundmy_constraintKeyInner',
    {
        'float': '_float',
        'd_float': '_float',
    },
    total=True
)

_BCompoundmy_constraintKey = TypedDict(
    '_BCompoundmy_constraintKey',
    {
        'my_constraint': '_BCompoundmy_constraintKeyInner',
    },
    total=True
)

BWhereUniqueInput = Union[
    '_BWhereUnique_id_Input',
    '_BCompoundmy_constraintKey',
]


class BUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    float: Union[AtomicFloatInput, _float]
    d_float: Union[AtomicFloatInput, _float]
    decFloat: decimal.Decimal
    numFloat: decimal.Decimal


class BUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    float: Union[AtomicFloatInput, _float]
    d_float: Union[AtomicFloatInput, _float]
    decFloat: decimal.Decimal
    numFloat: decimal.Decimal


class BUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['BCreateWithoutRelationsInput']
    connect: List['BWhereUniqueInput']
    connect_or_create: List['BConnectOrCreateWithoutRelationsInput']
    set: List['BWhereUniqueInput']
    disconnect: List['BWhereUniqueInput']
    delete: List['BWhereUniqueInput']

    # TODO
    # update: List['BUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['BUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['BScalarWhereInput']
    # upsert: List['BUpserteWithWhereUniqueWithoutRelationsInput']


class BUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'BCreateWithoutRelationsInput'
    connect: 'BWhereUniqueInput'
    connect_or_create: 'BConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'BUpdateInput'
    # upsert: 'BUpsertWithoutRelationsInput'


class BUpsertInput(TypedDict):
    create: 'BCreateInput'
    update: 'BUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_B_id_OrderByInput = TypedDict(
    '_B_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_B_float_OrderByInput = TypedDict(
    '_B_float_OrderByInput',
    {
        'float': 'SortOrder',
    },
    total=True
)

_B_d_float_OrderByInput = TypedDict(
    '_B_d_float_OrderByInput',
    {
        'd_float': 'SortOrder',
    },
    total=True
)

_B_decFloat_OrderByInput = TypedDict(
    '_B_decFloat_OrderByInput',
    {
        'decFloat': 'SortOrder',
    },
    total=True
)

_B_numFloat_OrderByInput = TypedDict(
    '_B_numFloat_OrderByInput',
    {
        'numFloat': 'SortOrder',
    },
    total=True
)

_B_RelevanceInner = TypedDict(
    '_B_RelevanceInner',
    {
        'fields': 'List[BScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_B_RelevanceOrderByInput = TypedDict(
    '_B_RelevanceOrderByInput',
    {
        '_relevance': '_B_RelevanceInner',
    },
    total=True
)

BOrderByInput = Union[
    '_B_id_OrderByInput',
    '_B_float_OrderByInput',
    '_B_d_float_OrderByInput',
    '_B_decFloat_OrderByInput',
    '_B_numFloat_OrderByInput',
    '_B_RelevanceOrderByInput',
]



# recursive B types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

BRelationFilter = TypedDict(
    'BRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class BListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class BInclude(TypedDict, total=False):
    """B relational arguments"""


    

class PostIncludeFromB(TypedDict, total=False):
    """Relational arguments for B"""
    author: Union[bool, 'UserArgsFromBRecursive1']


class PostIncludeFromBRecursive1(TypedDict, total=False):
    """Relational arguments for B"""
    author: Union[bool, 'UserArgsFromBRecursive2']


class PostIncludeFromBRecursive2(TypedDict, total=False):
    """Relational arguments for B"""

    

class PostArgsFromB(TypedDict, total=False):
    """Arguments for B"""
    include: 'PostIncludeFromPostRecursive1'


class PostArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""
    include: 'PostIncludeFromPostRecursive2'


class PostArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""
    
    

class FindManyPostArgsFromB(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPostRecursive1'


class FindManyPostArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPostRecursive2'


class FindManyPostArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    
    

class UserIncludeFromB(TypedDict, total=False):
    """Relational arguments for B"""
    posts: Union[bool, 'FindManyPostArgsFromBRecursive1']


class UserIncludeFromBRecursive1(TypedDict, total=False):
    """Relational arguments for B"""
    posts: Union[bool, 'FindManyPostArgsFromBRecursive2']


class UserIncludeFromBRecursive2(TypedDict, total=False):
    """Relational arguments for B"""

    

class UserArgsFromB(TypedDict, total=False):
    """Arguments for B"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""
    
    

class FindManyUserArgsFromB(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class MIncludeFromB(TypedDict, total=False):
    """Relational arguments for B"""
    n: Union[bool, 'FindManyNArgsFromBRecursive1']


class MIncludeFromBRecursive1(TypedDict, total=False):
    """Relational arguments for B"""
    n: Union[bool, 'FindManyNArgsFromBRecursive2']


class MIncludeFromBRecursive2(TypedDict, total=False):
    """Relational arguments for B"""

    

class MArgsFromB(TypedDict, total=False):
    """Arguments for B"""
    include: 'MIncludeFromMRecursive1'


class MArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""
    include: 'MIncludeFromMRecursive2'


class MArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""
    
    

class FindManyMArgsFromB(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromMRecursive1'


class FindManyMArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromMRecursive2'


class FindManyMArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    
    

class NIncludeFromB(TypedDict, total=False):
    """Relational arguments for B"""
    m: Union[bool, 'FindManyMArgsFromBRecursive1']


class NIncludeFromBRecursive1(TypedDict, total=False):
    """Relational arguments for B"""
    m: Union[bool, 'FindManyMArgsFromBRecursive2']


class NIncludeFromBRecursive2(TypedDict, total=False):
    """Relational arguments for B"""

    

class NArgsFromB(TypedDict, total=False):
    """Arguments for B"""
    include: 'NIncludeFromNRecursive1'


class NArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""
    include: 'NIncludeFromNRecursive2'


class NArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""
    
    

class FindManyNArgsFromB(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromNRecursive1'


class FindManyNArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromNRecursive2'


class FindManyNArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    
    

class OneOptionalIncludeFromB(TypedDict, total=False):
    """Relational arguments for B"""
    many: Union[bool, 'FindManyManyRequiredArgsFromBRecursive1']


class OneOptionalIncludeFromBRecursive1(TypedDict, total=False):
    """Relational arguments for B"""
    many: Union[bool, 'FindManyManyRequiredArgsFromBRecursive2']


class OneOptionalIncludeFromBRecursive2(TypedDict, total=False):
    """Relational arguments for B"""

    

class OneOptionalArgsFromB(TypedDict, total=False):
    """Arguments for B"""
    include: 'OneOptionalIncludeFromOneOptionalRecursive1'


class OneOptionalArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""
    include: 'OneOptionalIncludeFromOneOptionalRecursive2'


class OneOptionalArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""
    
    

class FindManyOneOptionalArgsFromB(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromOneOptionalRecursive1'


class FindManyOneOptionalArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromOneOptionalRecursive2'


class FindManyOneOptionalArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    
    

class ManyRequiredIncludeFromB(TypedDict, total=False):
    """Relational arguments for B"""
    one: Union[bool, 'OneOptionalArgsFromBRecursive1']


class ManyRequiredIncludeFromBRecursive1(TypedDict, total=False):
    """Relational arguments for B"""
    one: Union[bool, 'OneOptionalArgsFromBRecursive2']


class ManyRequiredIncludeFromBRecursive2(TypedDict, total=False):
    """Relational arguments for B"""

    

class ManyRequiredArgsFromB(TypedDict, total=False):
    """Arguments for B"""
    include: 'ManyRequiredIncludeFromManyRequiredRecursive1'


class ManyRequiredArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""
    include: 'ManyRequiredIncludeFromManyRequiredRecursive2'


class ManyRequiredArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""
    
    

class FindManyManyRequiredArgsFromB(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromManyRequiredRecursive1'


class FindManyManyRequiredArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromManyRequiredRecursive2'


class FindManyManyRequiredArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    
    

class ListsIncludeFromB(TypedDict, total=False):
    """Relational arguments for B"""


class ListsIncludeFromBRecursive1(TypedDict, total=False):
    """Relational arguments for B"""


class ListsIncludeFromBRecursive2(TypedDict, total=False):
    """Relational arguments for B"""

    

class ListsArgsFromB(TypedDict, total=False):
    """Arguments for B"""
    include: 'ListsIncludeFromListsRecursive1'


class ListsArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""
    include: 'ListsIncludeFromListsRecursive2'


class ListsArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""
    
    

class FindManyListsArgsFromB(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromListsRecursive1'


class FindManyListsArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromListsRecursive2'


class FindManyListsArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    
    

class AIncludeFromB(TypedDict, total=False):
    """Relational arguments for B"""


class AIncludeFromBRecursive1(TypedDict, total=False):
    """Relational arguments for B"""


class AIncludeFromBRecursive2(TypedDict, total=False):
    """Relational arguments for B"""

    

class AArgsFromB(TypedDict, total=False):
    """Arguments for B"""
    include: 'AIncludeFromARecursive1'


class AArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""
    include: 'AIncludeFromARecursive2'


class AArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""
    
    

class FindManyAArgsFromB(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromARecursive1'


class FindManyAArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromARecursive2'


class FindManyAArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    
    

class BIncludeFromB(TypedDict, total=False):
    """Relational arguments for B"""


class BIncludeFromBRecursive1(TypedDict, total=False):
    """Relational arguments for B"""


class BIncludeFromBRecursive2(TypedDict, total=False):
    """Relational arguments for B"""

    

class BArgsFromB(TypedDict, total=False):
    """Arguments for B"""
    include: 'BIncludeFromBRecursive1'


class BArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""
    include: 'BIncludeFromBRecursive2'


class BArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""
    
    

class FindManyBArgsFromB(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromBRecursive1'


class FindManyBArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromBRecursive2'


class FindManyBArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    
    

class CIncludeFromB(TypedDict, total=False):
    """Relational arguments for B"""


class CIncludeFromBRecursive1(TypedDict, total=False):
    """Relational arguments for B"""


class CIncludeFromBRecursive2(TypedDict, total=False):
    """Relational arguments for B"""

    

class CArgsFromB(TypedDict, total=False):
    """Arguments for B"""
    include: 'CIncludeFromCRecursive1'


class CArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""
    include: 'CIncludeFromCRecursive2'


class CArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""
    
    

class FindManyCArgsFromB(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromCRecursive1'


class FindManyCArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromCRecursive2'


class FindManyCArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    
    

class DIncludeFromB(TypedDict, total=False):
    """Relational arguments for B"""


class DIncludeFromBRecursive1(TypedDict, total=False):
    """Relational arguments for B"""


class DIncludeFromBRecursive2(TypedDict, total=False):
    """Relational arguments for B"""

    

class DArgsFromB(TypedDict, total=False):
    """Arguments for B"""
    include: 'DIncludeFromDRecursive1'


class DArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""
    include: 'DIncludeFromDRecursive2'


class DArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""
    
    

class FindManyDArgsFromB(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromDRecursive1'


class FindManyDArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromDRecursive2'


class FindManyDArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    
    

class EIncludeFromB(TypedDict, total=False):
    """Relational arguments for B"""


class EIncludeFromBRecursive1(TypedDict, total=False):
    """Relational arguments for B"""


class EIncludeFromBRecursive2(TypedDict, total=False):
    """Relational arguments for B"""

    

class EArgsFromB(TypedDict, total=False):
    """Arguments for B"""
    include: 'EIncludeFromERecursive1'


class EArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""
    include: 'EIncludeFromERecursive2'


class EArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""
    
    

class FindManyEArgsFromB(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromERecursive1'


class FindManyEArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromERecursive2'


class FindManyEArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    


FindManyBArgs = FindManyBArgsFromB
FindFirstBArgs = FindManyBArgsFromB


    

class BWhereInput(TypedDict, total=False):
    """B arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    float: Union[_float, 'types.FloatFilter']
    d_float: Union[_float, 'types.FloatFilter']
    decFloat: Union[decimal.Decimal, 'types.DecimalFilter']
    numFloat: Union[decimal.Decimal, 'types.DecimalFilter']

    # should be noted that AND and NOT should be Union['BWhereInputRecursive1', List['BWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['BWhereInputRecursive1']
    OR: List['BWhereInputRecursive1']
    NOT: List['BWhereInputRecursive1']


class BWhereInputRecursive1(TypedDict, total=False):
    """B arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    float: Union[_float, 'types.FloatFilter']
    d_float: Union[_float, 'types.FloatFilter']
    decFloat: Union[decimal.Decimal, 'types.DecimalFilter']
    numFloat: Union[decimal.Decimal, 'types.DecimalFilter']

    # should be noted that AND and NOT should be Union['BWhereInputRecursive2', List['BWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['BWhereInputRecursive2']
    OR: List['BWhereInputRecursive2']
    NOT: List['BWhereInputRecursive2']


class BWhereInputRecursive2(TypedDict, total=False):
    """B arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    float: Union[_float, 'types.FloatFilter']
    d_float: Union[_float, 'types.FloatFilter']
    decFloat: Union[decimal.Decimal, 'types.DecimalFilter']
    numFloat: Union[decimal.Decimal, 'types.DecimalFilter']



# aggregate B types


    

class BScalarWhereWithAggregatesInput(TypedDict, total=False):
    """B arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    d_float: Union[_float, 'types.FloatWithAggregatesFilter']
    decFloat: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    numFloat: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']

    AND: List['BScalarWhereWithAggregatesInputRecursive1']
    OR: List['BScalarWhereWithAggregatesInputRecursive1']
    NOT: List['BScalarWhereWithAggregatesInputRecursive1']


class BScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """B arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    d_float: Union[_float, 'types.FloatWithAggregatesFilter']
    decFloat: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    numFloat: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']

    AND: List['BScalarWhereWithAggregatesInputRecursive2']
    OR: List['BScalarWhereWithAggregatesInputRecursive2']
    NOT: List['BScalarWhereWithAggregatesInputRecursive2']


class BScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """B arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    d_float: Union[_float, 'types.FloatWithAggregatesFilter']
    decFloat: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    numFloat: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']



class BGroupByOutput(TypedDict, total=False):
    id: _str
    float: _float
    d_float: _float
    decFloat: decimal.Decimal
    numFloat: decimal.Decimal
    _sum: 'BSumAggregateOutput'
    _avg: 'BAvgAggregateOutput'
    _min: 'BMinAggregateOutput'
    _max: 'BMaxAggregateOutput'
    _count: 'BCountAggregateOutput'


class BAvgAggregateOutput(TypedDict, total=False):
    """B output for aggregating averages"""
    float: float
    d_float: float


class BSumAggregateOutput(TypedDict, total=False):
    """B output for aggregating sums"""
    float: _float
    d_float: _float


class BScalarAggregateOutput(TypedDict, total=False):
    """B output including scalar fields"""
    id: _str
    float: _float
    d_float: _float
    decFloat: decimal.Decimal
    numFloat: decimal.Decimal


BMinAggregateOutput = BScalarAggregateOutput
BMaxAggregateOutput = BScalarAggregateOutput


class BMaxAggregateInput(TypedDict, total=False):
    """B input for aggregating by max"""
    id: bool
    float: bool
    d_float: bool
    decFloat: bool
    numFloat: bool


class BMinAggregateInput(TypedDict, total=False):
    """B input for aggregating by min"""
    id: bool
    float: bool
    d_float: bool
    decFloat: bool
    numFloat: bool


class BNumberAggregateInput(TypedDict, total=False):
    """B input for aggregating numbers"""
    float: bool
    d_float: bool


BAvgAggregateInput = BNumberAggregateInput
BSumAggregateInput = BNumberAggregateInput


BCountAggregateInput = TypedDict(
    'BCountAggregateInput',
    {
        'id': bool,
        'float': bool,
        'd_float': bool,
        'decFloat': bool,
        'numFloat': bool,
        '_all': bool,
    },
    total=False,
)

BCountAggregateOutput = TypedDict(
    'BCountAggregateOutput',
    {
        'id': int,
        'float': int,
        'd_float': int,
        'decFloat': int,
        'numFloat': int,
        '_all': int,
    },
    total=False,
)


BKeys = Literal[
    'id',
    'float',
    'd_float',
    'decFloat',
    'numFloat',
]
BScalarFieldKeys = Literal[
    'id',
    'float',
    'd_float',
    'decFloat',
    'numFloat',
]
BScalarFieldKeysT = TypeVar('BScalarFieldKeysT', bound=BScalarFieldKeys)

BRelationalFieldKeys = _NoneType

# C types

class COptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the C create method"""


class CCreateInput(COptionalCreateInput):
    """Required arguments to the C create method"""
    char: _str
    v_char: _str
    text: _str
    bit: _str
    v_bit: _str
    uuid: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class COptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the C create method, without relations"""


class CCreateWithoutRelationsInput(COptionalCreateWithoutRelationsInput):
    """Required arguments to the C create method, without relations"""
    char: _str
    v_char: _str
    text: _str
    bit: _str
    v_bit: _str
    uuid: _str

class CConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'CCreateWithoutRelationsInput'
    where: 'CWhereUniqueInput'

class CCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'CCreateWithoutRelationsInput'
    connect: 'CWhereUniqueInput'
    connect_or_create: 'CConnectOrCreateWithoutRelationsInput'


class CCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['CCreateWithoutRelationsInput', List['CCreateWithoutRelationsInput']]
    connect: Union['CWhereUniqueInput', List['CWhereUniqueInput']]
    connect_or_create: Union['CConnectOrCreateWithoutRelationsInput', List['CConnectOrCreateWithoutRelationsInput']]

_CCompoundPrimaryKeyInner = TypedDict(
    '_CCompoundPrimaryKeyInner',
    {
        'char': '_str',
        'text': '_str',
    },
    total=True
)

_CCompoundPrimaryKey = TypedDict(
    '_CCompoundPrimaryKey',
    {
        'my_id': '_CCompoundPrimaryKeyInner',
    },
    total=True
)

CWhereUniqueInput = _CCompoundPrimaryKey


class CUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    char: _str
    v_char: _str
    text: _str
    bit: _str
    v_bit: _str
    uuid: _str


class CUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    char: _str
    v_char: _str
    text: _str
    bit: _str
    v_bit: _str
    uuid: _str


class CUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['CCreateWithoutRelationsInput']
    connect: List['CWhereUniqueInput']
    connect_or_create: List['CConnectOrCreateWithoutRelationsInput']
    set: List['CWhereUniqueInput']
    disconnect: List['CWhereUniqueInput']
    delete: List['CWhereUniqueInput']

    # TODO
    # update: List['CUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['CUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['CScalarWhereInput']
    # upsert: List['CUpserteWithWhereUniqueWithoutRelationsInput']


class CUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'CCreateWithoutRelationsInput'
    connect: 'CWhereUniqueInput'
    connect_or_create: 'CConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'CUpdateInput'
    # upsert: 'CUpsertWithoutRelationsInput'


class CUpsertInput(TypedDict):
    create: 'CCreateInput'
    update: 'CUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_C_char_OrderByInput = TypedDict(
    '_C_char_OrderByInput',
    {
        'char': 'SortOrder',
    },
    total=True
)

_C_v_char_OrderByInput = TypedDict(
    '_C_v_char_OrderByInput',
    {
        'v_char': 'SortOrder',
    },
    total=True
)

_C_text_OrderByInput = TypedDict(
    '_C_text_OrderByInput',
    {
        'text': 'SortOrder',
    },
    total=True
)

_C_bit_OrderByInput = TypedDict(
    '_C_bit_OrderByInput',
    {
        'bit': 'SortOrder',
    },
    total=True
)

_C_v_bit_OrderByInput = TypedDict(
    '_C_v_bit_OrderByInput',
    {
        'v_bit': 'SortOrder',
    },
    total=True
)

_C_uuid_OrderByInput = TypedDict(
    '_C_uuid_OrderByInput',
    {
        'uuid': 'SortOrder',
    },
    total=True
)

_C_RelevanceInner = TypedDict(
    '_C_RelevanceInner',
    {
        'fields': 'List[CScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_C_RelevanceOrderByInput = TypedDict(
    '_C_RelevanceOrderByInput',
    {
        '_relevance': '_C_RelevanceInner',
    },
    total=True
)

COrderByInput = Union[
    '_C_char_OrderByInput',
    '_C_v_char_OrderByInput',
    '_C_text_OrderByInput',
    '_C_bit_OrderByInput',
    '_C_v_bit_OrderByInput',
    '_C_uuid_OrderByInput',
    '_C_RelevanceOrderByInput',
]



# recursive C types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

CRelationFilter = TypedDict(
    'CRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class CListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class CInclude(TypedDict, total=False):
    """C relational arguments"""


    

class PostIncludeFromC(TypedDict, total=False):
    """Relational arguments for C"""
    author: Union[bool, 'UserArgsFromCRecursive1']


class PostIncludeFromCRecursive1(TypedDict, total=False):
    """Relational arguments for C"""
    author: Union[bool, 'UserArgsFromCRecursive2']


class PostIncludeFromCRecursive2(TypedDict, total=False):
    """Relational arguments for C"""

    

class PostArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    include: 'PostIncludeFromPostRecursive1'


class PostArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    include: 'PostIncludeFromPostRecursive2'


class PostArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    
    

class FindManyPostArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPostRecursive1'


class FindManyPostArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPostRecursive2'


class FindManyPostArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    
    

class UserIncludeFromC(TypedDict, total=False):
    """Relational arguments for C"""
    posts: Union[bool, 'FindManyPostArgsFromCRecursive1']


class UserIncludeFromCRecursive1(TypedDict, total=False):
    """Relational arguments for C"""
    posts: Union[bool, 'FindManyPostArgsFromCRecursive2']


class UserIncludeFromCRecursive2(TypedDict, total=False):
    """Relational arguments for C"""

    

class UserArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    
    

class FindManyUserArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class MIncludeFromC(TypedDict, total=False):
    """Relational arguments for C"""
    n: Union[bool, 'FindManyNArgsFromCRecursive1']


class MIncludeFromCRecursive1(TypedDict, total=False):
    """Relational arguments for C"""
    n: Union[bool, 'FindManyNArgsFromCRecursive2']


class MIncludeFromCRecursive2(TypedDict, total=False):
    """Relational arguments for C"""

    

class MArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    include: 'MIncludeFromMRecursive1'


class MArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    include: 'MIncludeFromMRecursive2'


class MArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    
    

class FindManyMArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromMRecursive1'


class FindManyMArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromMRecursive2'


class FindManyMArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    
    

class NIncludeFromC(TypedDict, total=False):
    """Relational arguments for C"""
    m: Union[bool, 'FindManyMArgsFromCRecursive1']


class NIncludeFromCRecursive1(TypedDict, total=False):
    """Relational arguments for C"""
    m: Union[bool, 'FindManyMArgsFromCRecursive2']


class NIncludeFromCRecursive2(TypedDict, total=False):
    """Relational arguments for C"""

    

class NArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    include: 'NIncludeFromNRecursive1'


class NArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    include: 'NIncludeFromNRecursive2'


class NArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    
    

class FindManyNArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromNRecursive1'


class FindManyNArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromNRecursive2'


class FindManyNArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    
    

class OneOptionalIncludeFromC(TypedDict, total=False):
    """Relational arguments for C"""
    many: Union[bool, 'FindManyManyRequiredArgsFromCRecursive1']


class OneOptionalIncludeFromCRecursive1(TypedDict, total=False):
    """Relational arguments for C"""
    many: Union[bool, 'FindManyManyRequiredArgsFromCRecursive2']


class OneOptionalIncludeFromCRecursive2(TypedDict, total=False):
    """Relational arguments for C"""

    

class OneOptionalArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    include: 'OneOptionalIncludeFromOneOptionalRecursive1'


class OneOptionalArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    include: 'OneOptionalIncludeFromOneOptionalRecursive2'


class OneOptionalArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    
    

class FindManyOneOptionalArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromOneOptionalRecursive1'


class FindManyOneOptionalArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromOneOptionalRecursive2'


class FindManyOneOptionalArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    
    

class ManyRequiredIncludeFromC(TypedDict, total=False):
    """Relational arguments for C"""
    one: Union[bool, 'OneOptionalArgsFromCRecursive1']


class ManyRequiredIncludeFromCRecursive1(TypedDict, total=False):
    """Relational arguments for C"""
    one: Union[bool, 'OneOptionalArgsFromCRecursive2']


class ManyRequiredIncludeFromCRecursive2(TypedDict, total=False):
    """Relational arguments for C"""

    

class ManyRequiredArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    include: 'ManyRequiredIncludeFromManyRequiredRecursive1'


class ManyRequiredArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    include: 'ManyRequiredIncludeFromManyRequiredRecursive2'


class ManyRequiredArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    
    

class FindManyManyRequiredArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromManyRequiredRecursive1'


class FindManyManyRequiredArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromManyRequiredRecursive2'


class FindManyManyRequiredArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    
    

class ListsIncludeFromC(TypedDict, total=False):
    """Relational arguments for C"""


class ListsIncludeFromCRecursive1(TypedDict, total=False):
    """Relational arguments for C"""


class ListsIncludeFromCRecursive2(TypedDict, total=False):
    """Relational arguments for C"""

    

class ListsArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    include: 'ListsIncludeFromListsRecursive1'


class ListsArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    include: 'ListsIncludeFromListsRecursive2'


class ListsArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    
    

class FindManyListsArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromListsRecursive1'


class FindManyListsArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromListsRecursive2'


class FindManyListsArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    
    

class AIncludeFromC(TypedDict, total=False):
    """Relational arguments for C"""


class AIncludeFromCRecursive1(TypedDict, total=False):
    """Relational arguments for C"""


class AIncludeFromCRecursive2(TypedDict, total=False):
    """Relational arguments for C"""

    

class AArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    include: 'AIncludeFromARecursive1'


class AArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    include: 'AIncludeFromARecursive2'


class AArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    
    

class FindManyAArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromARecursive1'


class FindManyAArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromARecursive2'


class FindManyAArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    
    

class BIncludeFromC(TypedDict, total=False):
    """Relational arguments for C"""


class BIncludeFromCRecursive1(TypedDict, total=False):
    """Relational arguments for C"""


class BIncludeFromCRecursive2(TypedDict, total=False):
    """Relational arguments for C"""

    

class BArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    include: 'BIncludeFromBRecursive1'


class BArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    include: 'BIncludeFromBRecursive2'


class BArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    
    

class FindManyBArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromBRecursive1'


class FindManyBArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromBRecursive2'


class FindManyBArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    
    

class CIncludeFromC(TypedDict, total=False):
    """Relational arguments for C"""


class CIncludeFromCRecursive1(TypedDict, total=False):
    """Relational arguments for C"""


class CIncludeFromCRecursive2(TypedDict, total=False):
    """Relational arguments for C"""

    

class CArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    include: 'CIncludeFromCRecursive1'


class CArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    include: 'CIncludeFromCRecursive2'


class CArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    
    

class FindManyCArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromCRecursive1'


class FindManyCArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromCRecursive2'


class FindManyCArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    
    

class DIncludeFromC(TypedDict, total=False):
    """Relational arguments for C"""


class DIncludeFromCRecursive1(TypedDict, total=False):
    """Relational arguments for C"""


class DIncludeFromCRecursive2(TypedDict, total=False):
    """Relational arguments for C"""

    

class DArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    include: 'DIncludeFromDRecursive1'


class DArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    include: 'DIncludeFromDRecursive2'


class DArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    
    

class FindManyDArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromDRecursive1'


class FindManyDArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromDRecursive2'


class FindManyDArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    
    

class EIncludeFromC(TypedDict, total=False):
    """Relational arguments for C"""


class EIncludeFromCRecursive1(TypedDict, total=False):
    """Relational arguments for C"""


class EIncludeFromCRecursive2(TypedDict, total=False):
    """Relational arguments for C"""

    

class EArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    include: 'EIncludeFromERecursive1'


class EArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    include: 'EIncludeFromERecursive2'


class EArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    
    

class FindManyEArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromERecursive1'


class FindManyEArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromERecursive2'


class FindManyEArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    


FindManyCArgs = FindManyCArgsFromC
FindFirstCArgs = FindManyCArgsFromC


    

class CWhereInput(TypedDict, total=False):
    """C arguments for searching"""
    char: Union[_str, 'types.StringFilter']
    v_char: Union[_str, 'types.StringFilter']
    text: Union[_str, 'types.StringFilter']
    bit: Union[_str, 'types.StringFilter']
    v_bit: Union[_str, 'types.StringFilter']
    uuid: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['CWhereInputRecursive1', List['CWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['CWhereInputRecursive1']
    OR: List['CWhereInputRecursive1']
    NOT: List['CWhereInputRecursive1']


class CWhereInputRecursive1(TypedDict, total=False):
    """C arguments for searching"""
    char: Union[_str, 'types.StringFilter']
    v_char: Union[_str, 'types.StringFilter']
    text: Union[_str, 'types.StringFilter']
    bit: Union[_str, 'types.StringFilter']
    v_bit: Union[_str, 'types.StringFilter']
    uuid: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['CWhereInputRecursive2', List['CWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['CWhereInputRecursive2']
    OR: List['CWhereInputRecursive2']
    NOT: List['CWhereInputRecursive2']


class CWhereInputRecursive2(TypedDict, total=False):
    """C arguments for searching"""
    char: Union[_str, 'types.StringFilter']
    v_char: Union[_str, 'types.StringFilter']
    text: Union[_str, 'types.StringFilter']
    bit: Union[_str, 'types.StringFilter']
    v_bit: Union[_str, 'types.StringFilter']
    uuid: Union[_str, 'types.StringFilter']



# aggregate C types


    

class CScalarWhereWithAggregatesInput(TypedDict, total=False):
    """C arguments for searching"""
    char: Union[_str, 'types.StringWithAggregatesFilter']
    v_char: Union[_str, 'types.StringWithAggregatesFilter']
    text: Union[_str, 'types.StringWithAggregatesFilter']
    bit: Union[_str, 'types.StringWithAggregatesFilter']
    v_bit: Union[_str, 'types.StringWithAggregatesFilter']
    uuid: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['CScalarWhereWithAggregatesInputRecursive1']
    OR: List['CScalarWhereWithAggregatesInputRecursive1']
    NOT: List['CScalarWhereWithAggregatesInputRecursive1']


class CScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """C arguments for searching"""
    char: Union[_str, 'types.StringWithAggregatesFilter']
    v_char: Union[_str, 'types.StringWithAggregatesFilter']
    text: Union[_str, 'types.StringWithAggregatesFilter']
    bit: Union[_str, 'types.StringWithAggregatesFilter']
    v_bit: Union[_str, 'types.StringWithAggregatesFilter']
    uuid: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['CScalarWhereWithAggregatesInputRecursive2']
    OR: List['CScalarWhereWithAggregatesInputRecursive2']
    NOT: List['CScalarWhereWithAggregatesInputRecursive2']


class CScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """C arguments for searching"""
    char: Union[_str, 'types.StringWithAggregatesFilter']
    v_char: Union[_str, 'types.StringWithAggregatesFilter']
    text: Union[_str, 'types.StringWithAggregatesFilter']
    bit: Union[_str, 'types.StringWithAggregatesFilter']
    v_bit: Union[_str, 'types.StringWithAggregatesFilter']
    uuid: Union[_str, 'types.StringWithAggregatesFilter']



class CGroupByOutput(TypedDict, total=False):
    char: _str
    v_char: _str
    text: _str
    bit: _str
    v_bit: _str
    uuid: _str
    _sum: 'CSumAggregateOutput'
    _avg: 'CAvgAggregateOutput'
    _min: 'CMinAggregateOutput'
    _max: 'CMaxAggregateOutput'
    _count: 'CCountAggregateOutput'


class CAvgAggregateOutput(TypedDict, total=False):
    """C output for aggregating averages"""


class CSumAggregateOutput(TypedDict, total=False):
    """C output for aggregating sums"""


class CScalarAggregateOutput(TypedDict, total=False):
    """C output including scalar fields"""
    char: _str
    v_char: _str
    text: _str
    bit: _str
    v_bit: _str
    uuid: _str


CMinAggregateOutput = CScalarAggregateOutput
CMaxAggregateOutput = CScalarAggregateOutput


class CMaxAggregateInput(TypedDict, total=False):
    """C input for aggregating by max"""
    char: bool
    v_char: bool
    text: bool
    bit: bool
    v_bit: bool
    uuid: bool


class CMinAggregateInput(TypedDict, total=False):
    """C input for aggregating by min"""
    char: bool
    v_char: bool
    text: bool
    bit: bool
    v_bit: bool
    uuid: bool


class CNumberAggregateInput(TypedDict, total=False):
    """C input for aggregating numbers"""


CAvgAggregateInput = CNumberAggregateInput
CSumAggregateInput = CNumberAggregateInput


CCountAggregateInput = TypedDict(
    'CCountAggregateInput',
    {
        'char': bool,
        'v_char': bool,
        'text': bool,
        'bit': bool,
        'v_bit': bool,
        'uuid': bool,
        '_all': bool,
    },
    total=False,
)

CCountAggregateOutput = TypedDict(
    'CCountAggregateOutput',
    {
        'char': int,
        'v_char': int,
        'text': int,
        'bit': int,
        'v_bit': int,
        'uuid': int,
        '_all': int,
    },
    total=False,
)


CKeys = Literal[
    'char',
    'v_char',
    'text',
    'bit',
    'v_bit',
    'uuid',
]
CScalarFieldKeys = Literal[
    'char',
    'v_char',
    'text',
    'bit',
    'v_bit',
    'uuid',
]
CScalarFieldKeysT = TypeVar('CScalarFieldKeysT', bound=CScalarFieldKeys)

CRelationalFieldKeys = _NoneType

# D types

class DOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the D create method"""
    id: _str


class DCreateInput(DOptionalCreateInput):
    """Required arguments to the D create method"""
    bool: _bool
    xml: _str
    json_: 'fields.Json'
    jsonb: 'fields.Json'
    binary: 'fields.Base64'


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class DOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the D create method, without relations"""
    id: _str


class DCreateWithoutRelationsInput(DOptionalCreateWithoutRelationsInput):
    """Required arguments to the D create method, without relations"""
    bool: _bool
    xml: _str
    json_: 'fields.Json'
    jsonb: 'fields.Json'
    binary: 'fields.Base64'

class DConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'DCreateWithoutRelationsInput'
    where: 'DWhereUniqueInput'

class DCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'DCreateWithoutRelationsInput'
    connect: 'DWhereUniqueInput'
    connect_or_create: 'DConnectOrCreateWithoutRelationsInput'


class DCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['DCreateWithoutRelationsInput', List['DCreateWithoutRelationsInput']]
    connect: Union['DWhereUniqueInput', List['DWhereUniqueInput']]
    connect_or_create: Union['DConnectOrCreateWithoutRelationsInput', List['DConnectOrCreateWithoutRelationsInput']]

_DWhereUnique_id_Input = TypedDict(
    '_DWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

DWhereUniqueInput = _DWhereUnique_id_Input


class DUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    bool: _bool
    xml: _str
    json_: 'fields.Json'
    jsonb: 'fields.Json'
    binary: 'fields.Base64'


class DUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    bool: _bool
    xml: _str
    json_: 'fields.Json'
    jsonb: 'fields.Json'
    binary: 'fields.Base64'


class DUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['DCreateWithoutRelationsInput']
    connect: List['DWhereUniqueInput']
    connect_or_create: List['DConnectOrCreateWithoutRelationsInput']
    set: List['DWhereUniqueInput']
    disconnect: List['DWhereUniqueInput']
    delete: List['DWhereUniqueInput']

    # TODO
    # update: List['DUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['DUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['DScalarWhereInput']
    # upsert: List['DUpserteWithWhereUniqueWithoutRelationsInput']


class DUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'DCreateWithoutRelationsInput'
    connect: 'DWhereUniqueInput'
    connect_or_create: 'DConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'DUpdateInput'
    # upsert: 'DUpsertWithoutRelationsInput'


class DUpsertInput(TypedDict):
    create: 'DCreateInput'
    update: 'DUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_D_id_OrderByInput = TypedDict(
    '_D_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_D_bool_OrderByInput = TypedDict(
    '_D_bool_OrderByInput',
    {
        'bool': 'SortOrder',
    },
    total=True
)

_D_xml_OrderByInput = TypedDict(
    '_D_xml_OrderByInput',
    {
        'xml': 'SortOrder',
    },
    total=True
)

_D_json__OrderByInput = TypedDict(
    '_D_json__OrderByInput',
    {
        'json_': 'SortOrder',
    },
    total=True
)

_D_jsonb_OrderByInput = TypedDict(
    '_D_jsonb_OrderByInput',
    {
        'jsonb': 'SortOrder',
    },
    total=True
)

_D_binary_OrderByInput = TypedDict(
    '_D_binary_OrderByInput',
    {
        'binary': 'SortOrder',
    },
    total=True
)

_D_RelevanceInner = TypedDict(
    '_D_RelevanceInner',
    {
        'fields': 'List[DScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_D_RelevanceOrderByInput = TypedDict(
    '_D_RelevanceOrderByInput',
    {
        '_relevance': '_D_RelevanceInner',
    },
    total=True
)

DOrderByInput = Union[
    '_D_id_OrderByInput',
    '_D_bool_OrderByInput',
    '_D_xml_OrderByInput',
    '_D_json__OrderByInput',
    '_D_jsonb_OrderByInput',
    '_D_binary_OrderByInput',
    '_D_RelevanceOrderByInput',
]



# recursive D types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

DRelationFilter = TypedDict(
    'DRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class DListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class DInclude(TypedDict, total=False):
    """D relational arguments"""


    

class PostIncludeFromD(TypedDict, total=False):
    """Relational arguments for D"""
    author: Union[bool, 'UserArgsFromDRecursive1']


class PostIncludeFromDRecursive1(TypedDict, total=False):
    """Relational arguments for D"""
    author: Union[bool, 'UserArgsFromDRecursive2']


class PostIncludeFromDRecursive2(TypedDict, total=False):
    """Relational arguments for D"""

    

class PostArgsFromD(TypedDict, total=False):
    """Arguments for D"""
    include: 'PostIncludeFromPostRecursive1'


class PostArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""
    include: 'PostIncludeFromPostRecursive2'


class PostArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""
    
    

class FindManyPostArgsFromD(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPostRecursive1'


class FindManyPostArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPostRecursive2'


class FindManyPostArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    
    

class UserIncludeFromD(TypedDict, total=False):
    """Relational arguments for D"""
    posts: Union[bool, 'FindManyPostArgsFromDRecursive1']


class UserIncludeFromDRecursive1(TypedDict, total=False):
    """Relational arguments for D"""
    posts: Union[bool, 'FindManyPostArgsFromDRecursive2']


class UserIncludeFromDRecursive2(TypedDict, total=False):
    """Relational arguments for D"""

    

class UserArgsFromD(TypedDict, total=False):
    """Arguments for D"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""
    
    

class FindManyUserArgsFromD(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class MIncludeFromD(TypedDict, total=False):
    """Relational arguments for D"""
    n: Union[bool, 'FindManyNArgsFromDRecursive1']


class MIncludeFromDRecursive1(TypedDict, total=False):
    """Relational arguments for D"""
    n: Union[bool, 'FindManyNArgsFromDRecursive2']


class MIncludeFromDRecursive2(TypedDict, total=False):
    """Relational arguments for D"""

    

class MArgsFromD(TypedDict, total=False):
    """Arguments for D"""
    include: 'MIncludeFromMRecursive1'


class MArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""
    include: 'MIncludeFromMRecursive2'


class MArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""
    
    

class FindManyMArgsFromD(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromMRecursive1'


class FindManyMArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromMRecursive2'


class FindManyMArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    
    

class NIncludeFromD(TypedDict, total=False):
    """Relational arguments for D"""
    m: Union[bool, 'FindManyMArgsFromDRecursive1']


class NIncludeFromDRecursive1(TypedDict, total=False):
    """Relational arguments for D"""
    m: Union[bool, 'FindManyMArgsFromDRecursive2']


class NIncludeFromDRecursive2(TypedDict, total=False):
    """Relational arguments for D"""

    

class NArgsFromD(TypedDict, total=False):
    """Arguments for D"""
    include: 'NIncludeFromNRecursive1'


class NArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""
    include: 'NIncludeFromNRecursive2'


class NArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""
    
    

class FindManyNArgsFromD(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromNRecursive1'


class FindManyNArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromNRecursive2'


class FindManyNArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    
    

class OneOptionalIncludeFromD(TypedDict, total=False):
    """Relational arguments for D"""
    many: Union[bool, 'FindManyManyRequiredArgsFromDRecursive1']


class OneOptionalIncludeFromDRecursive1(TypedDict, total=False):
    """Relational arguments for D"""
    many: Union[bool, 'FindManyManyRequiredArgsFromDRecursive2']


class OneOptionalIncludeFromDRecursive2(TypedDict, total=False):
    """Relational arguments for D"""

    

class OneOptionalArgsFromD(TypedDict, total=False):
    """Arguments for D"""
    include: 'OneOptionalIncludeFromOneOptionalRecursive1'


class OneOptionalArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""
    include: 'OneOptionalIncludeFromOneOptionalRecursive2'


class OneOptionalArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""
    
    

class FindManyOneOptionalArgsFromD(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromOneOptionalRecursive1'


class FindManyOneOptionalArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromOneOptionalRecursive2'


class FindManyOneOptionalArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    
    

class ManyRequiredIncludeFromD(TypedDict, total=False):
    """Relational arguments for D"""
    one: Union[bool, 'OneOptionalArgsFromDRecursive1']


class ManyRequiredIncludeFromDRecursive1(TypedDict, total=False):
    """Relational arguments for D"""
    one: Union[bool, 'OneOptionalArgsFromDRecursive2']


class ManyRequiredIncludeFromDRecursive2(TypedDict, total=False):
    """Relational arguments for D"""

    

class ManyRequiredArgsFromD(TypedDict, total=False):
    """Arguments for D"""
    include: 'ManyRequiredIncludeFromManyRequiredRecursive1'


class ManyRequiredArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""
    include: 'ManyRequiredIncludeFromManyRequiredRecursive2'


class ManyRequiredArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""
    
    

class FindManyManyRequiredArgsFromD(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromManyRequiredRecursive1'


class FindManyManyRequiredArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromManyRequiredRecursive2'


class FindManyManyRequiredArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    
    

class ListsIncludeFromD(TypedDict, total=False):
    """Relational arguments for D"""


class ListsIncludeFromDRecursive1(TypedDict, total=False):
    """Relational arguments for D"""


class ListsIncludeFromDRecursive2(TypedDict, total=False):
    """Relational arguments for D"""

    

class ListsArgsFromD(TypedDict, total=False):
    """Arguments for D"""
    include: 'ListsIncludeFromListsRecursive1'


class ListsArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""
    include: 'ListsIncludeFromListsRecursive2'


class ListsArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""
    
    

class FindManyListsArgsFromD(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromListsRecursive1'


class FindManyListsArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromListsRecursive2'


class FindManyListsArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    
    

class AIncludeFromD(TypedDict, total=False):
    """Relational arguments for D"""


class AIncludeFromDRecursive1(TypedDict, total=False):
    """Relational arguments for D"""


class AIncludeFromDRecursive2(TypedDict, total=False):
    """Relational arguments for D"""

    

class AArgsFromD(TypedDict, total=False):
    """Arguments for D"""
    include: 'AIncludeFromARecursive1'


class AArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""
    include: 'AIncludeFromARecursive2'


class AArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""
    
    

class FindManyAArgsFromD(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromARecursive1'


class FindManyAArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromARecursive2'


class FindManyAArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    
    

class BIncludeFromD(TypedDict, total=False):
    """Relational arguments for D"""


class BIncludeFromDRecursive1(TypedDict, total=False):
    """Relational arguments for D"""


class BIncludeFromDRecursive2(TypedDict, total=False):
    """Relational arguments for D"""

    

class BArgsFromD(TypedDict, total=False):
    """Arguments for D"""
    include: 'BIncludeFromBRecursive1'


class BArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""
    include: 'BIncludeFromBRecursive2'


class BArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""
    
    

class FindManyBArgsFromD(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromBRecursive1'


class FindManyBArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromBRecursive2'


class FindManyBArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    
    

class CIncludeFromD(TypedDict, total=False):
    """Relational arguments for D"""


class CIncludeFromDRecursive1(TypedDict, total=False):
    """Relational arguments for D"""


class CIncludeFromDRecursive2(TypedDict, total=False):
    """Relational arguments for D"""

    

class CArgsFromD(TypedDict, total=False):
    """Arguments for D"""
    include: 'CIncludeFromCRecursive1'


class CArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""
    include: 'CIncludeFromCRecursive2'


class CArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""
    
    

class FindManyCArgsFromD(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromCRecursive1'


class FindManyCArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromCRecursive2'


class FindManyCArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    
    

class DIncludeFromD(TypedDict, total=False):
    """Relational arguments for D"""


class DIncludeFromDRecursive1(TypedDict, total=False):
    """Relational arguments for D"""


class DIncludeFromDRecursive2(TypedDict, total=False):
    """Relational arguments for D"""

    

class DArgsFromD(TypedDict, total=False):
    """Arguments for D"""
    include: 'DIncludeFromDRecursive1'


class DArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""
    include: 'DIncludeFromDRecursive2'


class DArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""
    
    

class FindManyDArgsFromD(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromDRecursive1'


class FindManyDArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromDRecursive2'


class FindManyDArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    
    

class EIncludeFromD(TypedDict, total=False):
    """Relational arguments for D"""


class EIncludeFromDRecursive1(TypedDict, total=False):
    """Relational arguments for D"""


class EIncludeFromDRecursive2(TypedDict, total=False):
    """Relational arguments for D"""

    

class EArgsFromD(TypedDict, total=False):
    """Arguments for D"""
    include: 'EIncludeFromERecursive1'


class EArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""
    include: 'EIncludeFromERecursive2'


class EArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""
    
    

class FindManyEArgsFromD(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromERecursive1'


class FindManyEArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromERecursive2'


class FindManyEArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    


FindManyDArgs = FindManyDArgsFromD
FindFirstDArgs = FindManyDArgsFromD


    

class DWhereInput(TypedDict, total=False):
    """D arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    bool: Union[_bool, 'types.BooleanFilter']
    xml: Union[_str, 'types.StringFilter']
    json_: Union['fields.Json', 'types.JsonFilter']
    jsonb: Union['fields.Json', 'types.JsonFilter']
    binary: Union['fields.Base64', 'types.BytesFilter']

    # should be noted that AND and NOT should be Union['DWhereInputRecursive1', List['DWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['DWhereInputRecursive1']
    OR: List['DWhereInputRecursive1']
    NOT: List['DWhereInputRecursive1']


class DWhereInputRecursive1(TypedDict, total=False):
    """D arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    bool: Union[_bool, 'types.BooleanFilter']
    xml: Union[_str, 'types.StringFilter']
    json_: Union['fields.Json', 'types.JsonFilter']
    jsonb: Union['fields.Json', 'types.JsonFilter']
    binary: Union['fields.Base64', 'types.BytesFilter']

    # should be noted that AND and NOT should be Union['DWhereInputRecursive2', List['DWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['DWhereInputRecursive2']
    OR: List['DWhereInputRecursive2']
    NOT: List['DWhereInputRecursive2']


class DWhereInputRecursive2(TypedDict, total=False):
    """D arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    bool: Union[_bool, 'types.BooleanFilter']
    xml: Union[_str, 'types.StringFilter']
    json_: Union['fields.Json', 'types.JsonFilter']
    jsonb: Union['fields.Json', 'types.JsonFilter']
    binary: Union['fields.Base64', 'types.BytesFilter']



# aggregate D types


    

class DScalarWhereWithAggregatesInput(TypedDict, total=False):
    """D arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    bool: Union[_bool, 'types.BooleanWithAggregatesFilter']
    xml: Union[_str, 'types.StringWithAggregatesFilter']
    json_: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    jsonb: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    binary: Union['fields.Base64', 'types.BytesWithAggregatesFilter']

    AND: List['DScalarWhereWithAggregatesInputRecursive1']
    OR: List['DScalarWhereWithAggregatesInputRecursive1']
    NOT: List['DScalarWhereWithAggregatesInputRecursive1']


class DScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """D arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    bool: Union[_bool, 'types.BooleanWithAggregatesFilter']
    xml: Union[_str, 'types.StringWithAggregatesFilter']
    json_: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    jsonb: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    binary: Union['fields.Base64', 'types.BytesWithAggregatesFilter']

    AND: List['DScalarWhereWithAggregatesInputRecursive2']
    OR: List['DScalarWhereWithAggregatesInputRecursive2']
    NOT: List['DScalarWhereWithAggregatesInputRecursive2']


class DScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """D arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    bool: Union[_bool, 'types.BooleanWithAggregatesFilter']
    xml: Union[_str, 'types.StringWithAggregatesFilter']
    json_: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    jsonb: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    binary: Union['fields.Base64', 'types.BytesWithAggregatesFilter']



class DGroupByOutput(TypedDict, total=False):
    id: _str
    bool: _bool
    xml: _str
    json_: 'fields.Json'
    jsonb: 'fields.Json'
    binary: 'fields.Base64'
    _sum: 'DSumAggregateOutput'
    _avg: 'DAvgAggregateOutput'
    _min: 'DMinAggregateOutput'
    _max: 'DMaxAggregateOutput'
    _count: 'DCountAggregateOutput'


class DAvgAggregateOutput(TypedDict, total=False):
    """D output for aggregating averages"""


class DSumAggregateOutput(TypedDict, total=False):
    """D output for aggregating sums"""


class DScalarAggregateOutput(TypedDict, total=False):
    """D output including scalar fields"""
    id: _str
    bool: _bool
    xml: _str
    json_: 'fields.Json'
    jsonb: 'fields.Json'
    binary: 'fields.Base64'


DMinAggregateOutput = DScalarAggregateOutput
DMaxAggregateOutput = DScalarAggregateOutput


class DMaxAggregateInput(TypedDict, total=False):
    """D input for aggregating by max"""
    id: bool
    bool: bool
    xml: bool
    json_: bool
    jsonb: bool
    binary: bool


class DMinAggregateInput(TypedDict, total=False):
    """D input for aggregating by min"""
    id: bool
    bool: bool
    xml: bool
    json_: bool
    jsonb: bool
    binary: bool


class DNumberAggregateInput(TypedDict, total=False):
    """D input for aggregating numbers"""


DAvgAggregateInput = DNumberAggregateInput
DSumAggregateInput = DNumberAggregateInput


DCountAggregateInput = TypedDict(
    'DCountAggregateInput',
    {
        'id': bool,
        'bool': bool,
        'xml': bool,
        'json_': bool,
        'jsonb': bool,
        'binary': bool,
        '_all': bool,
    },
    total=False,
)

DCountAggregateOutput = TypedDict(
    'DCountAggregateOutput',
    {
        'id': int,
        'bool': int,
        'xml': int,
        'json_': int,
        'jsonb': int,
        'binary': int,
        '_all': int,
    },
    total=False,
)


DKeys = Literal[
    'id',
    'bool',
    'xml',
    'json_',
    'jsonb',
    'binary',
]
DScalarFieldKeys = Literal[
    'id',
    'bool',
    'xml',
    'json_',
    'jsonb',
    'binary',
]
DScalarFieldKeysT = TypeVar('DScalarFieldKeysT', bound=DScalarFieldKeys)

DRelationalFieldKeys = _NoneType

# E types

class EOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the E create method"""
    id: _str


class ECreateInput(EOptionalCreateInput):
    """Required arguments to the E create method"""
    date: datetime.datetime
    time: datetime.datetime
    ts: datetime.datetime


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class EOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the E create method, without relations"""
    id: _str


class ECreateWithoutRelationsInput(EOptionalCreateWithoutRelationsInput):
    """Required arguments to the E create method, without relations"""
    date: datetime.datetime
    time: datetime.datetime
    ts: datetime.datetime

class EConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ECreateWithoutRelationsInput'
    where: 'EWhereUniqueInput'

class ECreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ECreateWithoutRelationsInput'
    connect: 'EWhereUniqueInput'
    connect_or_create: 'EConnectOrCreateWithoutRelationsInput'


class ECreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ECreateWithoutRelationsInput', List['ECreateWithoutRelationsInput']]
    connect: Union['EWhereUniqueInput', List['EWhereUniqueInput']]
    connect_or_create: Union['EConnectOrCreateWithoutRelationsInput', List['EConnectOrCreateWithoutRelationsInput']]

_EWhereUnique_id_Input = TypedDict(
    '_EWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

EWhereUniqueInput = _EWhereUnique_id_Input


class EUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    date: datetime.datetime
    time: datetime.datetime
    ts: datetime.datetime


class EUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    date: datetime.datetime
    time: datetime.datetime
    ts: datetime.datetime


class EUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ECreateWithoutRelationsInput']
    connect: List['EWhereUniqueInput']
    connect_or_create: List['EConnectOrCreateWithoutRelationsInput']
    set: List['EWhereUniqueInput']
    disconnect: List['EWhereUniqueInput']
    delete: List['EWhereUniqueInput']

    # TODO
    # update: List['EUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['EUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['EScalarWhereInput']
    # upsert: List['EUpserteWithWhereUniqueWithoutRelationsInput']


class EUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ECreateWithoutRelationsInput'
    connect: 'EWhereUniqueInput'
    connect_or_create: 'EConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'EUpdateInput'
    # upsert: 'EUpsertWithoutRelationsInput'


class EUpsertInput(TypedDict):
    create: 'ECreateInput'
    update: 'EUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_E_id_OrderByInput = TypedDict(
    '_E_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_E_date_OrderByInput = TypedDict(
    '_E_date_OrderByInput',
    {
        'date': 'SortOrder',
    },
    total=True
)

_E_time_OrderByInput = TypedDict(
    '_E_time_OrderByInput',
    {
        'time': 'SortOrder',
    },
    total=True
)

_E_ts_OrderByInput = TypedDict(
    '_E_ts_OrderByInput',
    {
        'ts': 'SortOrder',
    },
    total=True
)

_E_RelevanceInner = TypedDict(
    '_E_RelevanceInner',
    {
        'fields': 'List[EScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_E_RelevanceOrderByInput = TypedDict(
    '_E_RelevanceOrderByInput',
    {
        '_relevance': '_E_RelevanceInner',
    },
    total=True
)

EOrderByInput = Union[
    '_E_id_OrderByInput',
    '_E_date_OrderByInput',
    '_E_time_OrderByInput',
    '_E_ts_OrderByInput',
    '_E_RelevanceOrderByInput',
]



# recursive E types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

ERelationFilter = TypedDict(
    'ERelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class EListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class EInclude(TypedDict, total=False):
    """E relational arguments"""


    

class PostIncludeFromE(TypedDict, total=False):
    """Relational arguments for E"""
    author: Union[bool, 'UserArgsFromERecursive1']


class PostIncludeFromERecursive1(TypedDict, total=False):
    """Relational arguments for E"""
    author: Union[bool, 'UserArgsFromERecursive2']


class PostIncludeFromERecursive2(TypedDict, total=False):
    """Relational arguments for E"""

    

class PostArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    include: 'PostIncludeFromPostRecursive1'


class PostArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    include: 'PostIncludeFromPostRecursive2'


class PostArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    
    

class FindManyPostArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPostRecursive1'


class FindManyPostArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPostRecursive2'


class FindManyPostArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    
    

class UserIncludeFromE(TypedDict, total=False):
    """Relational arguments for E"""
    posts: Union[bool, 'FindManyPostArgsFromERecursive1']


class UserIncludeFromERecursive1(TypedDict, total=False):
    """Relational arguments for E"""
    posts: Union[bool, 'FindManyPostArgsFromERecursive2']


class UserIncludeFromERecursive2(TypedDict, total=False):
    """Relational arguments for E"""

    

class UserArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    
    

class FindManyUserArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class MIncludeFromE(TypedDict, total=False):
    """Relational arguments for E"""
    n: Union[bool, 'FindManyNArgsFromERecursive1']


class MIncludeFromERecursive1(TypedDict, total=False):
    """Relational arguments for E"""
    n: Union[bool, 'FindManyNArgsFromERecursive2']


class MIncludeFromERecursive2(TypedDict, total=False):
    """Relational arguments for E"""

    

class MArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    include: 'MIncludeFromMRecursive1'


class MArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    include: 'MIncludeFromMRecursive2'


class MArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    
    

class FindManyMArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromMRecursive1'


class FindManyMArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromMRecursive2'


class FindManyMArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    
    

class NIncludeFromE(TypedDict, total=False):
    """Relational arguments for E"""
    m: Union[bool, 'FindManyMArgsFromERecursive1']


class NIncludeFromERecursive1(TypedDict, total=False):
    """Relational arguments for E"""
    m: Union[bool, 'FindManyMArgsFromERecursive2']


class NIncludeFromERecursive2(TypedDict, total=False):
    """Relational arguments for E"""

    

class NArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    include: 'NIncludeFromNRecursive1'


class NArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    include: 'NIncludeFromNRecursive2'


class NArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    
    

class FindManyNArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromNRecursive1'


class FindManyNArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromNRecursive2'


class FindManyNArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    
    

class OneOptionalIncludeFromE(TypedDict, total=False):
    """Relational arguments for E"""
    many: Union[bool, 'FindManyManyRequiredArgsFromERecursive1']


class OneOptionalIncludeFromERecursive1(TypedDict, total=False):
    """Relational arguments for E"""
    many: Union[bool, 'FindManyManyRequiredArgsFromERecursive2']


class OneOptionalIncludeFromERecursive2(TypedDict, total=False):
    """Relational arguments for E"""

    

class OneOptionalArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    include: 'OneOptionalIncludeFromOneOptionalRecursive1'


class OneOptionalArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    include: 'OneOptionalIncludeFromOneOptionalRecursive2'


class OneOptionalArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    
    

class FindManyOneOptionalArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromOneOptionalRecursive1'


class FindManyOneOptionalArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromOneOptionalRecursive2'


class FindManyOneOptionalArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    
    

class ManyRequiredIncludeFromE(TypedDict, total=False):
    """Relational arguments for E"""
    one: Union[bool, 'OneOptionalArgsFromERecursive1']


class ManyRequiredIncludeFromERecursive1(TypedDict, total=False):
    """Relational arguments for E"""
    one: Union[bool, 'OneOptionalArgsFromERecursive2']


class ManyRequiredIncludeFromERecursive2(TypedDict, total=False):
    """Relational arguments for E"""

    

class ManyRequiredArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    include: 'ManyRequiredIncludeFromManyRequiredRecursive1'


class ManyRequiredArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    include: 'ManyRequiredIncludeFromManyRequiredRecursive2'


class ManyRequiredArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    
    

class FindManyManyRequiredArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromManyRequiredRecursive1'


class FindManyManyRequiredArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromManyRequiredRecursive2'


class FindManyManyRequiredArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    
    

class ListsIncludeFromE(TypedDict, total=False):
    """Relational arguments for E"""


class ListsIncludeFromERecursive1(TypedDict, total=False):
    """Relational arguments for E"""


class ListsIncludeFromERecursive2(TypedDict, total=False):
    """Relational arguments for E"""

    

class ListsArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    include: 'ListsIncludeFromListsRecursive1'


class ListsArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    include: 'ListsIncludeFromListsRecursive2'


class ListsArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    
    

class FindManyListsArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromListsRecursive1'


class FindManyListsArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromListsRecursive2'


class FindManyListsArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    
    

class AIncludeFromE(TypedDict, total=False):
    """Relational arguments for E"""


class AIncludeFromERecursive1(TypedDict, total=False):
    """Relational arguments for E"""


class AIncludeFromERecursive2(TypedDict, total=False):
    """Relational arguments for E"""

    

class AArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    include: 'AIncludeFromARecursive1'


class AArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    include: 'AIncludeFromARecursive2'


class AArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    
    

class FindManyAArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromARecursive1'


class FindManyAArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromARecursive2'


class FindManyAArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    
    

class BIncludeFromE(TypedDict, total=False):
    """Relational arguments for E"""


class BIncludeFromERecursive1(TypedDict, total=False):
    """Relational arguments for E"""


class BIncludeFromERecursive2(TypedDict, total=False):
    """Relational arguments for E"""

    

class BArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    include: 'BIncludeFromBRecursive1'


class BArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    include: 'BIncludeFromBRecursive2'


class BArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    
    

class FindManyBArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromBRecursive1'


class FindManyBArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromBRecursive2'


class FindManyBArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    
    

class CIncludeFromE(TypedDict, total=False):
    """Relational arguments for E"""


class CIncludeFromERecursive1(TypedDict, total=False):
    """Relational arguments for E"""


class CIncludeFromERecursive2(TypedDict, total=False):
    """Relational arguments for E"""

    

class CArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    include: 'CIncludeFromCRecursive1'


class CArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    include: 'CIncludeFromCRecursive2'


class CArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    
    

class FindManyCArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromCRecursive1'


class FindManyCArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromCRecursive2'


class FindManyCArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    
    

class DIncludeFromE(TypedDict, total=False):
    """Relational arguments for E"""


class DIncludeFromERecursive1(TypedDict, total=False):
    """Relational arguments for E"""


class DIncludeFromERecursive2(TypedDict, total=False):
    """Relational arguments for E"""

    

class DArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    include: 'DIncludeFromDRecursive1'


class DArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    include: 'DIncludeFromDRecursive2'


class DArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    
    

class FindManyDArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromDRecursive1'


class FindManyDArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromDRecursive2'


class FindManyDArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    
    

class EIncludeFromE(TypedDict, total=False):
    """Relational arguments for E"""


class EIncludeFromERecursive1(TypedDict, total=False):
    """Relational arguments for E"""


class EIncludeFromERecursive2(TypedDict, total=False):
    """Relational arguments for E"""

    

class EArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    include: 'EIncludeFromERecursive1'


class EArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    include: 'EIncludeFromERecursive2'


class EArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    
    

class FindManyEArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromERecursive1'


class FindManyEArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromERecursive2'


class FindManyEArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    


FindManyEArgs = FindManyEArgsFromE
FindFirstEArgs = FindManyEArgsFromE


    

class EWhereInput(TypedDict, total=False):
    """E arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    date: Union[datetime.datetime, 'types.DateTimeFilter']
    time: Union[datetime.datetime, 'types.DateTimeFilter']
    ts: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['EWhereInputRecursive1', List['EWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['EWhereInputRecursive1']
    OR: List['EWhereInputRecursive1']
    NOT: List['EWhereInputRecursive1']


class EWhereInputRecursive1(TypedDict, total=False):
    """E arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    date: Union[datetime.datetime, 'types.DateTimeFilter']
    time: Union[datetime.datetime, 'types.DateTimeFilter']
    ts: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['EWhereInputRecursive2', List['EWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['EWhereInputRecursive2']
    OR: List['EWhereInputRecursive2']
    NOT: List['EWhereInputRecursive2']


class EWhereInputRecursive2(TypedDict, total=False):
    """E arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    date: Union[datetime.datetime, 'types.DateTimeFilter']
    time: Union[datetime.datetime, 'types.DateTimeFilter']
    ts: Union[datetime.datetime, 'types.DateTimeFilter']



# aggregate E types


    

class EScalarWhereWithAggregatesInput(TypedDict, total=False):
    """E arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    date: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    time: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    ts: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['EScalarWhereWithAggregatesInputRecursive1']
    OR: List['EScalarWhereWithAggregatesInputRecursive1']
    NOT: List['EScalarWhereWithAggregatesInputRecursive1']


class EScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """E arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    date: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    time: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    ts: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['EScalarWhereWithAggregatesInputRecursive2']
    OR: List['EScalarWhereWithAggregatesInputRecursive2']
    NOT: List['EScalarWhereWithAggregatesInputRecursive2']


class EScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """E arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    date: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    time: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    ts: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class EGroupByOutput(TypedDict, total=False):
    id: _str
    date: datetime.datetime
    time: datetime.datetime
    ts: datetime.datetime
    _sum: 'ESumAggregateOutput'
    _avg: 'EAvgAggregateOutput'
    _min: 'EMinAggregateOutput'
    _max: 'EMaxAggregateOutput'
    _count: 'ECountAggregateOutput'


class EAvgAggregateOutput(TypedDict, total=False):
    """E output for aggregating averages"""


class ESumAggregateOutput(TypedDict, total=False):
    """E output for aggregating sums"""


class EScalarAggregateOutput(TypedDict, total=False):
    """E output including scalar fields"""
    id: _str
    date: datetime.datetime
    time: datetime.datetime
    ts: datetime.datetime


EMinAggregateOutput = EScalarAggregateOutput
EMaxAggregateOutput = EScalarAggregateOutput


class EMaxAggregateInput(TypedDict, total=False):
    """E input for aggregating by max"""
    id: bool
    date: bool
    time: bool
    ts: bool


class EMinAggregateInput(TypedDict, total=False):
    """E input for aggregating by min"""
    id: bool
    date: bool
    time: bool
    ts: bool


class ENumberAggregateInput(TypedDict, total=False):
    """E input for aggregating numbers"""


EAvgAggregateInput = ENumberAggregateInput
ESumAggregateInput = ENumberAggregateInput


ECountAggregateInput = TypedDict(
    'ECountAggregateInput',
    {
        'id': bool,
        'date': bool,
        'time': bool,
        'ts': bool,
        '_all': bool,
    },
    total=False,
)

ECountAggregateOutput = TypedDict(
    'ECountAggregateOutput',
    {
        'id': int,
        'date': int,
        'time': int,
        'ts': int,
        '_all': int,
    },
    total=False,
)


EKeys = Literal[
    'id',
    'date',
    'time',
    'ts',
]
EScalarFieldKeys = Literal[
    'id',
    'date',
    'time',
    'ts',
]
EScalarFieldKeysT = TypeVar('EScalarFieldKeysT', bound=EScalarFieldKeys)

ERelationalFieldKeys = _NoneType



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields
'''