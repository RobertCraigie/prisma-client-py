{% set annotations = true %}
{% include '_header.py.jinja' %}
{% from '_utils.py.jinja' import is_async, maybe_async_def, maybe_await, recursive_types, active_provider with context %}
# -- template actions.py.jinja --
from typing import TypeVar
import warnings
import functools as _functools

from . import types, errors, bases, _parsers
from ._types import NotGiven, NotGivenOr, NOT_GIVEN
from ._helpers import is_mapping
from ._compat import model_parse

if TYPE_CHECKING:
    from .client import Client
    from .bases import _PrismaModel
    from .engine.json.serializer import SelectionSet


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')

{# TODO: support sampling combined unique constraints #}
{% macro sample_where_unique(model) %}
{% set id_field = model.id_field %}
{% if id_field %}'{{ id_field.name }}': {{ id_field.get_sample_data() }},{% else %}# {{ model.name }} where unique filter
{% endif %}
{% endmacro %}
{% set base_error_doc = clean_multiline('''
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
''')
%}
{% set query_error_doc = clean_multiline('''
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
''')
%}
{% set filter_error_doc = clean_multiline('''
        prisma.errors.RecordNotFoundError
            A record is required to exist but was not found
''')
%}
{% for model in dmmf.datamodel.models %}
{% set RawModelType = "prisma.models.%s" % model.name %}
{% set include_doc = 'Specifies which relations should be loaded on the returned %s model' % model.name %}

{% set ModelType = '_PrismaModelT' %}
class {{ model.name }}Actions(Generic[{{ ModelType }}]):
    __slots__ = (
        '_client',
        '_model',
        '_model_parser',
    )

    def __init__(self, client: 'Client', model: Type[{{ ModelType }}]) -> None:
        self._client = client
        self._model = model
        self._model_parser = _functools.partial(model_parse, self._model)

    {% if active_provider != 'mongodb' %}
    {{ maybe_async_def }}query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[{{ ModelType }}]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[{{ RawModelType }}]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        {{ base_error_doc }}

        Example
        -------
        {% set field = model.sampler().get_field() %}
        ```py
        users = {{ maybe_await }}{{ model.name }}.prisma().query_raw(
            'SELECT * FROM {{ model.name }} WHERE {{ field.name }} = {{ sql_param() }}',
            {{ field.get_sample_data() }},
        )
        ```
        """
        return {{ maybe_await }}self._client.query_raw(query, *args, model=self._model)

    {{ maybe_async_def }}query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[{{ ModelType }}]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        {{ RawModelType }}
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        {{ base_error_doc }}

        Example
        -------
        {% set field = model.sampler().get_field() %}
        ```py
        user = {{ maybe_await }}{{ model.name }}.prisma().query_first(
            'SELECT * FROM {{ model.name }} WHERE {{ field.name }} = {{ sql_param() }}',
            {{ field.get_sample_data() }},
        )
        ```
        """
        return {{ maybe_await }}self._client.query_first(query, *args, model=self._model)
    {% endif %}

    {{ maybe_async_def }}create(
        self,
        data: types.{{ model.name }}CreateInput,
        include: NotGivenOr[types.{{ model.name}}Include | None] = NOT_GIVEN,
    ) -> {{ ModelType }}:
        """Create a new {{ model.name }} record.

        Parameters
        ----------
        data
            {{ model.name }} record data
        include
            {{ include_doc }}

        Returns
        -------
        {{ RawModelType }}
            The created {{ model.name }} record

        Raises
        ------
        {{ query_error_doc }}
        {{ base_error_doc }}

        Example
        -------
        ```py
        # create a {{ model.name }} record from just the required fields
        {{ model.name.lower() }} = {{ maybe_await }}{{ model.name }}.prisma().create(
            data={
                # data to create a {{ model.name }} record
                {% for field in model.scalar_fields %}
                {% if field.required_on_create %}
                '{{ field.name }}': {{ field.get_sample_data() }},
                {% endif %}
                {% endfor %}
            },
        )
        ```
        """
        return {{ maybe_await }}self._client._execute_json_proto(
            method='create',
            arguments={
                'data': data,
                'include': include,
            },
            data_path=[],
            model=self._model,
            parser=self._model_parser,
        )

    {{ maybe_async_def }}create_many(
        self,
        data: List[types.{{ model.name }}CreateWithoutRelationsInput],
        *,
        skip_duplicates: NotGivenOr[bool | None] = NOT_GIVEN,
    ) -> int:
        """Create multiple {{ model.name }} records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of {{ model.name }} record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        {{ query_error_doc }}
        {{ base_error_doc }}

        Example
        -------
        ```py
        total = {{ maybe_await }}{{ model.name }}.prisma().create_many(
            data=[
                {% for _ in range(2) %}
                {
                    # data to create a {{ model.name }} record
                    {% for field in model.scalar_fields %}
                    {% if field.required_on_create %}
                    '{{ field.name }}': {{ field.get_sample_data() }},
                    {% endif %}
                    {% endfor %}
                },
                {% endfor %}
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        return {{ maybe_await }}self._client._execute_json_proto(
            method='create_many',
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            data_path=['count'],
            model=self._model,
            parser=int,
        )

    {{ maybe_async_def }}delete(
        self,
        where: types.{{ model.name }}WhereUniqueInput,
        include: NotGivenOr[types.{{ model.name}}Include | None] = NOT_GIVEN,
    ) -> Optional[{{ ModelType }}]:
        """Delete a single {{ model.name }} record.

        Parameters
        ----------
        where
            {{ model.name }} filter to select the record to be deleted, must be unique
        include
            {{ include_doc }}

        Returns
        -------
        {{ RawModelType }}
            The deleted {{ model.name }} record
        None
            Could not find a record to delete

        Raises
        ------
        {{ base_error_doc }}
        {{ query_error_doc }}

        Example
        -------
        ```py
        {{ model.name.lower() }} = {{ maybe_await }}{{ model.name }}.prisma().delete(
            where={
                {{ sample_where_unique(model) }}
            },
        )
        ```
        """
        return {{ maybe_await }}self._client._execute_json_proto(
            method='delete',
            arguments={
                'where': where,
                'include': include,
            },
            data_path=[],
            model=self._model,
            parser=self._model_parser,
            ignore_exceptions=(errors.RecordNotFoundError,)
        )

    {{ maybe_async_def }}find_unique(
        self,
        where: types.{{ model.name }}WhereUniqueInput,
        include: NotGivenOr[types.{{ model.name}}Include | None] = NOT_GIVEN
    ) -> Optional[{{ ModelType }}]:
        """Find a unique {{ model.name }} record.

        Parameters
        ----------
        where
            {{ model.name }} filter to find the record, must be unique
        include
            {{ include_doc }}

        Returns
        -------
        {{ RawModelType }}
            The found {{ model.name }} record
        None
            No record matching the given input could be found

        Raises
        ------
        {{ base_error_doc }}
        {{ query_error_doc }}

        Example
        -------
        ```py
        {{ model.name.lower() }} = {{ maybe_await }}{{ model.name }}.prisma().find_unique(
            where={
                {{ sample_where_unique(model) }}
            },
        )
        ```
        """
        return {{ maybe_await }}self._client._execute_json_proto(
            method='find_unique',
            arguments={
                'where': where,
                'include': include,
            },
            data_path=[],
            model=self._model,
            parser=_parsers.allow_none(self._model_parser),
        )

    {{ maybe_async_def }}find_unique_or_raise(
        self,
        where: types.{{ model.name }}WhereUniqueInput,
        include: NotGivenOr[Optional[types.{{ model.name}}Include]] = NOT_GIVEN
    ) -> {{ ModelType }}:
        """Find a unique {{ model.name }} record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            {{ model.name }} filter to find the record, must be unique
        include
            {{ include_doc }}

        Returns
        -------
        {{ RawModelType }}
            The found {{ model.name }} record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        {{ base_error_doc }}
        {{ query_error_doc }}

        Example
        -------
        ```py
        {{ model.name.lower() }} = {{ maybe_await }}{{ model.name }}.prisma().find_unique_or_raise(
            where={
                {{ sample_where_unique(model) }}
            },
        )
        ```
        """
        return {{ maybe_await }}self._client._execute_json_proto(
            method='find_unique_or_raise',
            arguments={
                'where': where,
                'include': include,
            },
            data_path=[],
            model=self._model,
            parser=self._model_parser,
        )

    {{ maybe_async_def }}find_many(
        self,
        take: NotGivenOr[int | None] = NOT_GIVEN,
        skip: NotGivenOr[int | None] = NOT_GIVEN,
        where: NotGivenOr[types.{{ model.name }}WhereInput | None] = NOT_GIVEN,
        cursor: NotGivenOr[types.{{ model.name }}WhereUniqueInput | None] = NOT_GIVEN,
        include: NotGivenOr[types.{{ model.name }}Include | None] = NOT_GIVEN,
        order: NotGivenOr[types.{{ model.name }}OrderByInput | List[types.{{ model.name }}OrderByInput] | None] = NOT_GIVEN,
        distinct: NotGivenOr[List[types.{{ model.name }}ScalarFieldKeys] | None] = NOT_GIVEN,
    ) -> List[{{ ModelType }}]:
        """Find multiple {{ model.name }} records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of {{ model.name }} records returned
        skip
            Ignore the first N results
        where
            {{ model.name }} filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            {{ include_doc }}
        order
            Order the returned {{ model.name }} records by any field
        distinct
            Filter {{ model.name }} records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[{{ RawModelType }}]
            The list of all {{ model.name }} records that could be found

        Raises
        ------
        {{ base_error_doc }}

        Example
        -------
        ```py
        # find the first 10 {{ model.name }} records
        {{ model.plural_name.lower() }} = {{ maybe_await }}{{ model.name }}.prisma().find_many(take=10)

        {% set field = model.sampler().get_field() %}
        # find the first 5 {{ model.name }} records ordered by the {{ field.name }} field
        {{ model.plural_name.lower() }} = {{ maybe_await }}{{ model.name }}.prisma().find_many(
            take=5,
            order={
                '{{ field.name }}': 'desc',
            },
        )
        ```
        """
        return {{ maybe_await }}self._client._execute_json_proto(
            method='find_many',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
            data_path=[],
            model=self._model,
            parser=_parsers.as_list(self._model_parser),
        )

    {{ maybe_async_def }}find_first(
        self,
        skip: NotGivenOr[int | None] = NOT_GIVEN,
        where: NotGivenOr[types.{{ model.name }}WhereInput | None] = NOT_GIVEN,
        cursor: NotGivenOr[types.{{ model.name }}WhereUniqueInput | None] = NOT_GIVEN,
        include: NotGivenOr[types.{{ model.name }}Include | None] = NOT_GIVEN,
        order: NotGivenOr[types.{{ model.name }}OrderByInput | List[types.{{ model.name }}OrderByInput] | None] = NOT_GIVEN,
        distinct: NotGivenOr[List[types.{{ model.name }}ScalarFieldKeys] | None] = NOT_GIVEN,
    ) -> Optional[{{ ModelType }}]:
        """Find a single {{ model.name }} record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            {{ model.name }} filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            {{ include_doc }}
        order
            Order the returned {{ model.name }} records by any field
        distinct
            Filter {{ model.name }} records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        {{ RawModelType }}
            The first {{ model.name }} record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        {{ base_error_doc }}

        Example
        -------
        ```py
        {% set field = model.sampler().get_field() %}
        # find the second {{ model.name }} record ordered by the {{ field.name }} field
        {{ model.name.lower() }} = {{ maybe_await }}{{ model.name }}.prisma().find_first(
            skip=1,
            order={
                '{{ field.name }}': 'desc',
            },
        )
        ```
        """
        return {{ maybe_await }}self._client._execute_json_proto(
            method='find_first',
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
            data_path=[],
            model=self._model,
            parser=_parsers.allow_none(self._model_parser),
        )

    {{ maybe_async_def }}find_first_or_raise(
        self,
        skip: NotGivenOr[int | None] = NOT_GIVEN,
        where: NotGivenOr[types.{{ model.name }}WhereInput | None] = NOT_GIVEN,
        cursor: NotGivenOr[types.{{ model.name }}WhereUniqueInput | None] = NOT_GIVEN,
        include: NotGivenOr[types.{{ model.name }}Include | None] = NOT_GIVEN,
        order: NotGivenOr[types.{{ model.name }}OrderByInput | list[types.{{ model.name }}OrderByInput] | None] = NOT_GIVEN,
        distinct: NotGivenOr[list[types.{{ model.name }}ScalarFieldKeys] | None] = NOT_GIVEN,
    ) -> {{ ModelType }}:
        """Find a single {{ model.name }} record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            {{ model.name }} filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            {{ include_doc }}
        order
            Order the returned {{ model.name }} records by any field
        distinct
            Filter {{ model.name }} records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        {{ RawModelType }}
            The first {{ model.name }} record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        {{ base_error_doc }}

        Example
        -------
        ```py
        {% set field = model.sampler().get_field() %}
        # find the second {{ model.name }} record ordered by the {{ field.name }} field
        {{ model.name.lower() }} = {{ maybe_await }}{{ model.name }}.prisma().find_first_or_raise(
            skip=1,
            order={
                '{{ field.name }}': 'desc',
            },
        )
        ```
        """
        return {{ maybe_await }}self._client._execute_json_proto(
            method='find_first_or_raise',
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
            data_path=[],
            model=self._model,
            parser=self._model_parser,
        )

    {{ maybe_async_def }}update(
        self,
        data: types.{{ model.name }}UpdateInput,
        where: types.{{ model.name }}WhereUniqueInput,
        include: NotGivenOr[types.{{ model.name}}Include | None] = NOT_GIVEN
    ) -> Optional[{{ ModelType }}]:
        """Update a single {{ model.name }} record.

        Parameters
        ----------
        data
            {{ model.name }} record data specifying what to update
        where
            {{ model.name }} filter to select the unique record to create / update
        include
            {{ include_doc }}

        Returns
        -------
        {{ RawModelType }}
            The updated {{ model.name }} record
        None
            No record could be found

        Raises
        ------
        {{ base_error_doc }}

        Example
        -------
        ```py
        {{ model.name.lower() }} = {{ maybe_await }}{{ model.name }}.prisma().update(
            where={
                {{ sample_where_unique(model) }}
            },
            data={
                # data to update the {{ model.name }} record to
            },
        )
        ```
        """
        return {{ maybe_await }}self._client._execute_json_proto(
            method='update',
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
            data_path=[],
            model=self._model,
            parser=self._model_parser,
            ignore_exceptions=(errors.RecordNotFoundError,),
        )

    {{ maybe_async_def }}upsert(
        self,
        where: types.{{ model.name }}WhereUniqueInput,
        data: types.{{ model.name }}UpsertInput,
        include: NotGivenOr[types.{{ model.name}}Include | None] = NOT_GIVEN,
    ) -> {{ ModelType }}:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            {{ model.name }} filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            {{ include_doc }}

        Returns
        -------
        {{ RawModelType }}
            The created or updated {{ model.name }} record

        Raises
        ------
        {{ base_error_doc }}
        {{ query_error_doc }}

        Example
        -------
        ```py
        {% if model.id_field %}
        {% set id_sample = model.id_field.get_sample_data() %}
        {{ model.name.lower() }} = {{ maybe_await }}{{ model.name }}.prisma().upsert(
            where={
                '{{ model.id_field.name }}': {{ id_sample }},
            },
            data={
                'create': {
                    '{{ model.id_field.name }}': {{ id_sample }},
                    {% for field in model.scalar_fields %}
                    {% if field.required_on_create and not field.name == model.id_field.name %}
                    '{{ field.name }}': {{ field.get_sample_data(increment=False) }},
                    {% endif %}
                    {% endfor %}
                },
                'update': {
                    {% for field in model.scalar_fields %}
                    {% if field.required_on_create and not field.name == model.id_field.name %}
                    '{{ field.name }}': {{ field.get_sample_data(increment=False) }},
                    {% endif %}
                    {% endfor %}
                },
            },
        )
        {% else %}
        {{ model.name.lower() }} = {{ maybe_await }}{{ model.name }}.prisma().upsert(
            where={
                # {{ model.name }} where unique filter
            },
            data={
                'create': {
                    # {{ model.name }} data to be set if the record does not exist
                },
                'update': {
                    # {{ model.name }} data to be set if the record does exist
                },
            },
        )
        {% endif %}
        ```
        """
        return {{ maybe_await }}self._client._execute_json_proto(
            method='upsert',
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
            data_path=[],
            model=self._model,
            parser=self._model_parser,
        )

    {{ maybe_async_def }}update_many(
        self,
        data: types.{{ model.name }}UpdateManyMutationInput,
        where: types.{{ model.name }}WhereInput,
    ) -> int:
        """Update multiple {{ model.name }} records

        Parameters
        ----------
        data
            {{ model.name }} data to update the selected {{ model.name }} records to
        where
            Filter to select the {{ model.name }} records to update

        Returns
        -------
        int
            The total number of {{ model.name }} records that were updated

        Raises
        ------
        {{ base_error_doc }}

        Example
        -------
        ```py
        # update all {{ model.name }} records
        total = {{ maybe_await }}{{ model.name }}.prisma().update_many(
            data={
                {% set field = model.sampler().get_field() %}
                '{{ field.name }}': {{ field.get_sample_data() }}
            },
            where={}
        )
        ```
        """
        return {{ maybe_await }}self._client._execute_json_proto(
            method='update_many',
            arguments={
                'data': data,
                'where': where,
            },
            data_path=['count'],
            model=self._model,
            parser=int,
        )

    @overload
    {{ maybe_async_def }}count(
        self,
        select: NotGivenOr[None] = NOT_GIVEN,
        take: NotGivenOr[int | None] = NOT_GIVEN,
        skip: NotGivenOr[int | None] = NOT_GIVEN,
        where: NotGivenOr[types.{{ model.name }}WhereInput | None] = NOT_GIVEN,
        cursor: NotGivenOr[types.{{ model.name }}WhereUniqueInput | None] = NOT_GIVEN,
    ) -> int:
        {# We add the docstring here as Pylance / VSCode picks up docstrings
           from the overloads of a function.

           We also add the docstring to the final implementation function so that it
           can also be accessed at runtime.
        #}
        {% macro count_doc() %}
"""Count the number of {{ model.name }} records present in the database

        Parameters
        ----------
        select
            Select the {{ model.name }} fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            {{ model.name }} filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.{{ model.name }}CountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        {{ base_error_doc }}

        Example
        -------
        ```py
        # total: int
        total = {{ maybe_await }}{{ model.name }}.prisma().count()

        # results: prisma.types.{{ model.name }}CountAggregateOutput
        results = {{ maybe_await }}{{ model.name }}.prisma().count(
            select={
                '_all': True,
                '{{ model.sampler().get_field().name }}': True,
            },
        )
        ```
        """
        {% endmacro %}
        {{ count_doc() }}

    @overload
    {{ maybe_async_def }}count(
        self,
        select: types.{{ model.name }}CountAggregateInput,
        take: NotGivenOr[int | None] = NOT_GIVEN,
        skip: NotGivenOr[int | None] = NOT_GIVEN,
        where: NotGivenOr[types.{{ model.name }}WhereInput | None] = NOT_GIVEN,
        cursor: NotGivenOr[types.{{ model.name }}WhereUniqueInput | None] = NOT_GIVEN,
    ) -> types.{{ model.name }}CountAggregateOutput:
        ...

    {{ maybe_async_def }}count(
        self,
        select: NotGivenOr[types.{{ model.name }}CountAggregateInput | None] = NOT_GIVEN,
        take: NotGivenOr[int | None] = NOT_GIVEN,
        skip: NotGivenOr[int | None] = NOT_GIVEN,
        where: NotGivenOr[types.{{ model.name }}WhereInput | None] = NOT_GIVEN,
        cursor: NotGivenOr[types.{{ model.name }}WhereUniqueInput | None] = NOT_GIVEN,
    ) -> Union[int, types.{{ model.name }}CountAggregateOutput]:
        {{ count_doc() }}
        selection = select or {'_all': True}

        def parser(value: Any) -> int | types.{{ model.name }}CountAggregateOutput:
            if is_mapping(select):
                return cast(types.{{ model.name }}CountAggregateOutput, value['_count'])
            return int(value['_count']['_all'])

        return {{ maybe_await }}self._client._execute_json_proto(
            method='count',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
                'select': {
                    '_count': {
                        'select': selection,
                    },
                },
            },
            data_path=[],
            model=self._model,
            parser=parser,
        )

    {{ maybe_async_def }}delete_many(
        self,
        where: NotGivenOr[types.{{ model.name }}WhereInput | None] = NOT_GIVEN
    ) -> int:
        """Delete multiple {{ model.name }} records.

        Parameters
        ----------
        where
            Optional {{ model.name }} filter to find the records to be deleted

        Returns
        -------
        int
            The total number of {{ model.name }} records that were deleted

        Raises
        ------
        {{ base_error_doc }}

        Example
        -------
        ```py
        # delete all {{ model.name }} records
        total = {{ maybe_await }}{{ model.name }}.prisma().delete_many()
        ```
        """
        return {{ maybe_await }}self._client._execute_json_proto(
            method='delete_many',
            arguments={
                'where': where,
            },
            data_path=['count'],
            model=self._model,
            parser=int,
        )

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    {{ maybe_async_def }}group_by(
        self,
        {% if recursive_types %}
        by: list['types.{{ model.name }}ScalarFieldKeysT'],
        {% else %}
        by: list['types.{{ model.name }}ScalarFieldKeys'],
        {% endif %}
        *,
        where: NotGivenOr['types.{{ model.name }}WhereInput | None'] = NOT_GIVEN,
        take: NotGivenOr[int | None] = NOT_GIVEN,
        skip: NotGivenOr[int | None] = NOT_GIVEN,
        avg: NotGivenOr['types.{{ model.name }}AvgAggregateInput | None'] = NOT_GIVEN,
        sum: NotGivenOr['types.{{ model.name }}SumAggregateInput | None'] = NOT_GIVEN,
        min: NotGivenOr['types.{{ model.name }}MinAggregateInput | None'] = NOT_GIVEN,
        max: NotGivenOr['types.{{ model.name }}MaxAggregateInput | None'] = NOT_GIVEN,
        having: NotGivenOr['types.{{ model.name }}ScalarWhereWithAggregatesInput | None'] = NOT_GIVEN,
        count: NotGivenOr['bool | types.{{ model.name }}CountAggregateInput | None'] = NOT_GIVEN,
        {% if recursive_types %}
        order: NotGivenOr[Mapping['types.{{ model.name }}ScalarFieldKeysT', 'types.SortOrder'] | list[Mapping['types.{{ model.name }}ScalarFieldKeysT', 'types.SortOrder']] | None] = NOT_GIVEN,
        {% else %}
        order: NotGivenOr[Mapping['types.{{ model.name }}ScalarFieldKeys', 'types.SortOrder'] | list[Mapping['types.{{ model.name }}ScalarFieldKeys', 'types.SortOrder']] | None] = NOT_GIVEN,
        {% endif %}
    ) -> list['types.{{ model.name }}GroupByOutput']:
        """Group {{ model.name }} records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar {{ model.name }} fields to group records by
        where
            {{ model.name }} filter to select records
        take
            Limit the maximum number of {{ model.name }} records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.{{ model.name }}GroupByOutput]
            A list of dictionaries representing the {{ model.name }} record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        {{ base_error_doc }}

        Example
        -------
        ```py
        {% set field = model.sampler().get_field().name %}
        # group {{ model.name }} records by {{ field }} values
        # and count how many records are in each group
        results = {{ maybe_await }}{{ model.name }}.prisma().group_by(
            ['{{ field }}'],
            count=True,
        )
        ```
        """
        if not order:
            if take:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        selection: SelectionSet = {key: True for key in by}
        if avg:
            selection['_avg'] = {'select': avg}

        if min:
            selection['_min'] = {'select': min}

        if sum:
            selection['_sum'] = {'select': sum}

        if max:
            selection['_max'] = {'select': max}

        if count:
            if count is True:
                selection['_count'] = {'select': {'_all': True}}
            elif isinstance(count, dict):
                selection['_count'] = {'select': count}

        return {{ maybe_await }}self._client._execute_json_proto(
            method='group_by',
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
                'select': selection,
            },
            model=self._model,
            data_path=[],
            parser=lambda v: v,
        )

{% endfor %}


from . import models
