{% include '_header.py.jinja' %}
{% from '_utils.py.jinja' import sleep, is_async, maybe_async_def, maybe_await with context %}
# -- template engine/library.py.jinja --

import os
import time
import json
import asyncio
import logging
from functools import wraps

from . import utils, errors
from .abstract import AbstractEngine
from ..utils import DEBUG
from ..utils import time_since
from ..types import DatasourceOverride
from .._types import CallableT
from ..generator.models import EngineType
import _prisma_query_engine as pqe
from _prisma_query_engine import PythonEngine as _PythonEngine


__all__ = (
    'LibraryEngine',
)

log: logging.Logger = logging.getLogger(__name__)


# TODO: all errors
RUST_ERROR_MAPPING: Dict[Type[Exception], Type[Exception]] = {
    pqe.NotConnectedError: errors.NotConnectedError,
    pqe.AlreadyConnectedError: errors.AlreadyConnectedError,
}

# TODO: move to utils?
def transform_rust_errors(func: CallableT) -> CallableT:

    @wraps(func)
    def wrapper(*args: Any, **kwargs: Any) -> Any:
        try:
            return func(*args, **kwargs)
        except pqe.PrismaRustError as exc:
            mapped = RUST_ERROR_MAPPING.get(type(exc))
            if mapped is not None:
                raise mapped()

            raise exc

    return cast(CallableT, wrapper)


class PythonEngine(_PythonEngine):
    """Python wrapper over the native rust class due to:

    https://github.com/awestlake87/pyo3-asyncio/issues/51
    """

    # TODO: transform errors for constructing too

    @transform_rust_errors
    def query_sync(self, query: str) -> str:
        return super().query_sync(query)

    @transform_rust_errors
    def connect_sync(self, timeout: int) -> None:
        return super().connect_sync(timeout)

    @transform_rust_errors
    def disconnect_sync(self) -> None:
        return super().disconnect_sync()

    @transform_rust_errors
    async def query(self, query: str) -> str:
        return await super().query(query)

    @transform_rust_errors
    async def connect(self) -> None:
        return await super().connect()

    @transform_rust_errors
    async def disconnect(self) -> None:
        return await super().disconnect()


class LibraryEngine(AbstractEngine):
    dml: str
    kind: EngineType = EngineType.library

    def __init__(self, *, dml: str, log_queries: bool = False):
        self.dml = dml
        self._log_queries = log_queries
        self._engine = None  # type: Optional[PythonEngine]

    def __del__(self) -> None:
        self.stop()

    {# TODO: decide on a proper solution #}
    {% if is_async %}
    def close(self) -> None:
        # if self._engine is not None:
        #     self._engine.disconnect_sync()
        pass

    async def aclose(self) -> None:
        if self._engine is not None:
            await self._engine.disconnect()
    {% else %}
    def close(self) -> None:
        if self._engine is not None:
            self._engine.disconnect_sync()

    async def aclose(self) -> None:
        # if self._engine is not None:
        #     await self._engine.disconnect()
        pass
    {% endif %}

    {{ maybe_async_def }}connect(
        self,
        timeout: int = 10,
        datasources: Optional[List[DatasourceOverride]] = None,
    ) -> None:
        log.debug('Connecting to query engine')
        if self._engine is not None:
            raise errors.AlreadyConnectedError('Already connected to the query engine')

        start = time.monotonic()

        # TODO: test logging

        if DEBUG:
            log_level = 'info'
        else:
            log_level = 'error'

        env = os.environ.copy()
        env.update(
            PRISMA_DML=self.dml,
            RUST_LOG=log_level,
            RUST_LOG_FORMAT='json',
            PRISMA_CLIENT_ENGINE_TYPE='library',
        )

        if datasources is None:
            overrides: Dict[str, str] = {}
        else:
            # TODO: proper fix for typing
            overrides = {
                cast(Any, ds)['name']: ds['url']
                for ds in datasources
            }

        engine = PythonEngine(
            env=env,
            log_level='error',
            log_queries=self._log_queries,
            datamodel=self.dml,
            datasource_overrides=overrides,
            ignore_env_var_errors=False,
        )
        {% if is_async %}
        await asyncio.wait_for(engine.connect(), timeout=timeout)
        {% else %}
        engine.connect_sync(timeout)
        {% endif %}

        self._engine = engine

        log.debug('Connecting to query engine took %s', time_since(start))

    {{ maybe_async_def }}query(self, content: str) -> Any:
        engine = self._engine
        if engine is None:
            raise errors.NotConnectedError('Not connected to the query engine')

        {% if is_async %}
        resp = await engine.query(content)
        {% else %}
        resp = engine.query_sync(content)
        {% endif %}

        try:
            data = json.loads(resp)
        except Exception:
            # TODO:
            raise

        errors_data = data.get('errors')
        if errors_data:
            return utils.handle_response_errors(errors_data)

        return data


# black does not respect the fmt: off comment without this
# fmt: on

